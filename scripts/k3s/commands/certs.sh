#!/usr/bin/env bash

# Certificate configuration
CERTS_DIR="$SCRIPT_DIR/certs"
CA_KEY="$CERTS_DIR/ca-key.pem"
CA_CERT="$CERTS_DIR/ca-cert.pem"
SERVER_KEY="$CERTS_DIR/server-key.pem"
SERVER_CERT="$CERTS_DIR/server-cert.pem"

# Function to create a self-signed CA ClusterIssuer for local development
create_self_signed_issuer() {
    print_status "Creating self-signed CA ClusterIssuer for local development..."
    
    # First create a self-signed CA certificate
    cat <<EOF | kubectl_exec apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: nano-local-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: Nano Local CA
  secretName: nano-local-ca-secret
  duration: 8760h # 1 year
  renewBefore: 720h # 30 days
  subject:
    organizationalUnits:
      - "Nano Local Development"
    organizations:
      - "Nano CE"
    countries:
      - "US"
  issuerRef:
    name: selfsigned-issuer
    kind: ClusterIssuer
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: nano-local-ca-issuer
spec:
  ca:
    secretName: nano-local-ca-secret
EOF
    
    if [ $? -eq 0 ]; then
        print_success "Self-signed CA ClusterIssuer created successfully"
        
        # Wait for CA certificate to be ready
        print_status "Waiting for CA certificate to be ready..."
        local max_wait=30
        local wait_count=0
        while [ $wait_count -lt $max_wait ]; do
            if kubectl_exec get certificate nano-local-ca -n cert-manager -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null | grep -q "True"; then
                print_success "CA certificate is ready!"
                break
            fi
            sleep 2
            ((wait_count++))
        done
        
        if [ $wait_count -eq $max_wait ]; then
            print_warning "CA certificate is still not ready after ${max_wait} attempts"
            return 1
        fi
        
        return 0
    else
        print_error "Failed to create self-signed CA ClusterIssuer"
        return 1
    fi
}

# Function to check if certificate is ready
check_certificate_ready() {
    local cert_name="$1"
    kubectl_exec get certificate "$cert_name" -n nano -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null | grep -q "True"
}

# Function to get TLS secret name
get_tls_secret_name() {
    # First try to get the main secret name
    if kubectl_exec get secret nano-local-tls -n nano &>/dev/null; then
        echo "nano-local-tls"
        return 0
    fi
    
    # If not found, look for secrets with the prefix (temporary cert-manager secrets)
    local secret_name
    secret_name=$(kubectl_exec get secret -n nano -o name | grep "secret/nano-local-tls" | head -n 1 | cut -d'/' -f2)
    if [ -n "$secret_name" ]; then
        echo "$secret_name"
        return 0
    fi
    
    return 1
}

# Function to export certificates generated by cert-manager/Traefik
export_traefik_certificates() {
    print_status "Exporting certificates from Kubernetes secrets..."
    
    # Create certificate directory
    mkdir -p "$CERTS_DIR"
    
    # Check if cert-manager is available
    if kubectl_exec get crd certificates.cert-manager.io &>/dev/null; then
        print_status "cert-manager detected, checking certificate status..."
        
        # Check if certificate exists and is ready
        if kubectl_exec get certificate nano-local-tls -n nano &>/dev/null; then
            if check_certificate_ready nano-local-tls; then
                print_success "Certificate is ready!"
            else
                print_warning "Certificate exists but is not ready. Checking if we need to create a self-signed issuer..."
                
                # Check if the issue is a missing ClusterIssuer
                if kubectl_exec describe certificaterequest -n nano | grep -q "ClusterIssuer.*not found"; then
                    print_status "Creating self-signed issuer for local development..."
                    if create_self_signed_issuer; then
                        # Update the certificate to use the CA issuer
                        print_status "Updating certificate to use CA issuer..."
                        kubectl_exec patch certificate nano-local-tls -n nano --type='merge' -p='{"spec":{"issuerRef":{"name":"nano-local-ca-issuer","kind":"ClusterIssuer"}}}'
                        
                        # Wait for certificate to become ready
                        print_status "Waiting for certificate to become ready..."
                        local max_wait=30
                        local wait_count=0
                        while [ $wait_count -lt $max_wait ]; do
                            if check_certificate_ready nano-local-tls; then
                                print_success "Certificate is now ready!"
                                break
                            fi
                            sleep 2
                            ((wait_count++))
                        done
                        
                        if [ $wait_count -eq $max_wait ]; then
                            print_warning "Certificate is still not ready after ${max_wait} attempts"
                        fi
                    fi
                fi
            fi
        fi
    fi
    
    # Get the TLS secret name
    local secret_name
    if ! secret_name=$(get_tls_secret_name); then
        print_error "No TLS secret found for nano-local-tls"
        return 1
    fi
    
    print_status "Found TLS secret: $secret_name"
    
    # Check if secret has both cert and key
    local has_cert has_key
    has_cert=$(kubectl_exec get secret "$secret_name" -n nano -o jsonpath='{.data.tls\.crt}' 2>/dev/null)
    has_key=$(kubectl_exec get secret "$secret_name" -n nano -o jsonpath='{.data.tls\.key}' 2>/dev/null)
    
    if [ -z "$has_cert" ]; then
        print_error "Secret $secret_name does not contain tls.crt"
        return 1
    fi
    
    if [ -z "$has_key" ]; then
        print_error "Secret $secret_name does not contain tls.key"
        return 1
    fi
    
    # Export the certificate from the Kubernetes secret
    print_status "Extracting certificate from Kubernetes secret..."
    kubectl_exec get secret "$secret_name" -n nano -o jsonpath='{.data.tls\.crt}' | base64 -d > "$SERVER_CERT"
    kubectl_exec get secret "$secret_name" -n nano -o jsonpath='{.data.tls\.key}' | base64 -d > "$SERVER_KEY"
    
    # Export the CA certificate from cert-manager
    print_status "Extracting CA certificate..."
    if kubectl_exec get secret nano-local-ca-secret -n cert-manager &>/dev/null; then
        kubectl_exec get secret nano-local-ca-secret -n cert-manager -o jsonpath='{.data.tls\.crt}' | base64 -d > "$CA_CERT"
    else
        print_warning "CA certificate not found, using server certificate as CA"
        cp "$SERVER_CERT" "$CA_CERT"
    fi
    # Verify the exported certificates
    if [ -f "$SERVER_CERT" ] && [ -f "$SERVER_KEY" ] && [ -f "$CA_CERT" ] && \
       openssl x509 -in "$SERVER_CERT" -noout &>/dev/null && \
       openssl rsa -in "$SERVER_KEY" -check -noout &>/dev/null && \
       openssl x509 -in "$CA_CERT" -noout &>/dev/null; then
        print_success "Certificates exported successfully!"
        print_status "Certificate files saved to:"
        echo "  CA Certificate: $CA_CERT"
        echo "  Server Certificate: $SERVER_CERT"
        echo "  Server Private Key: $SERVER_KEY"
        return 0
    else
        print_error "Failed to export valid certificates"
        print_warning "Certificate files may be missing or invalid"
        return 1
    fi
}

# Function to wait for Traefik to be ready and certificates to be generated
wait_for_traefik_certificates() {
    print_status "Waiting for Traefik to generate certificates for the ingress..."
    
    # Check if ingress exists first
    local max_attempts=30  # 2.5 minutes
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if kubectl_exec get ingress nano -n nano &>/dev/null; then
            print_success "Ingress found!"
            break
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            print_error "Timeout waiting for ingress to be created"
            return 1
        fi
        
        sleep 5
        ((attempt++))
    done
    
    # Now wait for TLS secret to be created by Traefik
    export_traefik_certificates
}

# Function to display certificate trust instructions
show_certificate_instructions() {
    print_status "Certificate details (exported from Traefik):"
    if [[ -f "$SERVER_CERT" ]]; then
        openssl x509 -in "$SERVER_CERT" -text -noout | grep -A 10 "Subject Alternative Name" 2>/dev/null || echo "Certificate exported successfully"
    else
        echo "Certificates will be exported after successful deployment"
    fi
    
    echo ""
    print_warning "To trust the certificates in your browser:"
    echo ""
    
    # Detect OS and provide appropriate instructions
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo -e "${BLUE}For Linux (Chrome/Firefox):${RESET}"
        echo "1. Copy the CA certificate to your local certificate store:"
        echo "   sudo cp $CA_CERT /usr/local/share/ca-certificates/nano-local-ca.crt"
        echo "   sudo update-ca-certificates"
        echo ""
        echo -e "${BLUE}Alternative for Firefox:${RESET}"
        echo "1. Open Firefox -> Settings -> Privacy & Security"
        echo "2. Scroll to 'Certificates' -> View Certificates"
        echo "3. Go to 'Authorities' tab -> Import"
        echo "4. Select: $(pwd)/$CA_CERT"
        echo "5. Check 'Trust this CA to identify websites'"
        
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo -e "${BLUE}For macOS:${RESET}"
        echo "1. Open Keychain Access"
        echo "2. File -> Import Items"
        echo "3. Select: $(pwd)/$CA_CERT"
        echo "4. Double-click the imported certificate"
        echo "5. Expand 'Trust' section"
        echo "6. Set 'When using this certificate' to 'Always Trust'"
        
    elif [[ "$OSTYPE" == "msys" ]]; then
        echo -e "${BLUE}For Windows:${RESET}"
        echo "1. Double-click: $(pwd)/$CA_CERT"
        echo "2. Click 'Install Certificate'"
        echo "3. Select 'Local Machine' -> Next"
        echo "4. Select 'Place all certificates in the following store'"
        echo "5. Browse -> Select 'Trusted Root Certification Authorities'"
        echo "6. Click Next -> Finish"
    fi
    
    echo ""
    print_status "Add these entries to your /etc/hosts file:"
    echo "127.0.0.1    nano.local"
    echo "127.0.0.1    app.nano.local"
    echo "127.0.0.1    api.nano.local"
    echo ""
    print_status "Note: These certificates are generated automatically by Traefik"
    echo "and exported for local development trust purposes."
}

# Command: certs
cmd_certs() {
    print_header "Certificate Export from Traefik"
    
    # Check if cluster is running
    if ! kubectl_exec get nodes >/dev/null 2>&1; then
        print_error "Cluster not running - start the cluster first with 'start' command"
        exit 1
    fi
    
    # Check if the application is deployed
    if ! kubectl_exec get namespace nano >/dev/null 2>&1; then
        print_error "Application not deployed - deploy first with 'deploy' command"
        exit 1
    fi
    
    # Export certificates from Traefik
    if export_traefik_certificates; then
        print_success "Certificates exported from Traefik successfully!"
    else
        print_error "Failed to export certificates from Traefik"
        print_warning "Make sure the application is fully deployed and Traefik is generating certificates"
        exit 1
    fi
    
    echo ""
    show_certificate_instructions
}
