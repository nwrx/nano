config:
  apiUrl: 'https://api.nwrx.local'
  appUrl: 'https://nwrx.local'
  api:
    secretRef: ''  # Use external secret instead of creating one
    trustProxy: true
    sessionDuration: '86400000'  # 24 hours in milliseconds
    sessionIdCookieName: __Host-Session-Id
    sessionTokenCookieName: __Host-Session-Token
    sessionEncryptionSecret: your_session_encryption_secret_here_change_in_production
    sessionEncryptionAlgorithm: aes-256-gcm
    userRecoveryTokenDuration: '3600000' # 1 hour in milliseconds
    vaultEncryptionSecret: your_vault_encryption_secret_here_change_in_production
    vaultEncryptionAlgorithm: aes-256-gcm
    iconCdnUrl: 'https://esm.sh/'
    iconifyUrl: 'https://api.iconify.design/'
  runners:
    token: your_runner_token_secret_here_change_in_production  # Secret used to generate unique tokens for each runner
    autoRegister: true  # When true, runners will be auto-registered in the API via NANO_RUNNER_INITIAL_SERVERS
  database:
    secretRef: ''  # Use external secret instead of creating one
    username: postgres
    password: postgres-password-change-me
    database: postgres
    synchronize: true  # Set to true for development, false for production
  storage:
    secretRef: ''  # Use external secret instead of creating one
    encryptionSecret: your_storage_encryption_secret_here_change_in_production
    encryptionAlgorithm: aes-256-gcm
    # Optional: Custom download URL for external access to files
    # When set, file downloads will redirect to this URL instead of the internal storage URLs
    # This is useful when using MinIO in Kubernetes where internal URLs are not accessible externally
    #
    # Options:
    # 1. 'https://api.nwrx.local' - Redirect to API endpoint (preserves authentication/authorization)
    # 2. 'https://cdn.nwrx.local' - Redirect directly to storage service (faster, requires storage ingress)
    # 3. Leave empty ('') - Proxy data through API (slowest but always works)
    # NOTE: Set to CDN URL so MinIO generates correct external URLs
    publicDownloadUrl: ''
    publicPoolType: s3
    publicPoolConfiguration: 
      region: eu-west-1
      bucket: default
      accessKeyId: minio-admin
      secretAccessKey: minio-admin-password-change-me

      # For production with external S3, uncomment and configure the following
      # region: eu-west-1
      # bucket: nano-production
      # endpoint: https://s3.amazonaws.com
      # accessKeyId: your-external-access-key-id
      # secretAccessKey: your-external-secret-access-key

# Configure the Nano application service (frontend)
app:
  enabled: true
  replicas: 3
  image:
    repository: ghcr.io/nwrx/nano
    tag: main
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  environment: []
  service:
    type: ClusterIP
    port: 80
    annotations: {}
    labels: {}
  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 80
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 250m
      memory: 256Mi
  serviceAccount:
    create: true
    annotations: {}
    name: ''
    automountServiceAccountToken: false
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  securityContext:
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}

# Configure the Nano API service (backend)
api:
  enabled: true
  replicas: 1
  image:
    repository: ghcr.io/nwrx/nano
    tag: main
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  environment: []
  persistence:
    enabled: true
    size: 20Gi
    storageClass: ''
    accessModes:
      - ReadWriteOnce
  # Deployment strategy
  strategy:
    type: Recreate  # Use Recreate for ReadWriteOnce volumes
  service:
    type: ClusterIP
    port: 80
    annotations: {}
    labels: {}
  # Health check probes
  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 45
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  startupProbe:
    httpGet:
      path: /ready
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  serviceAccount:
    create: true
    annotations: {}
    name: ''
    automountServiceAccountToken: false
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  securityContext:
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}

# Configure the runners for Nano (workers)
runners:
  enabled: true
  replicas: 3
  image:
    repository: ghcr.io/nwrx/nano
    tag: main
    pullPolicy: IfNotPresent
  imagePullSecrets:
    - name: ghcr-secret
  environment: {}
  service:
    type: ClusterIP
    port: 80
    annotations: {}
    labels: {}
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  networkPolicy:
    enabled: true
  serviceAccount:
    create: true
    annotations: {}
    name: ''
    automountServiceAccountToken: false
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  securityContext:
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}

# Configure the Nano database service (PostgreSQL)
database:
  enabled: true
  image:
    repository: postgres
    tag: 15-alpine
    pullPolicy: IfNotPresent
  persistence:
    enabled: true
    size: 10Gi
    storageClass: ''
    accessModes:
      - ReadWriteOnce
  service:
    type: ClusterIP
    port: 5432
    annotations: {}
    labels: {}
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  serviceAccount:
    create: true
    annotations: {}
    name: ''
    automountServiceAccountToken: false
  podSecurityContext:
    runAsNonRoot: false  # PostgreSQL needs to run as root initially
    fsGroup: 999
    seccompProfile:
      type: RuntimeDefault
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
      add:
        - CHOWN
        - DAC_OVERRIDE
        - FOWNER
        - SETGID
        - SETUID
  # Health check probes
  livenessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  startupProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}

# Configure the MinIO storage service (S3-compatible object storage)
# NOTE: Enabled by default for development/testing convenience
# For production, consider disabling this and using external S3-compatible storage
# Set storage.enabled: false and configure external S3 in config.storage.publicPoolConfiguration
storage:
  enabled: true  # Enabled by default for development - disable for production and use external S3
  image:
    repository: quay.io/minio/minio
    tag: latest
    pullPolicy: IfNotPresent
  imagePullSecrets: []
  environment: []
  persistence:
    enabled: true
    size: 50Gi
    storageClass: ''
    accessModes:
      - ReadWriteOnce
  # Deployment strategy
  strategy:
    type: Recreate  # Use Recreate for ReadWriteOnce volumes
  service:
    type: ClusterIP
    port: 9000
    consolePort: 9001
    annotations: {}
    labels: {}
  # Health check probes
  livenessProbe:
    httpGet:
      path: /minio/health/live
      port: api
    initialDelaySeconds: 45
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
  readinessProbe:
    httpGet:
      path: /minio/health/ready
      port: api
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
  startupProbe:
    httpGet:
      path: /minio/health/live
      port: api
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 500m
      memory: 512Mi
  serviceAccount:
    create: true
    annotations: {}
    name: ''
    automountServiceAccountToken: false
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    fsGroup: 1001
    seccompProfile:
      type: RuntimeDefault
  securityContext:
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}

# Ingress configuration for Nano services
ingress:
  enabled: true
  className: traefik
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-staging
    traefik.ingress.kubernetes.io/websocket: 'true'
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
  tls:
    - secretName: nano-tls
      hosts:
        - nwrx.local
        - api.nwrx.local
        - cdn.nwrx.local
  hosts:
    - host: nwrx.local
      paths:
        - path: /
          pathType: Prefix
          service: app
    - host: api.nwrx.local
      paths:
        - path: /
          pathType: Prefix
          service: api

    # If using internal MinIO service for storage, you can expose it via this host.
    # Note: Only include this host if storage.enabled is true
    # Also configure config.storage.publicDownloadUrl to 'https://cdn.nwrx.local'
    # so that file downloads are redirected to this external URL instead of internal cluster URLs
    - host: cdn.nwrx.local
      paths:
        - path: /
          pathType: Prefix
          service: storage

# Extra Kubernetes objects to create
# This allows you to deploy additional resources alongside the main application
extraObjects: []
# Example usage:
# - apiVersion: v1
#   kind: ConfigMap
#   metadata:
#     name: my-configmap
#     namespace: "{{ .Release.Namespace }}"
#   data:
#     key: value
# - apiVersion: v1
#   kind: Secret
#   metadata:
#     name: my-secret
#     namespace: "{{ .Release.Namespace }}"
#   type: Opaque
#   data:
#     password: "{{ "mypassword" | b64enc }}"
