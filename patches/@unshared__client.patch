diff --git a/dist/chunks/Cyb3f4h0.js b/dist/chunks/Cyb3f4h0.js
new file mode 100644
index 0000000000000000000000000000000000000000..b72dfb3268d7244fe202b5b1c61ea23f31ab4785
--- /dev/null
+++ b/dist/chunks/Cyb3f4h0.js
@@ -0,0 +1,86 @@
+import { awaitable } from "@unshared/functions/awaitable";
+import { p as parseRequestParameters, a as parseRequestQuery } from "./B6pUErTM.js";
+const EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, PROTOCOLS = /* @__PURE__ */ new Set(["ws", "wss"]);
+function parseConnectUrl(parameters, channel, options) {
+  const { baseUrl, protocol } = options, match = EXP_CONNECTION_CHANNEL.exec(channel);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeProtocol = protocol ?? match.groups.protocol ?? "ws", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const protocolLower = routeProtocol.toLowerCase();
+  if (!PROTOCOLS.has(protocolLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeProtocol}\` is invalid.`);
+  parameters.url = new URL(routeBaseUrl), parameters.url.pathname += parameters.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path, parameters.protocol = protocolLower;
+}
+function parseConnectOptions(channel, options) {
+  const { baseUrl, protocol, data, parameters = data, query = data } = options, wsParameters = { url: new URL("about:blank") };
+  return parseConnectUrl(wsParameters, channel, { baseUrl, protocol }), parseRequestParameters(wsParameters, { parameters }), parseRequestQuery(wsParameters, { query }), wsParameters;
+}
+class WebSocketChannel {
+  constructor(channel, options) {
+    this.channel = channel, this.options = options;
+  }
+  /** The WebSocket connection to the server. */
+  webSocket;
+  /**
+   * Open a new WebSocket connection to the server. The connection will be opened with the given
+   * URL and protocols. If the connection is already open, the connection will be closed before
+   * opening a new connection. Also add the event listeners that were passed in the options.
+   *
+   * @returns The WebSocket connection.
+   */
+  async open() {
+    this.webSocket && await this.close();
+    const { url, protocol } = parseConnectOptions(this.channel, this.options);
+    this.webSocket = new WebSocket(url, protocol);
+    const promise = new Promise((resolve, rejects) => {
+      this.webSocket.addEventListener("error", () => rejects(new Error("Failed to open the WebSocket connection")), { once: !0 }), this.webSocket.addEventListener("open", () => {
+        this.options.initialPayload && this.send(this.options.initialPayload), resolve();
+      }, { once: !0 });
+    });
+    return this.options.onOpen && this.on("open", this.options.onOpen, { once: !0 }), this.options.onClose && this.on("close", this.options.onClose, { once: !0 }), this.options.onError && this.on("error", this.options.onError), this.options.onMessage && this.on("message", (message) => this.options.onMessage(message)), this.webSocket.addEventListener("close", (event) => {
+      event.code !== 1e3 && this.options.autoReconnect && (this.options.reconnectLimit && event.wasClean || setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0));
+    }, { once: !0 }), promise.then(() => this);
+  }
+  /**
+   * Send a payload to the server. The payload will be serialized to JSON before sending.
+   *
+   * @param payload The data to send to the server.
+   */
+  send(payload) {
+    if (!this.webSocket) throw new Error("WebSocket connection is not open");
+    const json = JSON.stringify(payload);
+    this.webSocket.send(json);
+  }
+  on(event, callback, options) {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    const listener = async (event2) => {
+      event2.type !== "message" && callback(event2);
+      let data = event2.data;
+      data instanceof Blob && (data = await data.text());
+      try {
+        data = JSON.parse(data);
+      } catch {
+        console.error("Failed to parse the message:", data);
+      }
+      callback(data);
+    };
+    return this.webSocket.addEventListener(event, listener, options), () => this.webSocket.removeEventListener(event, listener);
+  }
+  /**
+   * Close the WebSocket connection to the server. The connection will not be able to send or receive
+   * messages after it is closed.
+   */
+  async close() {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    this.webSocket.readyState !== WebSocket.CLOSED && this.webSocket.readyState !== WebSocket.CLOSING && (this.webSocket.close(1e3, "Client closed the connection"), await new Promise((resolve) => this.webSocket.addEventListener("close", () => resolve())));
+  }
+}
+function connect(route, options) {
+  const channel = new WebSocketChannel(route, options);
+  return awaitable(channel, () => channel.open());
+}
+export {
+  WebSocketChannel as W,
+  connect as c,
+  parseConnectOptions as p
+};
+//# sourceMappingURL=Cyb3f4h0.js.map
diff --git a/dist/chunks/Cyb3f4h0.js.map b/dist/chunks/Cyb3f4h0.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..3b2d14c4026d4a18f2afdeebbf9c8c083179a947
--- /dev/null
+++ b/dist/chunks/Cyb3f4h0.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Cyb3f4h0.js","sources":["../../websocket/parseConnectOptions.ts","../../websocket/connect.ts"],"sourcesContent":["import type { Loose, ObjectLike, UnionMerge } from '@unshared/types'\nimport { parseRequestParameters } from '../utils/parseRequestParameters'\nimport { parseRequestQuery } from '../utils/parseRequestQuery'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid WebSocket protocols. */\nconst PROTOCOLS = new Set(['ws', 'wss'])\n\n/** The protocols to use for the connection. */\nexport type ConnectProtocol = 'WS' | 'WSS'\n\n/** Options to pass to the `createChannel` function. */\nexport interface ConnectOptions<\n  BaseUrl extends string = string,\n  Query extends ObjectLike = ObjectLike,\n  Parameters extends ObjectLike = ObjectLike,\n  ClientData extends ObjectLike = any,\n  ServerData extends ObjectLike = any,\n> {\n\n  /** The protocol to use when connecting to the server. */\n  protocol?: Lowercase<ConnectProtocol> | Uppercase<ConnectProtocol>\n\n  /** The base URL to connect to. */\n  baseUrl?: BaseUrl\n\n  /**\n   * The path parameters to use when connecting to the server. These parameters will be used to\n   * fill in the path parameters of the connection URL.\n   *\n   * @example { id: 1 }\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to use when connecting to the server. These parameters will be used to\n   * fill in the query parameters of the connection URL.\n   *\n   * @example { limit: 10, offset: 0 }\n   */\n  query?: Loose<Query>\n\n  /**\n   * The data to send when creating the connection. Namely, the path parameters\n   * to use when connecting to the server.\n   *\n   * @example\n   *\n   * // Create a new connection to `http://localhost:8080/users/1`.\n   * connect('GET /users/:id', {\n   *   data: { id: 1 },\n   *   baseUrl: 'http://localhost:8080'\n   * })\n   */\n  data?: UnionMerge<Loose<Query> | Parameters>\n\n  /**\n   * The payload to send when creating the connection. Namely, the initial message\n   * to send to the server when the connection is established.\n   */\n  initialPayload?: Loose<ClientData>\n\n  /**\n   * Weather to reconnect the connection when it is closed unexpectedly. If `true`,\n   * the connection will automatically reconnect when it is closed. If `false`, the\n   * connection will not reconnect when it is closed.\n   *\n   * @default false\n   */\n  autoReconnect?: boolean\n\n  /**\n   * The delay in milliseconds to wait before reconnecting the connection. This delay\n   * will be used to wait before reconnecting the connection after it is closed.\n   *\n   * @default 0\n   */\n  reconnectDelay?: number\n\n  /**\n   * The maximum number of times to reconnect the connection before giving up. This\n   * number will be used to determine when to stop trying to reconnect the connection.\n   *\n   * @default 3\n   */\n  reconnectLimit?: number\n\n  /**\n   * The function to call when the connection is opened. This function will be called\n   * when the connection is successfully opened or reconnected.\n   */\n  onOpen?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed with an error. This function will\n   * be called when the connection is closed unexpectedly with an error.\n   */\n  onError?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed. This function will be called\n   * when the connection is closed unexpectedly or when the connection is closed manually.\n   */\n  onClose?: (event: CloseEvent) => void\n\n  /**\n   * The function to call when a message is received from the server. This function will\n   * be called when a message is received from the server.\n   */\n  onMessage?: (data: ServerData) => void\n}\n\nexport interface WebSocketParameters {\n  url: URL\n  protocol?: 'ws' | 'wss'\n}\n\nfunction parseConnectUrl(parameters: WebSocketParameters, channel: string, options: ConnectOptions): void {\n  const { baseUrl, protocol } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_CONNECTION_CHANNEL.exec(channel)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeProtocol = protocol ?? match.groups.protocol ?? 'ws'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const protocolLower = routeProtocol.toLowerCase()\n  const protocolIsValid = PROTOCOLS.has(protocolLower)\n  if (!protocolIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeProtocol}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  parameters.url = new URL(routeBaseUrl)\n  parameters.url.pathname += parameters.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n  parameters.protocol = protocolLower as 'ws' | 'wss'\n}\n\nexport function parseConnectOptions(channel: string, options: ConnectOptions): WebSocketParameters {\n  const { baseUrl, protocol, data, parameters = data, query = data } = options\n  const wsParameters: WebSocketParameters = { url: new URL('about:blank') }\n  parseConnectUrl(wsParameters, channel, { baseUrl, protocol })\n  parseRequestParameters(wsParameters, { parameters })\n  parseRequestQuery(wsParameters, { query })\n  return wsParameters\n}\n","import type { Awaitable } from '@unshared/functions/awaitable'\nimport type { ConnectOptions } from './parseConnectOptions'\nimport { awaitable } from '@unshared/functions/awaitable'\nimport { parseConnectOptions } from './parseConnectOptions'\n\ntype RemoveListener = () => void\n\ntype ClientData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, infer R, any> ? R : any\n\ntype ServerData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, any, infer R> ? R : any\n\nexport class WebSocketChannel<T extends ConnectOptions = ConnectOptions> {\n  constructor(public channel: string, public options: T) {}\n\n  /** The WebSocket connection to the server. */\n  public webSocket: undefined | WebSocket\n\n  /**\n   * Open a new WebSocket connection to the server. The connection will be opened with the given\n   * URL and protocols. If the connection is already open, the connection will be closed before\n   * opening a new connection. Also add the event listeners that were passed in the options.\n   *\n   * @returns The WebSocket connection.\n   */\n  async open(): Promise<this> {\n    if (this.webSocket) await this.close()\n    const { url, protocol } = parseConnectOptions(this.channel, this.options)\n    this.webSocket = new WebSocket(url, protocol)\n\n    // --- Return a promise that resolves when the connection is opened.\n    const promise = new Promise<void>((resolve, rejects) => {\n      this.webSocket!.addEventListener('error', () => rejects(new Error('Failed to open the WebSocket connection')), { once: true })\n      this.webSocket!.addEventListener('open', () => {\n        if (this.options.initialPayload) this.send(this.options.initialPayload as ClientData<T>)\n        resolve()\n      }, { once: true })\n    })\n\n    // --- Add the options' hooks to the WebSocket connection.\n    if (this.options.onOpen) this.on('open', this.options.onOpen, { once: true })\n    if (this.options.onClose) this.on('close', this.options.onClose, { once: true })\n    if (this.options.onError) this.on('error', this.options.onError)\n    if (this.options.onMessage) this.on('message', message => this.options.onMessage!(message))\n\n    // --- Handle reconnection when the connection is closed unexpectedly.\n    this.webSocket.addEventListener('close', (event) => {\n      if (event.code === 1000) return\n      if (!this.options.autoReconnect) return\n      if (this.options.reconnectLimit && event.wasClean) return\n      setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0)\n    }, { once: true })\n\n    return promise.then(() => this)\n  }\n\n  /**\n   * Send a payload to the server. The payload will be serialized to JSON before sending.\n   *\n   * @param payload The data to send to the server.\n   */\n  send(payload: ClientData<T>) {\n    if (!this.webSocket) throw new Error('WebSocket connection is not open')\n    const json = JSON.stringify(payload)\n    this.webSocket.send(json)\n  }\n\n  /**\n   * Listen for events from the server. The event will be deserialized from JSON before calling the callback.\n   *\n   * @param event The event to listen for.\n   * @param callback The callback to call when the event is received.\n   * @returns A function to remove the event listener.\n   */\n  on(event: 'message', callback: (data: ServerData<T>) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'close', callback: (event: CloseEvent) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'error', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'open', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: string, callback: (data: any) => any, options?: AddEventListenerOptions) {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n\n    const listener = async(event: CloseEvent | Event | MessageEvent<Blob>): Promise<void> => {\n      if (event.type !== 'message') callback(event)\n      // @ts-expect-error: `data` exists on the event.\n      let data = event.data as unknown\n      if (data instanceof Blob) data = await data.text()\n      try { data = JSON.parse(data as string) }\n      catch { console.error('Failed to parse the message:', data) }\n      callback(data)\n    }\n\n    /* eslint-disable @typescript-eslint/no-misused-promises */\n    this.webSocket.addEventListener(event, listener, options)\n    return () => this.webSocket!.removeEventListener(event, listener)\n    /* eslint-enable @typescript-eslint/no-misused-promises */\n  }\n\n  /**\n   * Close the WebSocket connection to the server. The connection will not be able to send or receive\n   * messages after it is closed.\n   */\n  async close() {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n    if (this.webSocket.readyState === WebSocket.CLOSED) return\n    if (this.webSocket.readyState === WebSocket.CLOSING) return\n    this.webSocket.close(1000, 'Client closed the connection')\n    await new Promise<void>(resolve => this.webSocket!.addEventListener('close', () => resolve()))\n  }\n}\n\n/**\n * Create a new WebSocket connection to the server with the given path. The connection will\n * automatically reconnect if the connection is closed unexpectedly.\n *\n * @param route The name of the route to connect to.\n * @param options The options to pass to the connection.\n * @returns The WebSocket connection.\n */\nexport function connect(route: string, options: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n  const channel = new WebSocketChannel(route, options)\n  return awaitable(channel, () => channel.open())\n}\n"],"names":["event"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/chunks/SZf7rksc.cjs b/dist/chunks/SZf7rksc.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..8659a3fb0efd47eada29b78008fa7b0f756585ab
--- /dev/null
+++ b/dist/chunks/SZf7rksc.cjs
@@ -0,0 +1,84 @@
+"use strict";
+var awaitable = require("@unshared/functions/awaitable"), parseRequestQuery = require("./BDxlAULu.cjs");
+const EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, PROTOCOLS = /* @__PURE__ */ new Set(["ws", "wss"]);
+function parseConnectUrl(parameters, channel, options) {
+  const { baseUrl, protocol } = options, match = EXP_CONNECTION_CHANNEL.exec(channel);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeProtocol = protocol ?? match.groups.protocol ?? "ws", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const protocolLower = routeProtocol.toLowerCase();
+  if (!PROTOCOLS.has(protocolLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeProtocol}\` is invalid.`);
+  parameters.url = new URL(routeBaseUrl), parameters.url.pathname += parameters.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path, parameters.protocol = protocolLower;
+}
+function parseConnectOptions(channel, options) {
+  const { baseUrl, protocol, data, parameters = data, query = data } = options, wsParameters = { url: new URL("about:blank") };
+  return parseConnectUrl(wsParameters, channel, { baseUrl, protocol }), parseRequestQuery.parseRequestParameters(wsParameters, { parameters }), parseRequestQuery.parseRequestQuery(wsParameters, { query }), wsParameters;
+}
+class WebSocketChannel {
+  constructor(channel, options) {
+    this.channel = channel, this.options = options;
+  }
+  /** The WebSocket connection to the server. */
+  webSocket;
+  /**
+   * Open a new WebSocket connection to the server. The connection will be opened with the given
+   * URL and protocols. If the connection is already open, the connection will be closed before
+   * opening a new connection. Also add the event listeners that were passed in the options.
+   *
+   * @returns The WebSocket connection.
+   */
+  async open() {
+    this.webSocket && await this.close();
+    const { url, protocol } = parseConnectOptions(this.channel, this.options);
+    this.webSocket = new WebSocket(url, protocol);
+    const promise = new Promise((resolve, rejects) => {
+      this.webSocket.addEventListener("error", () => rejects(new Error("Failed to open the WebSocket connection")), { once: !0 }), this.webSocket.addEventListener("open", () => {
+        this.options.initialPayload && this.send(this.options.initialPayload), resolve();
+      }, { once: !0 });
+    });
+    return this.options.onOpen && this.on("open", this.options.onOpen, { once: !0 }), this.options.onClose && this.on("close", this.options.onClose, { once: !0 }), this.options.onError && this.on("error", this.options.onError), this.options.onMessage && this.on("message", (message) => this.options.onMessage(message)), this.webSocket.addEventListener("close", (event) => {
+      event.code !== 1e3 && this.options.autoReconnect && (this.options.reconnectLimit && event.wasClean || setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0));
+    }, { once: !0 }), promise.then(() => this);
+  }
+  /**
+   * Send a payload to the server. The payload will be serialized to JSON before sending.
+   *
+   * @param payload The data to send to the server.
+   */
+  send(payload) {
+    if (!this.webSocket) throw new Error("WebSocket connection is not open");
+    const json = JSON.stringify(payload);
+    this.webSocket.send(json);
+  }
+  on(event, callback, options) {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    const listener = async (event2) => {
+      event2.type !== "message" && callback(event2);
+      let data = event2.data;
+      data instanceof Blob && (data = await data.text());
+      try {
+        data = JSON.parse(data);
+      } catch {
+        console.error("Failed to parse the message:", data);
+      }
+      callback(data);
+    };
+    return this.webSocket.addEventListener(event, listener, options), () => this.webSocket.removeEventListener(event, listener);
+  }
+  /**
+   * Close the WebSocket connection to the server. The connection will not be able to send or receive
+   * messages after it is closed.
+   */
+  async close() {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    this.webSocket.readyState !== WebSocket.CLOSED && this.webSocket.readyState !== WebSocket.CLOSING && (this.webSocket.close(1e3, "Client closed the connection"), await new Promise((resolve) => this.webSocket.addEventListener("close", () => resolve())));
+  }
+}
+function connect(route, options) {
+  const channel = new WebSocketChannel(route, options);
+  return awaitable.awaitable(channel, () => channel.open());
+}
+exports.WebSocketChannel = WebSocketChannel;
+exports.connect = connect;
+exports.parseConnectOptions = parseConnectOptions;
+//# sourceMappingURL=SZf7rksc.cjs.map
diff --git a/dist/chunks/SZf7rksc.cjs.map b/dist/chunks/SZf7rksc.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..47fb69889ddfbb8a5469f9bcda8ae1476485192a
--- /dev/null
+++ b/dist/chunks/SZf7rksc.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"SZf7rksc.cjs","sources":["../../websocket/parseConnectOptions.ts","../../websocket/connect.ts"],"sourcesContent":["import type { Loose, ObjectLike, UnionMerge } from '@unshared/types'\nimport { parseRequestParameters } from '../utils/parseRequestParameters'\nimport { parseRequestQuery } from '../utils/parseRequestQuery'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid WebSocket protocols. */\nconst PROTOCOLS = new Set(['ws', 'wss'])\n\n/** The protocols to use for the connection. */\nexport type ConnectProtocol = 'WS' | 'WSS'\n\n/** Options to pass to the `createChannel` function. */\nexport interface ConnectOptions<\n  BaseUrl extends string = string,\n  Query extends ObjectLike = ObjectLike,\n  Parameters extends ObjectLike = ObjectLike,\n  ClientData extends ObjectLike = any,\n  ServerData extends ObjectLike = any,\n> {\n\n  /** The protocol to use when connecting to the server. */\n  protocol?: Lowercase<ConnectProtocol> | Uppercase<ConnectProtocol>\n\n  /** The base URL to connect to. */\n  baseUrl?: BaseUrl\n\n  /**\n   * The path parameters to use when connecting to the server. These parameters will be used to\n   * fill in the path parameters of the connection URL.\n   *\n   * @example { id: 1 }\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to use when connecting to the server. These parameters will be used to\n   * fill in the query parameters of the connection URL.\n   *\n   * @example { limit: 10, offset: 0 }\n   */\n  query?: Loose<Query>\n\n  /**\n   * The data to send when creating the connection. Namely, the path parameters\n   * to use when connecting to the server.\n   *\n   * @example\n   *\n   * // Create a new connection to `http://localhost:8080/users/1`.\n   * connect('GET /users/:id', {\n   *   data: { id: 1 },\n   *   baseUrl: 'http://localhost:8080'\n   * })\n   */\n  data?: UnionMerge<Loose<Query> | Parameters>\n\n  /**\n   * The payload to send when creating the connection. Namely, the initial message\n   * to send to the server when the connection is established.\n   */\n  initialPayload?: Loose<ClientData>\n\n  /**\n   * Weather to reconnect the connection when it is closed unexpectedly. If `true`,\n   * the connection will automatically reconnect when it is closed. If `false`, the\n   * connection will not reconnect when it is closed.\n   *\n   * @default false\n   */\n  autoReconnect?: boolean\n\n  /**\n   * The delay in milliseconds to wait before reconnecting the connection. This delay\n   * will be used to wait before reconnecting the connection after it is closed.\n   *\n   * @default 0\n   */\n  reconnectDelay?: number\n\n  /**\n   * The maximum number of times to reconnect the connection before giving up. This\n   * number will be used to determine when to stop trying to reconnect the connection.\n   *\n   * @default 3\n   */\n  reconnectLimit?: number\n\n  /**\n   * The function to call when the connection is opened. This function will be called\n   * when the connection is successfully opened or reconnected.\n   */\n  onOpen?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed with an error. This function will\n   * be called when the connection is closed unexpectedly with an error.\n   */\n  onError?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed. This function will be called\n   * when the connection is closed unexpectedly or when the connection is closed manually.\n   */\n  onClose?: (event: CloseEvent) => void\n\n  /**\n   * The function to call when a message is received from the server. This function will\n   * be called when a message is received from the server.\n   */\n  onMessage?: (data: ServerData) => void\n}\n\nexport interface WebSocketParameters {\n  url: URL\n  protocol?: 'ws' | 'wss'\n}\n\nfunction parseConnectUrl(parameters: WebSocketParameters, channel: string, options: ConnectOptions): void {\n  const { baseUrl, protocol } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_CONNECTION_CHANNEL.exec(channel)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeProtocol = protocol ?? match.groups.protocol ?? 'ws'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const protocolLower = routeProtocol.toLowerCase()\n  const protocolIsValid = PROTOCOLS.has(protocolLower)\n  if (!protocolIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeProtocol}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  parameters.url = new URL(routeBaseUrl)\n  parameters.url.pathname += parameters.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n  parameters.protocol = protocolLower as 'ws' | 'wss'\n}\n\nexport function parseConnectOptions(channel: string, options: ConnectOptions): WebSocketParameters {\n  const { baseUrl, protocol, data, parameters = data, query = data } = options\n  const wsParameters: WebSocketParameters = { url: new URL('about:blank') }\n  parseConnectUrl(wsParameters, channel, { baseUrl, protocol })\n  parseRequestParameters(wsParameters, { parameters })\n  parseRequestQuery(wsParameters, { query })\n  return wsParameters\n}\n","import type { Awaitable } from '@unshared/functions/awaitable'\nimport type { ConnectOptions } from './parseConnectOptions'\nimport { awaitable } from '@unshared/functions/awaitable'\nimport { parseConnectOptions } from './parseConnectOptions'\n\ntype RemoveListener = () => void\n\ntype ClientData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, infer R, any> ? R : any\n\ntype ServerData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, any, infer R> ? R : any\n\nexport class WebSocketChannel<T extends ConnectOptions = ConnectOptions> {\n  constructor(public channel: string, public options: T) {}\n\n  /** The WebSocket connection to the server. */\n  public webSocket: undefined | WebSocket\n\n  /**\n   * Open a new WebSocket connection to the server. The connection will be opened with the given\n   * URL and protocols. If the connection is already open, the connection will be closed before\n   * opening a new connection. Also add the event listeners that were passed in the options.\n   *\n   * @returns The WebSocket connection.\n   */\n  async open(): Promise<this> {\n    if (this.webSocket) await this.close()\n    const { url, protocol } = parseConnectOptions(this.channel, this.options)\n    this.webSocket = new WebSocket(url, protocol)\n\n    // --- Return a promise that resolves when the connection is opened.\n    const promise = new Promise<void>((resolve, rejects) => {\n      this.webSocket!.addEventListener('error', () => rejects(new Error('Failed to open the WebSocket connection')), { once: true })\n      this.webSocket!.addEventListener('open', () => {\n        if (this.options.initialPayload) this.send(this.options.initialPayload as ClientData<T>)\n        resolve()\n      }, { once: true })\n    })\n\n    // --- Add the options' hooks to the WebSocket connection.\n    if (this.options.onOpen) this.on('open', this.options.onOpen, { once: true })\n    if (this.options.onClose) this.on('close', this.options.onClose, { once: true })\n    if (this.options.onError) this.on('error', this.options.onError)\n    if (this.options.onMessage) this.on('message', message => this.options.onMessage!(message))\n\n    // --- Handle reconnection when the connection is closed unexpectedly.\n    this.webSocket.addEventListener('close', (event) => {\n      if (event.code === 1000) return\n      if (!this.options.autoReconnect) return\n      if (this.options.reconnectLimit && event.wasClean) return\n      setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0)\n    }, { once: true })\n\n    return promise.then(() => this)\n  }\n\n  /**\n   * Send a payload to the server. The payload will be serialized to JSON before sending.\n   *\n   * @param payload The data to send to the server.\n   */\n  send(payload: ClientData<T>) {\n    if (!this.webSocket) throw new Error('WebSocket connection is not open')\n    const json = JSON.stringify(payload)\n    this.webSocket.send(json)\n  }\n\n  /**\n   * Listen for events from the server. The event will be deserialized from JSON before calling the callback.\n   *\n   * @param event The event to listen for.\n   * @param callback The callback to call when the event is received.\n   * @returns A function to remove the event listener.\n   */\n  on(event: 'message', callback: (data: ServerData<T>) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'close', callback: (event: CloseEvent) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'error', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'open', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener\n  on(event: string, callback: (data: any) => any, options?: AddEventListenerOptions) {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n\n    const listener = async(event: CloseEvent | Event | MessageEvent<Blob>): Promise<void> => {\n      if (event.type !== 'message') callback(event)\n      // @ts-expect-error: `data` exists on the event.\n      let data = event.data as unknown\n      if (data instanceof Blob) data = await data.text()\n      try { data = JSON.parse(data as string) }\n      catch { console.error('Failed to parse the message:', data) }\n      callback(data)\n    }\n\n    /* eslint-disable @typescript-eslint/no-misused-promises */\n    this.webSocket.addEventListener(event, listener, options)\n    return () => this.webSocket!.removeEventListener(event, listener)\n    /* eslint-enable @typescript-eslint/no-misused-promises */\n  }\n\n  /**\n   * Close the WebSocket connection to the server. The connection will not be able to send or receive\n   * messages after it is closed.\n   */\n  async close() {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n    if (this.webSocket.readyState === WebSocket.CLOSED) return\n    if (this.webSocket.readyState === WebSocket.CLOSING) return\n    this.webSocket.close(1000, 'Client closed the connection')\n    await new Promise<void>(resolve => this.webSocket!.addEventListener('close', () => resolve()))\n  }\n}\n\n/**\n * Create a new WebSocket connection to the server with the given path. The connection will\n * automatically reconnect if the connection is closed unexpectedly.\n *\n * @param route The name of the route to connect to.\n * @param options The options to pass to the connection.\n * @returns The WebSocket connection.\n */\nexport function connect(route: string, options: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n  const channel = new WebSocketChannel(route, options)\n  return awaitable(channel, () => channel.open())\n}\n"],"names":["parseRequestParameters","parseRequestQuery","event","awaitable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/createClient.cjs b/dist/createClient.cjs
index 3fe57a738edc54876c65bd6d5cc100c33730de6d..09888d29b20477fa3f9ac542937f97ee35dac51e 100644
--- a/dist/createClient.cjs
+++ b/dist/createClient.cjs
@@ -1,9 +1,8 @@
 "use strict";
-var attempt = require("@unshared/functions/attempt"), request = require("./chunks/DXrQkl1A.cjs"), connect = require("./chunks/BdFNzMcu.cjs");
+var attempt = require("@unshared/functions/attempt"), request = require("./chunks/DXrQkl1A.cjs"), connect = require("./chunks/SZf7rksc.cjs");
 require("./chunks/CVzmr2NA.cjs");
 require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
-require("@unshared/functions");
 class Client {
   /**
    * Create a new client for the application.
diff --git a/dist/createClient.cjs.map b/dist/createClient.cjs.map
index 5fda2bb219d7ca4d753fc77c9606819d4cd10f15..ec91b6be84a359d8de54acb5fd4c67d4463c398f 100644
--- a/dist/createClient.cjs.map
+++ b/dist/createClient.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createClient.cjs","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { FetchOptions, RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }>\n  public fetch(route: string, options?: FetchOptions): Promise<Response>\n  public fetch(route: string, options?: FetchOptions): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>>\n  public request(route: string, options?: RequestOptions): Promise<unknown>\n  public request(route: string, options?: RequestOptions): Promise<unknown> {\n    return request(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options })\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":["fetch","request","attempt","connect"],"mappings":";;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA,EAaZ,MAAM,OAAe,SAA2C;AAC9D,WAAAA,QAAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAuB9C,QAAQ,OAAe,SAA4C;AACjE,WAAAC,QAAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAyBhD,eAAe,OAAe,SAAoD;AACvF,WAAOC,QAAAA,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA,EAa5C,QAAQ,SAAiB,SAAyE;AAChG,WAAAC,QAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;;;"}
\ No newline at end of file
+{"version":3,"file":"createClient.cjs","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { FetchOptions, RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }>\n  public fetch(route: string, options?: FetchOptions): Promise<Response>\n  public fetch(route: string, options?: FetchOptions): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>>\n  public request(route: string, options?: RequestOptions): Promise<unknown>\n  public request(route: string, options?: RequestOptions): Promise<unknown> {\n    return request(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options })\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":["fetch","request","attempt","connect"],"mappings":";;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA,EAaZ,MAAM,OAAe,SAA2C;AAC9D,WAAAA,QAAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAuB9C,QAAQ,OAAe,SAA4C;AACjE,WAAAC,QAAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAyBhD,eAAe,OAAe,SAAoD;AACvF,WAAOC,QAAAA,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA,EAa5C,QAAQ,SAAiB,SAAyE;AAChG,WAAAC,QAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;;;"}
\ No newline at end of file
diff --git a/dist/createClient.d.ts b/dist/createClient.d.ts
index aaa0036489882ab5a432fec00ae0f2767c875af1..1e0a1eb9ae11db9558323f362e1b5655e70add49 100644
--- a/dist/createClient.d.ts
+++ b/dist/createClient.d.ts
@@ -8,6 +8,7 @@ import '@unshared/types';
 import './HttpHeaders.js';
 import './HttpMethods.js';
 import 'openapi-types';
+import '@unshared/functions/awaitable';
 
 type Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown;
 type Routes = Record<string, RequestOptions>;
diff --git a/dist/createClient.js b/dist/createClient.js
index b4bce2388e771bd4d8936a0b4e9b164a1cf2a6d2..ba4101f9233ce6686b36d8578e47854d0b212b85 100644
--- a/dist/createClient.js
+++ b/dist/createClient.js
@@ -1,10 +1,9 @@
 import { attempt } from "@unshared/functions/attempt";
 import { f as fetch, r as request } from "./chunks/D1QsGr3A.js";
-import { c as connect } from "./chunks/Bys4-xE2.js";
+import { c as connect } from "./chunks/Cyb3f4h0.js";
 import "./chunks/CS5r-m4U.js";
 import "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
-import "@unshared/functions";
 class Client {
   /**
    * Create a new client for the application.
diff --git a/dist/createClient.js.map b/dist/createClient.js.map
index 53c4ec910304acda1a8258c378a9965f2c34b41c..ad52adb5d83d4762812cb14853c4f70ee9b12fe0 100644
--- a/dist/createClient.js.map
+++ b/dist/createClient.js.map
@@ -1 +1 @@
-{"version":3,"file":"createClient.js","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { FetchOptions, RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }>\n  public fetch(route: string, options?: FetchOptions): Promise<Response>\n  public fetch(route: string, options?: FetchOptions): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>>\n  public request(route: string, options?: RequestOptions): Promise<unknown>\n  public request(route: string, options?: RequestOptions): Promise<unknown> {\n    return request(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options })\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":[],"mappings":";;;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA,EAaZ,MAAM,OAAe,SAA2C;AAC9D,WAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAuB9C,QAAQ,OAAe,SAA4C;AACjE,WAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAyBhD,eAAe,OAAe,SAAoD;AACvF,WAAO,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA,EAa5C,QAAQ,SAAiB,SAAyE;AAChG,WAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;"}
\ No newline at end of file
+{"version":3,"file":"createClient.js","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { FetchOptions, RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }>\n  public fetch(route: string, options?: FetchOptions): Promise<Response>\n  public fetch(route: string, options?: FetchOptions): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>>\n  public request(route: string, options?: RequestOptions): Promise<unknown>\n  public request(route: string, options?: RequestOptions): Promise<unknown> {\n    return request(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>>\n  public requestAttempt(route: string, options?: RequestOptions): Promise<Result<unknown>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel>\n  public connect(channel: string, options?: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options })\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":[],"mappings":";;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA,EAaZ,MAAM,OAAe,SAA2C;AAC9D,WAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAuB9C,QAAQ,OAAe,SAA4C;AACjE,WAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA,EAyBhD,eAAe,OAAe,SAAoD;AACvF,WAAO,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA,EAa5C,QAAQ,SAAiB,SAAyE;AAChG,WAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;"}
\ No newline at end of file
diff --git a/dist/index.cjs b/dist/index.cjs
index 033393058c42e472326ef52f7ce86bc5e5f6dbf6..56583016789c592019bb259c0c1d02aad067d478 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -5,8 +5,7 @@ require("./chunks/DXrQkl1A.cjs");
 require("./chunks/CVzmr2NA.cjs");
 require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
-require("./chunks/BdFNzMcu.cjs");
-require("@unshared/functions");
+require("./chunks/SZf7rksc.cjs");
 require("./chunks/DEyigyGy.cjs");
 exports.Client = createClient.Client;
 exports.createClient = createClient.createClient;
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index f092322431f05f13c206b8226a1fce52cf84ad55..fee6f44f2616223ecf53d613da7e94f2d65135e9 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 78a6a25d45b73fde73efc7bdf2f33864c1710d67..8910ff165a236e74d5000fc0f304fbf611ff17d9 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -10,3 +10,4 @@ import '@unshared/types';
 import './chunks/5p4H9ZaI.js';
 import 'openapi-types';
 import './websocket.js';
+import '@unshared/functions/awaitable';
diff --git a/dist/index.js b/dist/index.js
index 0c4eb6fe515d770aefef9539b40b685528f39c41..c2978bd10794fb126f01bf699b5b702fabb1d84c 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -8,8 +8,7 @@ import "./chunks/D1QsGr3A.js";
 import "./chunks/CS5r-m4U.js";
 import "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
-import "./chunks/Bys4-xE2.js";
-import "@unshared/functions";
+import "./chunks/Cyb3f4h0.js";
 import "./chunks/B_Gz6Yz8.js";
 export {
   Client,
diff --git a/dist/index.js.map b/dist/index.js.map
index 10a431c8e5b1ba6e19d1b7b492e3d4b95feb5db9..dff53aea1c07185b2437885e5991228f9db35e53 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/websocket.cjs b/dist/websocket.cjs
index 02c2c4d0130cfe952a5e0ad5764951d83d436e9f..71a96477a942c83f80d659295e2411ac7146ab56 100644
--- a/dist/websocket.cjs
+++ b/dist/websocket.cjs
@@ -1,6 +1,6 @@
 "use strict";
-var connect = require("./chunks/BdFNzMcu.cjs");
-require("@unshared/functions");
+var connect = require("./chunks/SZf7rksc.cjs");
+require("@unshared/functions/awaitable");
 require("./chunks/BDxlAULu.cjs");
 exports.WebSocketChannel = connect.WebSocketChannel;
 exports.connect = connect.connect;
diff --git a/dist/websocket.d.ts b/dist/websocket.d.ts
index 6f00de2969465e1bd46128593beb2df8daf6592a..0e7ba667b731c518a8b287928b5dbc360f51ac5b 100644
--- a/dist/websocket.d.ts
+++ b/dist/websocket.d.ts
@@ -1,4 +1,4 @@
-import { Awaitable } from '@unshared/functions';
+import { Awaitable } from '@unshared/functions/awaitable';
 import { ObjectLike, Loose, UnionMerge } from '@unshared/types';
 
 /** The protocols to use for the connection. */
@@ -120,10 +120,10 @@ declare class WebSocketChannel<T extends ConnectOptions = ConnectOptions> {
      * @param callback The callback to call when the event is received.
      * @returns A function to remove the event listener.
      */
-    on(event: 'message', callback: (data: ServerData<T>) => void, options?: AddEventListenerOptions): RemoveListener;
-    on(event: 'close', callback: (event: CloseEvent) => void, options?: AddEventListenerOptions): RemoveListener;
-    on(event: 'error', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener;
-    on(event: 'open', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener;
+    on(event: 'message', callback: (data: ServerData<T>) => any, options?: AddEventListenerOptions): RemoveListener;
+    on(event: 'close', callback: (event: CloseEvent) => any, options?: AddEventListenerOptions): RemoveListener;
+    on(event: 'error', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener;
+    on(event: 'open', callback: (event: Event) => any, options?: AddEventListenerOptions): RemoveListener;
     /**
      * Close the WebSocket connection to the server. The connection will not be able to send or receive
      * messages after it is closed.
diff --git a/dist/websocket.js b/dist/websocket.js
index a3086b8238008411b59f07d5b9de95eb4c75db02..ec77336dedc4dfad3eee497861fa6626f21a0b70 100644
--- a/dist/websocket.js
+++ b/dist/websocket.js
@@ -1,5 +1,5 @@
-import { W, c, p } from "./chunks/Bys4-xE2.js";
-import "@unshared/functions";
+import { W, c, p } from "./chunks/Cyb3f4h0.js";
+import "@unshared/functions/awaitable";
 import "./chunks/B6pUErTM.js";
 export {
   W as WebSocketChannel,
