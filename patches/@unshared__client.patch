diff --git a/dist/chunks/2o4clKrH.js b/dist/chunks/2o4clKrH.js
new file mode 100644
index 0000000000000000000000000000000000000000..c300342b311a183cb6c21c632722d9fa99f1a380
--- /dev/null
+++ b/dist/chunks/2o4clKrH.js
@@ -0,0 +1,15 @@
+import { p as parseRequest, h as handleResponse } from "./BwI3JmT5.js";
+async function fetch(route, options = {}) {
+  const { url, init } = parseRequest(route, options);
+  if (!url) throw new Error("Could not parse request URL");
+  return await globalThis.fetch(url, init);
+}
+async function request(route, options = {}) {
+  const response = await fetch(route, options);
+  return await handleResponse(response, options);
+}
+export {
+  fetch as f,
+  request as r
+};
+//# sourceMappingURL=2o4clKrH.js.map
diff --git a/dist/chunks/2o4clKrH.js.map b/dist/chunks/2o4clKrH.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..176de26a1f6cd996ff1a693a67c6d8f43a283c7d
--- /dev/null
+++ b/dist/chunks/2o4clKrH.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"2o4clKrH.js","sources":["../../utils/fetch.ts","../../utils/request.ts"],"sourcesContent":["import type { FetchOptions } from './parseRequest'\nimport { parseRequest } from './parseRequest'\n\n/**\n * Fetch a route with the provided options. This function will parse the route and\n * options to create a `Request` object and return the response from the server.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The response from the server.\n * @example fetch('GET /users', { query: { limit: 10 } })\n */\nexport async function fetch(route: string, options?: FetchOptions): Promise<Response>\nexport async function fetch(route: string, options: FetchOptions = {}): Promise<Response> {\n  const { url, init } = parseRequest(route, options)\n  if (!url) throw new Error('Could not parse request URL')\n  return await globalThis.fetch(url, init)\n}\n","import type { ObjectLike } from '@unshared/types'\nimport type { FetchMethod, FetchOptions } from './parseRequest'\nimport { fetch } from './fetch'\nimport { handleResponse } from './handleResponse'\n\nexport interface RequestOptions<\n  Method extends FetchMethod = FetchMethod,\n  BaseUrl extends string = string,\n  Parameters extends ObjectLike = ObjectLike,\n  Query extends ObjectLike = ObjectLike,\n  Body = unknown,\n  Headers extends ObjectLike = ObjectLike,\n  Data = any,\n  Response = globalThis.Response,\n> extends\n  FetchOptions<Method, BaseUrl, Parameters, Query, Body, Headers> {\n\n  /**\n   * The callback that is called when an error occurs during the request.\n   */\n  onError?: (error: Error) => any\n\n  /**\n   * The callback that is called when data is received from the request. This callback\n   * will be called for each chunk of data that is received from the request.\n   */\n  onData?: (data: Data) => any\n\n  /**\n   * The callback that is called when the request is successful. This callback will be\n   * called after the request is complete and all data has been received.\n   */\n  onSuccess?: (response: Response) => any\n\n  /**\n   * The callback that is called when the status code is not OK. This callback will be called\n   * after the request is complete and before the data is consumed.\n   */\n  onFailure?: (response: Response) => any\n\n  /**\n   * The callback that is called when the request is complete. This callback will be called\n   * after the request is complete and all data has been received.\n   */\n  onEnd?: (response: Response) => any\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request(route: string, options?: RequestOptions): Promise<unknown>\nexport async function request(route: string, options: RequestOptions = {}): Promise<unknown> {\n  const response = await fetch(route, options)\n  return await handleResponse(response, options)\n}\n"],"names":[],"mappings":";AAaA,eAAsB,MAAM,OAAe,UAAwB,IAAuB;AACxF,QAAM,EAAE,KAAK,KAAA,IAAS,aAAa,OAAO,OAAO;AACjD,MAAI,CAAC,IAAW,OAAA,IAAI,MAAM,6BAA6B;AACvD,SAAO,MAAM,WAAW,MAAM,KAAK,IAAI;AACzC;ACiDA,eAAsB,QAAQ,OAAe,UAA0B,IAAsB;AAC3F,QAAM,WAAW,MAAM,MAAM,OAAO,OAAO;AACpC,SAAA,MAAM,eAAe,UAAU,OAAO;AAC/C;"}
\ No newline at end of file
diff --git a/dist/chunks/3E8iuIR5.d.ts b/dist/chunks/3E8iuIR5.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ac416cfab1c0b8b54fe0d3c8bd6c4d9d7fd4282f
--- /dev/null
+++ b/dist/chunks/3E8iuIR5.d.ts
@@ -0,0 +1,225 @@
+import { Loose, UnionMerge, Override, Pretty, CollectKey, MaybeLiteral, StringSplit } from '@unshared/types';
+import { F as FetchMethod, R as RequestOptions } from './BZ5qrH6f.js';
+import { OpenAPI } from 'openapi-types';
+
+/** Get the base URL of an OpenAPI specification. */
+type ServerUrl<T> = T extends {
+    host: infer Host extends string;
+    basePath?: infer BasePath extends string;
+    schemes?: Array<infer Scheme extends string>;
+} ? `${Scheme}://${Host}${BasePath}` : T extends {
+    servers: Array<{
+        url: infer U extends string;
+    }>;
+} ? U : string;
+/**
+ * Given an OpenAPI specification, get the first base URL.
+ *
+ * @param specification The OpenAPI specification.
+ * @returns The first base URL.
+ * @example getBaseUrl(specification) // 'https://api.example.com/v1'
+ */
+declare function getServerUrl<T>(specification: T): ServerUrl<T>;
+
+declare namespace OpenAPIV2 {
+    type ServerUrl<T> = T extends {
+        host: infer Host extends string;
+        basePath?: infer BasePath extends string;
+        schemes?: Array<infer Scheme extends string>;
+    } ? `${Scheme}://${Host}${BasePath}` : string;
+    /*************************************************************************/
+    /*************************************************************************/
+    type InferSchemaObject<T> = T extends {
+        properties: infer P extends Record<string, any>;
+        required: Array<infer R extends string>;
+    } ? ({
+        [K in keyof P as K extends R ? K : never]: InferSchema<P[K]>;
+    } & {
+        [K in keyof P as K extends R ? never : K]?: InferSchema<P[K]>;
+    }) : T extends {
+        properties: infer P extends Record<string, any>;
+    } ? {
+        [K in keyof P]?: InferSchema<P[K]>;
+    } : Record<string, unknown>;
+    type InferSchemaArray<T> = T extends {
+        items?: infer U;
+        additionalItems?: infer U;
+    } ? Array<InferSchema<U>> : unknown[];
+    type InferSchema<T> = Loose<(T extends {
+        anyOf: Array<infer U>;
+    } ? InferSchema<U> : T extends {
+        oneOf: Array<infer U>;
+    } ? InferSchema<U> : T extends {
+        allOf: Array<infer U>;
+    } ? UnionMerge<InferSchema<U>> : T extends {
+        schema: infer U;
+    } ? InferSchema<U> : T extends {
+        type: 'array';
+    } ? InferSchemaArray<T> : T extends {
+        type: 'object';
+    } ? InferSchemaObject<T> : T extends {
+        type: 'string';
+    } ? T extends {
+        enum: Array<infer U>;
+    } ? U : string : T extends {
+        type: 'integer' | 'number';
+    } ? number : T extends {
+        type: 'boolean';
+    } ? boolean : never) | (T extends {
+        nullable: true;
+    } ? undefined : never)>;
+    /*************************************************************************/
+    /*************************************************************************/
+    type Parameters<T, I extends string> = UnionMerge<T extends {
+        parameters: Array<infer U>;
+    } ? U extends {
+        in: I;
+        name: infer N extends string;
+    } ? Record<N, InferSchema<U> | (U extends {
+        required: true;
+    } ? never : undefined)> : never : never>;
+    type RequestBody<T> = Parameters<T, 'body'> extends Record<string, infer U> ? U : never;
+    type RequestQuery<T> = Parameters<T, 'query'>;
+    type RequestParameters<T> = Parameters<T, 'path'>;
+    type RequestHeaders<T> = UnionMerge<Parameters<T, 'header'> | (T extends {
+        consumes: Array<infer C>;
+    } ? {
+        'Content-Type'?: C;
+    } : never)>;
+    /*************************************************************************/
+    /*************************************************************************/
+    type ResponseBody<T> = T extends {
+        responses: Record<200, {
+            schema: infer S;
+        }>;
+    } ? NonNullable<InferSchema<S>> : never;
+    type Response<T> = T extends {
+        responses: infer R;
+    } ? ({
+        [P in keyof R]: Override<globalThis.Response, {
+            status: P extends 'default' ? number : P;
+            json: InferSchema<R[P]> extends (infer V | undefined) ? [never] extends V ? never : () => Promise<V> : never;
+        }>;
+    }) extends infer Result ? Result[keyof Result] : never : never;
+}
+
+declare namespace OpenAPIV3 {
+    type ServerUrl<T> = T extends {
+        servers: Array<{
+            url: infer U extends string;
+        }>;
+    } ? U : string;
+    type ServerHeaders<T> = T extends {
+        servers: Array<{
+            variables: infer V;
+        }>;
+    } ? V extends {
+        [K in keyof V]: {
+            enum: Array<infer U>;
+        };
+    } ? {
+        [K in keyof V]: U;
+    } : never : never;
+    type ServerQuery<T> = T extends {
+        components: {
+            securitySchemes: Record<string, {
+                in: 'query';
+                name: infer U extends string;
+            }>;
+        };
+    } ? Partial<Record<U, string>> : object;
+    /*************************************************************************/
+    /*************************************************************************/
+    type RequestBody<T> = T extends {
+        requestBody: {
+            content: infer C;
+        };
+    } ? C extends Record<string, {
+        schema: infer S;
+    }> ? OpenAPIV2.InferSchema<S> : object : object;
+    type RequestQuery<T> = OpenAPIV2.Parameters<T, 'query'>;
+    /*************************************************************************/
+    /*************************************************************************/
+    type ResponseBody<U> = U extends {
+        responses: Record<200, {
+            content: Record<string, {
+                schema: infer Schema;
+            }>;
+        }>;
+    } ? NonNullable<OpenAPIV2.InferSchema<Schema>> : never;
+    type Response<U> = U extends {
+        responses: infer Responses;
+    } ? ({
+        [Status in keyof Responses]: Responses[Status] extends {
+            content: Record<'application/json', infer Schema>;
+        } ? Pretty<Override<globalThis.Response, {
+            status: Status;
+            json: OpenAPIV2.InferSchema<Schema> extends (infer V | undefined) ? [never] extends V ? never : () => Promise<V> : never;
+        }>> : never;
+    }) extends infer Result ? Result[keyof Result] : never : never;
+}
+
+/** Union of all operation IDs in the specification. */
+type OperationId<T> = T extends {
+    paths: infer P;
+} ? P extends Record<string, infer R> ? R extends Record<string, infer O> ? O extends {
+    operationId: infer N;
+} ? N : string : string : string : string;
+/** A union of possible Operations types in the specification. */
+type Operation = OpenAPI.Operation & {
+    method: FetchMethod;
+    path: string;
+};
+/** Find an operation by its operationId in an OpenAPI specification. */
+type OperationById<T, U extends OperationId<T>> = T extends {
+    paths: infer P;
+} ? CollectKey<P> extends Record<string, infer R> ? CollectKey<R> extends Record<string, infer O> ? O extends {
+    $key: [infer P extends string, infer M extends string];
+    operationId: U;
+} ? Pretty<Omit<O, '$key'> & {
+    method: M;
+    path: P;
+}> : never : never : never : never;
+/**
+ * Given an OpenAPI specification, find an operation by its operationId.
+ *
+ * @param document The OpenAPI specification document.
+ * @param operationId The operationId of the operation to resolve.
+ * @returns The resolved operation.
+ * @example resolveOperation(document, 'getUser') // { method: 'get', path: '/users/{username}', ... }
+ */
+declare function resolveOperation<T, U extends OperationId<T>>(document: T, operationId: U): OperationById<T, U>;
+declare function resolveOperation(document: object, operationId: string): Operation;
+
+interface OpenAPIV2Like {
+    swagger: string;
+}
+interface OpenAPIV3Like {
+    openapi: string;
+}
+type OpenAPILike = OpenAPIV2Like | OpenAPIV3Like;
+/** The options to pass to the request. */
+type OperationOptions<T, V extends Operation> = T extends OpenAPIV2Like ? RequestOptions<never, MaybeLiteral<ServerUrl<T>>, OpenAPIV2.RequestParameters<V>, OpenAPIV2.RequestQuery<V>, OpenAPIV2.RequestBody<V>, OpenAPIV2.RequestHeaders<V>, OpenAPIV2.ResponseBody<V>> : T extends OpenAPIV3Like ? RequestOptions<never, MaybeLiteral<ServerUrl<T>>, OpenAPIV2.RequestParameters<V>, OpenAPIV3.RequestQuery<V> & OpenAPIV3.ServerQuery<T>, OpenAPIV3.RequestBody<V>, OpenAPIV2.RequestHeaders<V>, OpenAPIV3.ResponseBody<V>> : RequestOptions;
+/** The response data from the operation. */
+type OperationResult<T, V extends Operation> = T extends OpenAPIV2Like ? OpenAPIV2.ResponseBody<V> : T extends OpenAPIV3Like ? OpenAPIV3.ResponseBody<V> : unknown;
+/** The `Response` object from the operation. */
+type OperationResponse<T, V extends Operation> = T extends OpenAPIV2Like ? OpenAPIV2.Response<V> : T extends OpenAPIV3Like ? OpenAPIV3.Response<V> : globalThis.Response;
+/** Union of all operation route names in the specification. */
+type OperationRoute<T> = T extends {
+    paths: infer P;
+} ? CollectKey<P> extends Record<string, infer R> ? CollectKey<R> extends Record<string, infer O> ? O extends {
+    $key: [infer P extends string, infer M extends string];
+} ? `${Uppercase<M>} ${P}` : string : string : string : string;
+/** Find an operation by its route name in an OpenAPI specification. */
+type OperationByRoute<T, U extends OperationRoute<T>> = StringSplit<U, ' '> extends [infer M extends string, infer P extends string] ? T extends {
+    paths: infer U;
+} ? U extends Record<P, infer R> ? R extends Record<Lowercase<M>, infer O> ? Pretty<O & {
+    method: Lowercase<M>;
+    path: P;
+}> : never : never : never : never;
+/** The `ClientRoutes` inferred from the OpenAPI specification. */
+type OpenAPIOptionsMap<T> = {
+    [K in OperationRoute<T>]: OperationOptions<T, OperationByRoute<T, K>>;
+};
+
+export { type OpenAPILike as O, type ServerUrl as S, type OpenAPIOptionsMap as a, type OperationId as b, type OperationById as c, type OperationOptions as d, type OperationResult as e, OpenAPIV3 as f, getServerUrl as g, OpenAPIV2 as h, type Operation as i, type OpenAPIV2Like as j, type OpenAPIV3Like as k, type OperationResponse as l, type OperationRoute as m, type OperationByRoute as n, resolveOperation as r };
diff --git a/dist/chunks/B3X3mHFx.cjs b/dist/chunks/B3X3mHFx.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..852191a646617abeb04663df7d275af222f68d88
--- /dev/null
+++ b/dist/chunks/B3X3mHFx.cjs
@@ -0,0 +1,189 @@
+"use strict";
+var parseRequestQuery = require("./BDxlAULu.cjs"), awaitable = require("@unshared/functions/awaitable");
+function isObjectLike(value) {
+  return typeof value == "object" && value !== null && value.constructor === Object;
+}
+function setHeader(headers, key, value) {
+  if (value = String(value), headers instanceof Headers)
+    headers.set(key, value);
+  else if (Array.isArray(headers)) {
+    const keyLower = key.toLowerCase(), index = headers.findIndex(([k]) => k.toLowerCase() === keyLower);
+    index === -1 && headers.push([key, value]), headers[index] = [key, value];
+  } else if (typeof headers == "object" && headers !== null) {
+    const keyLower = key.toLowerCase();
+    for (const k in headers)
+      if (k.toLowerCase() === keyLower) {
+        headers[k] = value;
+        return;
+      }
+    headers[key] = value;
+  }
+}
+function parseRequestBasicAuth(context, options) {
+  const { username, password } = options;
+  if (typeof username != "string" || typeof password != "string") return;
+  const credentials = btoa(`${username}:${password}`);
+  context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Authorization", `Basic ${credentials}`);
+}
+function isFormDataLike(value) {
+  if (typeof value != "object" || value === null) return !1;
+  if (value instanceof FormData) return !0;
+  const values = Object.values(value);
+  return values.length === 0 ? !1 : values.every((x) => x instanceof File ? !0 : Array.isArray(x) ? x.every((item) => item instanceof File) : x instanceof Blob);
+}
+function toFormData(object) {
+  if (object instanceof FormData) return object;
+  const formData = new FormData();
+  for (const key in object) {
+    const value = object[key];
+    if (value !== void 0)
+      if (Array.isArray(value))
+        for (const item of value)
+          formData.append(key, item);
+      else
+        formData.append(key, value);
+  }
+  return formData;
+}
+function parseRequestBody(context, options) {
+  const { body } = options;
+  context.init?.method && (["get", "head", "delete"].includes(context.init.method) || body != null && (isFormDataLike(body) ? (context.init.body = toFormData(body), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "multipart/form-data")) : body instanceof ReadableStream ? (context.init.body = body, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "application/octet-stream")) : body instanceof File ? (context.init.body = body.stream(), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Disposition", `attachment; filename="${body.name}"`), setHeader(context.init.headers, "Content-Type", body.type), setHeader(context.init.headers, "Content-Length", body.size), setHeader(context.init.headers, "Content-Transfer-Encoding", "binary")) : isObjectLike(body) ? (context.init.body = JSON.stringify(body), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "application/json")) : context.init.body = body));
+}
+function parseRequestHeaders(context, options) {
+  const { headers } = options;
+  for (const key in headers) {
+    const value = headers[key];
+    (typeof value != "string" || value.length === 0) && typeof value != "number" || (context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, key, value));
+  }
+}
+function getHeader(headers, key) {
+  if (headers instanceof Headers)
+    return headers.get(key) ?? void 0;
+  if (Array.isArray(headers)) {
+    const keyLower = key.toLowerCase(), header = headers.find(([k]) => k.toLowerCase() === keyLower);
+    return header ? header[1] : void 0;
+  } else {
+    const keyLower = key.toLowerCase(), keys = Object.keys(headers), index = keys.findIndex((k) => k.toLowerCase() === keyLower);
+    return index === -1 ? void 0 : headers[keys[index]];
+  }
+}
+function getCookies(headers) {
+  const value = getHeader(headers, "Cookie");
+  if (!value) return {};
+  const cookies = {}, parts = value.split(";");
+  for (const part of parts) {
+    const [key, value2] = part.trim().split("=").map((v) => v.trim());
+    !key || !value2 || (cookies[key] = value2);
+  }
+  return cookies;
+}
+function setCookie(headers, key, value) {
+  const cookies = { ...getCookies(headers), [key]: value }, header = Object.entries(cookies).map(([key2, value2]) => `${key2}=${value2}`).join("; ");
+  setHeader(headers, "Cookie", header);
+}
+function parseRequestToken(context, options) {
+  const { token, tokenLocation = "headers", tokenProperty } = options;
+  if (token) {
+    if (tokenLocation === "query") {
+      if (!(context.url instanceof URL)) throw new Error("The `url` must be an instance of `URL`.");
+      if (!tokenProperty) throw new Error("The `tokenProperty` must be provided when using `tokenLocation` of `query`.");
+      context.url.searchParams.set(tokenProperty, token);
+    } else if (tokenLocation === "header")
+      context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, tokenProperty ? setHeader(context.init.headers, tokenProperty, token) : setHeader(context.init.headers, "Authorization", `Bearer ${token}`);
+    else if (tokenLocation === "cookie") {
+      if (!tokenProperty) throw new Error("The `tokenProperty` must be provided when using `tokenLocation` of `cookie`.");
+      context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setCookie(context.init.headers, tokenProperty, token);
+    }
+  }
+}
+const EXP_REQUEST = /^((?<method>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, METHODS = /* @__PURE__ */ new Set(["get", "post", "put", "patch", "delete", "head", "options"]);
+function parseRequestUrl(context, route, options) {
+  const { method, baseUrl } = options, match = EXP_REQUEST.exec(route);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeMethod = method ?? match.groups.method ?? "get", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const methodLower = routeMethod.toLowerCase();
+  if (!METHODS.has(methodLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeMethod}\` is invalid.`);
+  context.init = context.init ?? {}, context.init.method = methodLower, context.url = new URL(routeBaseUrl), context.url.pathname += context.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path;
+}
+function parseRequest(route, options = {}) {
+  const {
+    username,
+    password,
+    token,
+    tokenLocation,
+    tokenProperty,
+    data,
+    body,
+    query,
+    parameters,
+    headers,
+    method,
+    baseUrl,
+    queryArrayFormat,
+    ...init
+  } = options, context = { init }, dataObject = isObjectLike(data) ? data : void 0;
+  parseRequestUrl(context, route, { baseUrl, method }), parseRequestQuery.parseRequestParameters(context, { parameters: parameters ?? dataObject }), parseRequestBasicAuth(context, { username, password });
+  const requestMethod = context.init?.method?.toLowerCase() ?? "get", requestExpectsBody = ["post", "put", "patch"].includes(requestMethod);
+  return parseRequestQuery.parseRequestQuery(context, { queryArrayFormat, query: requestExpectsBody ? query : query ?? dataObject }), parseRequestToken(context, { token, tokenLocation, tokenProperty }), parseRequestBody(context, { body: requestExpectsBody ? body ?? dataObject : void 0 }), parseRequestHeaders(context, { headers }), context;
+}
+async function* createResponseStreamJsonIterator(response, options) {
+  const { onError, onSuccess, onData, onEnd } = options;
+  try {
+    const body = response.body;
+    if (body === null) throw new Error("Could not read the response body, it is empty.");
+    const reader = body.getReader();
+    for (; ; ) {
+      const { done, value } = await reader.read();
+      if (done) break;
+      const parts = new TextDecoder().decode(value).trim().split("\0").filter(Boolean);
+      for (const part of parts) {
+        const payload = JSON.parse(part);
+        onData && onData(payload), yield payload;
+      }
+    }
+    onSuccess && onSuccess(response);
+  } catch (error) {
+    onError && onError(error);
+  } finally {
+    onEnd && onEnd(response);
+  }
+}
+function handleResponseStreamJson(response, options) {
+  const responseIterator = createResponseStreamJsonIterator(response, options);
+  return awaitable.awaitable(responseIterator);
+}
+async function handleResponse(response, options = {}) {
+  const { onError, onSuccess, onData, onEnd, onFailure } = options, contentType = response.headers.get("Content-Type");
+  if (!response.ok)
+    throw onFailure && onFailure(response), onEnd && onEnd(response), new Error(response.statusText);
+  if (response.status === 204) {
+    onSuccess && onSuccess(response), onEnd && onEnd(response);
+    return;
+  }
+  return contentType?.startsWith("text/") ? await response.text().then((data) => (onData && onData(data), onSuccess && onSuccess(response), data)).catch((error) => {
+    throw onError && onError(error), error;
+  }).finally(() => {
+    onEnd && onEnd(response);
+  }) : contentType === "application/json" ? await response.json().then((data) => (onData && onData(data), onSuccess && onSuccess(response), data)).catch((error) => {
+    throw onError && onError(error), error;
+  }).finally(() => {
+    onEnd && onEnd(response);
+  }) : contentType === "application/stream+json" ? handleResponseStreamJson(response, options) : (onSuccess && onSuccess(response), onEnd && onEnd(response), response.body);
+}
+exports.getCookies = getCookies;
+exports.getHeader = getHeader;
+exports.handleResponse = handleResponse;
+exports.handleResponseStreamJson = handleResponseStreamJson;
+exports.isFormDataLike = isFormDataLike;
+exports.isObjectLike = isObjectLike;
+exports.parseRequest = parseRequest;
+exports.parseRequestBasicAuth = parseRequestBasicAuth;
+exports.parseRequestBody = parseRequestBody;
+exports.parseRequestHeaders = parseRequestHeaders;
+exports.parseRequestToken = parseRequestToken;
+exports.parseRequestUrl = parseRequestUrl;
+exports.setCookie = setCookie;
+exports.setHeader = setHeader;
+exports.toFormData = toFormData;
+//# sourceMappingURL=B3X3mHFx.cjs.map
diff --git a/dist/chunks/B3X3mHFx.cjs.map b/dist/chunks/B3X3mHFx.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..8f76b773b927f0e89b1e90cb07468304e919ded9
--- /dev/null
+++ b/dist/chunks/B3X3mHFx.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"B3X3mHFx.cjs","sources":["../../utils/isObjectLike.ts","../../utils/setHeader.ts","../../utils/parseRequestBasicAuth.ts","../../utils/isFormDataLike.ts","../../utils/toFormData.ts","../../utils/parseRequestBody.ts","../../utils/parseRequestHeaders.ts","../../utils/getHeader.ts","../../utils/getCookies.ts","../../utils/setCookie.ts","../../utils/parseRequestToken.ts","../../utils/parseRequestUrl.ts","../../utils/parseRequest.ts","../../utils/handleResponseStreamJson.ts","../../utils/handleResponse.ts"],"sourcesContent":["import type { ObjectLike } from '@unshared/types'\n\n/**\n * Predicate to check if a value is an object-like value.\n *\n * @param value The value to check.\n * @returns `true` if the value is an object-like value, `false` otherwise.\n * @example isObjectLike({}) // true\n */\nexport function isObjectLike(value: unknown): value is ObjectLike {\n  return typeof value === 'object' && value !== null && value.constructor === Object\n}\n","/**\n * Set a header in the `HeadersInit` object whether it is a `Headers` instance, an\n * array of key-value pairs, or an object. It is also case-insensitive, meaning that\n * if a header with the same key but different case is found, it will be replaced.\n *\n * @param headers The headers to set the key-value pair in.\n * @param key The key of the header to set.\n * @param value The value of the header to set.\n * @example\n * const headers = new Headers()\n * setHeader(headers, 'Content-Type', 'application/json')\n * console.log(headers.get('Content-Type')) // 'application/json'\n */\nexport function setHeader(headers: HeadersInit, key: string, value: number | string): void {\n  value = String(value)\n  if (headers instanceof Headers) {\n    headers.set(key, value)\n  }\n  else if (Array.isArray(headers)) {\n    const keyLower = key.toLowerCase()\n    const index = headers.findIndex(([k]) => k.toLowerCase() === keyLower)\n    if (index === -1) headers.push([key, value])\n    headers[index] = [key, value]\n  }\n  else if (typeof headers === 'object' && headers !== null) {\n    const keyLower = key.toLowerCase()\n    for (const k in headers) {\n      if (k.toLowerCase() !== keyLower) continue\n      headers[k] = value\n      return\n    }\n    headers[key] = value\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the basic authentication headers based on the provided username and password.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n *\n * // Append the `Authorization` header to the request.\n * const context = {}\n * parseRequestBasicAuth(context, { username: 'user', password: 'pass' })\n *\n * // Will mutate the `init` object to include the headers.\n * console.log(context) // => { init: { headers: { 'Authorization': 'Basic dXNlcjpwYXNz' } } }\n */\nexport function parseRequestBasicAuth(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { username, password } = options\n\n  // --- Return early if the username or password is not provided.\n  if (typeof username !== 'string' || typeof password !== 'string') return\n\n  // --- Encode the credentials and set the Authorization header.\n  const credentials = btoa(`${username}:${password}`)\n  context.init = context.init ?? {}\n  context.init.headers = context.init.headers ?? {}\n  setHeader(context.init.headers, 'Authorization', `Basic ${credentials}`)\n}\n","/**\n * A type that represents a FormData-like object, which is a plain object with\n * nested Blob, File, or FileList values. Or a FormData instance.\n */\nexport type FormDataLike = FormData | Record<string, Blob | File | FileList>\n\n/**\n * Predicate to check if a value is FormData-like, meaning it is a plain object\n * with nested Blob, File, or FileList values.\n *\n * @param value The value to check.\n * @returns `true` if the value is FormData-like, `false` otherwise.\n * @example isFormDataLike({ file: new File(['test'], 'test.txt') }) // true\n */\nexport function isFormDataLike(value: unknown): value is FormDataLike {\n  if (typeof value !== 'object' || value === null) return false\n  if (value instanceof FormData) return true\n  const values = Object.values(value)\n  if (values.length === 0) return false\n  return values.every((x) => {\n    if (x instanceof File) return true\n    if (Array.isArray(x)) return x.every(item => item instanceof File)\n    return x instanceof Blob\n  })\n}\n","import type { FormDataLike } from './isFormDataLike'\n\n/**\n * Casts an object that may contain `Blob`, `File`, or `FileList` values to a `FormData` object.\n *\n * @param object The object to cast to a `FormData` object.\n * @returns The `FormData` object.\n */\nexport function toFormData(object: FormDataLike): FormData {\n  if (object instanceof FormData) return object\n  const formData = new FormData()\n  for (const key in object) {\n    const value = object[key]\n    if (value === undefined) continue\n    if (Array.isArray(value)) {\n      for (const item of value)\n        formData.append(key, item as Blob | string)\n    }\n    else {\n      formData.append(key, value as Blob | string)\n    }\n  }\n  return formData\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { isFormDataLike } from './isFormDataLike'\nimport { isObjectLike } from './isObjectLike'\nimport { setHeader } from './setHeader'\nimport { toFormData } from './toFormData'\n\n/**\n * Parse the request body based on the provided data and options.\n *\n * @param context The request context.\n * @param options The request options.\n */\nexport function parseRequestBody(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { body } = options\n\n  // --- If the method is `GET`, `HEAD`, or `DELETE`, return early.\n  if (!context.init?.method) return\n  if (['get', 'head', 'delete'].includes(context.init.method)) return\n\n  // --- If no data is provided, return early.\n  if (body === null || body === undefined) return\n\n  // --- If data contains a `File` object, create a FormData object.\n  if (isFormDataLike(body)) {\n    context.init.body = toFormData(body)\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'multipart/form-data')\n  }\n\n  // --- If the data is a `ReadableStream`, pass it directly to the body.\n  else if (body instanceof ReadableStream) {\n    context.init.body = body\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'application/octet-stream')\n  }\n\n  // --- If the data is a Blob, pass it directly to the body.\n  else if (body instanceof File) {\n    context.init.body = body.stream()\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Disposition', `attachment; filename=\"${body.name}\"`)\n    setHeader(context.init.headers, 'Content-Type', body.type)\n    setHeader(context.init.headers, 'Content-Length', body.size)\n    setHeader(context.init.headers, 'Content-Transfer-Encoding', 'binary')\n  }\n\n  // --- Otherwise, stringify the data and set the content type to JSON.\n  else if (isObjectLike(body)) {\n    context.init.body = JSON.stringify(body)\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'application/json')\n  }\n\n  // --- For all other data types, set the body directly.\n  else {\n    context.init.body = body as BodyInit\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the request headers based on the provided data and options.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n *\n * // Append the `Content-Type` header to the request.\n * const context = {}\n * parseRequestHeaders(context, { headers: { 'Content-Type': 'application/json' } })\n *\n * // Will mutate the `init` object to include the headers.\n * console.log(context) // => { init: { headers: { 'Content-Type': 'application/json' } } }\n */\nexport function parseRequestHeaders(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { headers } = options\n\n  // --- Merge the headers with the existing headers.\n  for (const key in headers) {\n    const value = headers[key]\n    if (((typeof value !== 'string' || value.length === 0) && typeof value !== 'number')) continue\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, key, value)\n  }\n}\n","/**\n * Get a header value from the `HeadersInit` object.\n *\n * @param headers The headers to get the key-value pair from.\n * @param key The key of the header to get.\n * @returns The value of the header.\n * @example\n * const headers = new Headers({ 'Content-Type': 'application/json' })\n * const contentType = getHeader(headers, 'Content-Type')\n * console.log(contentType) // 'application/json'\n */\nexport function getHeader(headers: HeadersInit, key: string): string | undefined {\n  if (headers instanceof Headers) {\n    return headers.get(key) ?? undefined\n  }\n  else if (Array.isArray(headers)) {\n    const keyLower = key.toLowerCase()\n    const header = headers.find(([k]) => k.toLowerCase() === keyLower)\n    return header ? header[1] : undefined\n  }\n  else {\n    const keyLower = key.toLowerCase()\n    const keys = Object.keys(headers)\n    const index = keys.findIndex(k => k.toLowerCase() === keyLower)\n    return index === -1 ? undefined : headers[keys[index]]\n  }\n}\n","import { getHeader } from './getHeader'\n\n/**\n * Extract the cookies from the `HeadersInit` object.\n *\n * @param headers The headers to extract the cookies from.\n * @returns An array of cookies.\n * @example\n * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })\n * const cookies = getCookies(headers) // { key1: 'value1', key2: 'value2' }\n */\nexport function getCookies(headers: HeadersInit): Record<string, string> {\n  const value = getHeader(headers, 'Cookie')\n  if (!value) return {}\n\n  // --- Parse the cookie header.\n  const cookies: Record<string, string> = {}\n  const parts = value.split(';')\n  for (const part of parts) {\n    const [key, value] = part.trim().split('=').map(v => v.trim())\n    if (!key || !value) continue\n    cookies[key] = value\n  }\n\n  // --- Return the cookies.\n  return cookies\n}\n","import { getCookies } from './getCookies'\nimport { setHeader } from './setHeader'\n\n/**\n * Set a cookie in the `HeadersInit` object.\n *\n * @param headers The headers to set the cookie in.\n * @param key The key of the cookie to set.\n * @param value The value of the cookie to set.\n * @example\n * const headers = new Headers()\n * const cookie = { key: 'key1', value: 'value1', path: '/', secure: true }\n * setCookie(headers, cookie)\n * console.log(headers.get('Cookie')) // 'key1=value1; Path=/; Secure'\n */\nexport function setCookie(headers: HeadersInit, key: string, value: string): void {\n  const cookies = { ...getCookies(headers), [key]: value }\n  const header = Object.entries(cookies).map(([key, value]) => `${key}=${value}`).join('; ')\n  setHeader(headers, 'Cookie', header)\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setCookie } from './setCookie'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the token and dynamically extend either the query, headers, or cookies.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n * // Append the `token` to the query parameters.\n * const context = { url: new URL('https://example.com') }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'query', tokenProperty: 'token' })\n * console.log(context.url.searchParams.get('token')) // 'my-token'\n *\n * @example\n * // Append the `token` to the headers.\n * const context = { init: { headers: new Headers() } }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'header', tokenProperty: 'Authorization' })\n * console.log(context.init.headers.get('Authorization')) // 'Bearer my-token'\n *\n * @example\n * // Append the `token` to the cookies.\n * const context = { init: { headers: new Headers() } }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'cookie', tokenProperty: 'token' })\n * console.log(context.init.headers.get('Cookie')) // 'token=my-token'\n */\nexport function parseRequestToken(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { token, tokenLocation = 'headers', tokenProperty } = options\n\n  // --- Return early if the token is not provided.\n  if (!token) return\n\n  // --- Append the token to the query parameters.\n  if (tokenLocation === 'query') {\n    if (context.url instanceof URL === false) throw new Error('The `url` must be an instance of `URL`.')\n    if (!tokenProperty) throw new Error('The `tokenProperty` must be provided when using `tokenLocation` of `query`.')\n    context.url.searchParams.set(tokenProperty, token)\n  }\n\n  // --- Append the token to the path parameters.\n  else if (tokenLocation === 'header') {\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    if (tokenProperty) setHeader(context.init.headers, tokenProperty, token)\n    else setHeader(context.init.headers, 'Authorization', `Bearer ${token}`)\n  }\n\n  // --- Append the token to the cookie header.\n  else if (tokenLocation === 'cookie') {\n    if (!tokenProperty) throw new Error('The `tokenProperty` must be provided when using `tokenLocation` of `cookie`.')\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    setCookie(context.init.headers, tokenProperty, token)\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_REQUEST = /^((?<method>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid HTTP methods. */\nconst METHODS = new Set(['get', 'post', 'put', 'patch', 'delete', 'head', 'options'])\n\n/**\n * Parses the route name to extract the URL and method. It allows the url and method to be\n * provided in the route name, or in the options object. The method will default to 'get'.\n *\n * @param context The request context to mutate.\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @example parseRequestUrl('GET /users', { baseUrl: 'https://api.example.com' }, context)\n */\nexport function parseRequestUrl(context: Partial<RequestContext>, route: string, options: FetchOptions): void {\n  const { method, baseUrl } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_REQUEST.exec(route)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeMethod = method ?? match.groups.method ?? 'get'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const methodLower = routeMethod.toLowerCase()\n  const methodIsValid = METHODS.has(methodLower)\n  if (!methodIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeMethod}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  context.init = context.init ?? {}\n  context.init.method = methodLower\n  context.url = new URL(routeBaseUrl)\n\n  // --- Append the path to the URL while making sure there are no double slashes.\n  context.url.pathname += context.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n}\n","import type { Loose, MaybeLiteral, ObjectLike } from '@unshared/types'\nimport type { UnionMerge } from '@unshared/types'\nimport type { HttpHeader } from '../HttpHeaders'\nimport type { HttpMethod } from '../HttpMethods'\nimport type { SearchArrayFormat } from './toSearchParams'\nimport { isObjectLike } from './isObjectLike'\nimport { parseRequestBasicAuth } from './parseRequestBasicAuth'\nimport { parseRequestBody } from './parseRequestBody'\nimport { parseRequestHeaders } from './parseRequestHeaders'\nimport { parseRequestParameters } from './parseRequestParameters'\nimport { parseRequestQuery } from './parseRequestQuery'\nimport { parseRequestToken } from './parseRequestToken'\nimport { parseRequestUrl } from './parseRequestUrl'\n\n/** The methods to use for the request. */\nexport type FetchMethod = Lowercase<keyof typeof HttpMethod> | Uppercase<keyof typeof HttpMethod>\n\n/** Headers to include in the request. */\nexport type FetchHeaders = Partial<Record<MaybeLiteral<HttpHeader>, number | string>>\n\n/** Options to pass to the request. */\nexport interface FetchOptions<\n  Method extends FetchMethod = FetchMethod,\n  BaseUrl extends string = string,\n  Parameters extends ObjectLike = ObjectLike,\n  Query extends ObjectLike = ObjectLike,\n  Body = unknown,\n  Headers extends ObjectLike = ObjectLike,\n> extends Omit<RequestInit, 'body' | 'headers' | 'method'> {\n\n  /**\n   * The method to use for the request.\n   *\n   * @example 'GET'\n   */\n  method?: Method\n\n  /**\n   * The base URL to use for the request. This URL will be used to resolve the\n   * path and query parameters of the request.\n   *\n   * @example 'https://api.example.com'\n   */\n  baseUrl?: BaseUrl\n\n  /**\n   * The data to include in the request. This data will be used to populate the\n   * query parameters, body, and headers of the request based on the method type.\n   *\n   * @example { id: 1 }\n   */\n  data?: Loose<UnionMerge<Body | Headers | Query>>\n\n  /**\n   * The path parameters to include in the request.\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to include in the request.\n   */\n  query?: Loose<Query>\n\n  /**\n   * The format to use when serializing the query parameters.\n   */\n  queryArrayFormat?: SearchArrayFormat\n\n  /**\n   * The body to include in the request.\n   */\n  body?: Body extends ObjectLike ? Loose<Body> : Body\n\n  /**\n   * The headers to include in the request.\n   */\n  headers?: FetchHeaders & Headers\n\n  /**\n   * The username for basic authentication.\n   */\n  username?: string\n\n  /**\n   * The password for basic authentication.\n   */\n  password?: string\n\n  /**\n   * The token for API key authentication.\n   */\n  token?: string\n\n  /**\n   * The location where the token should be included in the request.\n   */\n  tokenLocation?: 'cookie' | 'header' | 'query'\n\n  /**\n   * The name of the key to use in the request for the token.\n   */\n  tokenProperty?: string\n}\n\nexport interface RequestContext {\n  url: URL\n  init: RequestInit\n}\n\n/**\n * Resolves the request body and/or query parameters based on the method type. This function\n * will mutate the `init` object to include the request body and headers based on the data type.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The URL and the `RequestInit` object.\n */\nexport function parseRequest(route: string, options: FetchOptions = {}): RequestContext {\n  const {\n    username,\n    password,\n    token,\n    tokenLocation,\n    tokenProperty,\n    data,\n    body,\n    query,\n    parameters,\n    headers,\n    method,\n    baseUrl,\n    queryArrayFormat,\n    ...init\n  } = options\n  const context: Partial<RequestContext> = { init }\n  const dataObject = isObjectLike(data) ? data : undefined\n\n  // --- Parse the URL and insert the path parameters.\n  parseRequestUrl(context, route, { baseUrl, method })\n  parseRequestParameters(context, { parameters: parameters ?? dataObject })\n  parseRequestBasicAuth(context, { username, password })\n\n  // --- Depending on the method, parse the query, body, and headers.\n  const requestMethod = context.init?.method?.toLowerCase() ?? 'get'\n  const requestExpectsBody = ['post', 'put', 'patch'].includes(requestMethod)\n  parseRequestQuery(context, { queryArrayFormat, query: requestExpectsBody ? query : query ?? dataObject })\n  parseRequestToken(context, { token, tokenLocation, tokenProperty })\n  parseRequestBody(context, { body: requestExpectsBody ? body ?? dataObject : undefined })\n  parseRequestHeaders(context, { headers })\n\n  // --- Return the context with the URL and the `RequestInit` object.\n  return context as RequestContext\n}\n","import type { Awaitable } from '@unshared/functions/awaitable'\nimport type { RequestOptions } from './request'\nimport { awaitable } from '@unshared/functions/awaitable'\n\nasync function * createResponseStreamJsonIterator(response: Response, options: RequestOptions): AsyncGenerator<unknown, void, unknown> {\n  const { onError, onSuccess, onData, onEnd } = options\n  try {\n    const body = response.body\n    if (body === null) throw new Error('Could not read the response body, it is empty.')\n    const reader = body.getReader()\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) break\n      const parts = new TextDecoder().decode(value).trim().split('\\0').filter(Boolean)\n\n      // --- For each part, parse as JSON and yield the data.\n      for (const part of parts) {\n        const payload = JSON.parse(part) as unknown\n        if (onData) onData(payload)\n        yield payload\n      }\n    }\n    if (onSuccess) onSuccess(response)\n  }\n  catch (error) {\n    if (onError) onError(error as Error)\n  }\n  finally {\n    if (onEnd) onEnd(response)\n  }\n}\n\n/**\n * Handle a request response where the content type is a stream of JSON objects. This function\n * will parse the JSON objects and yield the data to the caller. If an error occurs, the `onError`\n * callback will be called and the function will return.\n *\n * @param response The response to handle.\n * @param options The options to pass to the request.\n * @returns An awaitable iterator that yields the parsed JSON objects.\n */\nexport function handleResponseStreamJson(response: Response, options: RequestOptions): Awaitable<AsyncIterable<unknown>, unknown[]> {\n  const responseIterator = createResponseStreamJsonIterator(response, options)\n  return awaitable(responseIterator)\n}\n","import type { RequestOptions } from './request'\nimport { handleResponseStreamJson } from './handleResponseStreamJson'\n\n/**\n * Handle a request response. This function will parse the response based on the content type and\n * return the data. If an error occurs, the `onError` callback will be called and the function will\n * throw an error.\n *\n * @param response The response to handle.\n * @param options The options to pass to the request.\n * @returns The parsed data from the response.\n */\nexport async function handleResponse(response: Response, options: RequestOptions = {}): Promise<unknown> {\n  const { onError, onSuccess, onData, onEnd, onFailure } = options\n  const contentType = response.headers.get('Content-Type')\n\n  // --- If the response is not OK, throw an error with the response message.\n  if (!response.ok) {\n    if (onFailure) onFailure(response)\n    if (onEnd) onEnd(response)\n    throw new Error(response.statusText)\n  }\n\n  // --- If the status code is 204, return an empty response early.\n  if (response.status === 204) {\n    if (onSuccess) onSuccess(response)\n    if (onEnd) onEnd(response)\n    return\n  }\n\n  // --- If the response is a text content type, return the text response.\n  if (contentType?.startsWith('text/')) {\n    return await response.text()\n      .then((data) => {\n        if (onData) onData(data)\n        if (onSuccess) onSuccess(response)\n        return data\n      })\n      .catch((error: Error) => {\n        if (onError) onError(error)\n        throw error\n      })\n      .finally(() => {\n        if (onEnd) onEnd(response)\n      })\n  }\n\n  // --- If the response is a application/json, parse the JSON and return it.\n  if (contentType === 'application/json') {\n    return await response.json()\n      .then((data) => {\n        if (onData) onData(data)\n        if (onSuccess) onSuccess(response)\n        return data as unknown\n      })\n      .catch((error: Error) => {\n        if (onError) onError(error)\n        throw error\n      })\n      .finally(() => {\n        if (onEnd) onEnd(response)\n      })\n  }\n\n  // --- If the response is a application/stream+json, return an iterator that parses the JSON.\n  if (contentType === 'application/stream+json')\n    return handleResponseStreamJson(response, options)\n\n  // --- Otherwise, fallback to returning the response body as-is.\n  if (onSuccess) onSuccess(response)\n  if (onEnd) onEnd(response)\n  return response.body\n}\n"],"names":["value","key","parseRequestParameters","parseRequestQuery","awaitable"],"mappings":";;AASO,SAAS,aAAa,OAAqC;AAChE,SAAO,OAAO,SAAU,YAAY,UAAU,QAAQ,MAAM,gBAAgB;AAC9E;ACEgB,SAAA,UAAU,SAAsB,KAAa,OAA8B;AAEzF,MADA,QAAQ,OAAO,KAAK,GAChB,mBAAmB;AACb,YAAA,IAAI,KAAK,KAAK;AAAA,WAEf,MAAM,QAAQ,OAAO,GAAG;AAC/B,UAAM,WAAW,IAAI,YAAY,GAC3B,QAAQ,QAAQ,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,YAAA,MAAkB,QAAQ;AACjE,cAAU,MAAI,QAAQ,KAAK,CAAC,KAAK,KAAK,CAAC,GAC3C,QAAQ,KAAK,IAAI,CAAC,KAAK,KAAK;AAAA,EAErB,WAAA,OAAO,WAAY,YAAY,YAAY,MAAM;AAClD,UAAA,WAAW,IAAI,YAAY;AACjC,eAAW,KAAK;AACV,UAAA,EAAE,YAAY,MAAM,UACxB;AAAA,gBAAQ,CAAC,IAAI;AACb;AAAA,MAAA;AAEF,YAAQ,GAAG,IAAI;AAAA,EAAA;AAEnB;AChBgB,SAAA,sBAAsB,SAAkC,SAA6B;AAC7F,QAAA,EAAE,UAAU,SAAA,IAAa;AAG/B,MAAI,OAAO,YAAa,YAAY,OAAO,YAAa,SAAU;AAGlE,QAAM,cAAc,KAAK,GAAG,QAAQ,IAAI,QAAQ,EAAE;AAC1C,UAAA,OAAO,QAAQ,QAAQ,CAAA,GAC/B,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,IAC/C,UAAU,QAAQ,KAAK,SAAS,iBAAiB,SAAS,WAAW,EAAE;AACzE;ACdO,SAAS,eAAe,OAAuC;AACpE,MAAI,OAAO,SAAU,YAAY,UAAU,KAAa,QAAA;AACpD,MAAA,iBAAiB,SAAiB,QAAA;AAChC,QAAA,SAAS,OAAO,OAAO,KAAK;AAC9B,SAAA,OAAO,WAAW,IAAU,KACzB,OAAO,MAAM,CAAC,MACf,aAAa,OAAa,KAC1B,MAAM,QAAQ,CAAC,IAAU,EAAE,MAAM,UAAQ,gBAAgB,IAAI,IAC1D,aAAa,IACrB;AACH;AChBO,SAAS,WAAW,QAAgC;AACrD,MAAA,kBAAkB,SAAiB,QAAA;AACjC,QAAA,WAAW,IAAI,SAAS;AAC9B,aAAW,OAAO,QAAQ;AAClB,UAAA,QAAQ,OAAO,GAAG;AACxB,QAAI,UAAU;AACV,UAAA,MAAM,QAAQ,KAAK;AACrB,mBAAW,QAAQ;AACR,mBAAA,OAAO,KAAK,IAAqB;AAAA;AAGnC,iBAAA,OAAO,KAAK,KAAsB;AAAA,EAAA;AAGxC,SAAA;AACT;ACXgB,SAAA,iBAAiB,SAAkC,SAA6B;AACxF,QAAA,EAAE,SAAS;AAGZ,UAAQ,MAAM,WACf,CAAC,OAAO,QAAQ,QAAQ,EAAE,SAAS,QAAQ,KAAK,MAAM,KAGtD,QAAS,SAGT,eAAe,IAAI,KACrB,QAAQ,KAAK,OAAO,WAAW,IAAI,GACnC,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAAA,GAC/C,UAAU,QAAQ,KAAK,SAAS,gBAAgB,qBAAqB,KAI9D,gBAAgB,kBACvB,QAAQ,KAAK,OAAO,MACpB,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAC/C,GAAA,UAAU,QAAQ,KAAK,SAAS,gBAAgB,0BAA0B,KAInE,gBAAgB,QACvB,QAAQ,KAAK,OAAO,KAAK,OAAO,GAChC,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAAA,GAC/C,UAAU,QAAQ,KAAK,SAAS,uBAAuB,yBAAyB,KAAK,IAAI,GAAG,GAC5F,UAAU,QAAQ,KAAK,SAAS,gBAAgB,KAAK,IAAI,GACzD,UAAU,QAAQ,KAAK,SAAS,kBAAkB,KAAK,IAAI,GAC3D,UAAU,QAAQ,KAAK,SAAS,6BAA6B,QAAQ,KAI9D,aAAa,IAAI,KACxB,QAAQ,KAAK,OAAO,KAAK,UAAU,IAAI,GACvC,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,IAC/C,UAAU,QAAQ,KAAK,SAAS,gBAAgB,kBAAkB,KAKlE,QAAQ,KAAK,OAAO;AAExB;ACxCgB,SAAA,oBAAoB,SAAkC,SAA6B;AAC3F,QAAA,EAAE,YAAY;AAGpB,aAAW,OAAO,SAAS;AACnB,UAAA,QAAQ,QAAQ,GAAG;AACzB,KAAM,OAAO,SAAU,YAAY,MAAM,WAAW,MAAM,OAAO,SAAU,aAC3E,QAAQ,OAAO,QAAQ,QAAQ,CAAA,GAC/B,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAAA,GAC/C,UAAU,QAAQ,KAAK,SAAS,KAAK,KAAK;AAAA,EAAA;AAE9C;ACjBgB,SAAA,UAAU,SAAsB,KAAiC;AAC/E,MAAI,mBAAmB;AACd,WAAA,QAAQ,IAAI,GAAG,KAAK;AAEpB,MAAA,MAAM,QAAQ,OAAO,GAAG;AAC/B,UAAM,WAAW,IAAI,YAAY,GAC3B,SAAS,QAAQ,KAAK,CAAC,CAAC,CAAC,MAAM,EAAE,YAAA,MAAkB,QAAQ;AAC1D,WAAA,SAAS,OAAO,CAAC,IAAI;AAAA,EAAA,OAEzB;AACH,UAAM,WAAW,IAAI,YAAA,GACf,OAAO,OAAO,KAAK,OAAO,GAC1B,QAAQ,KAAK,UAAU,CAAA,MAAK,EAAE,kBAAkB,QAAQ;AAC9D,WAAO,UAAU,KAAK,SAAY,QAAQ,KAAK,KAAK,CAAC;AAAA,EAAA;AAEzD;ACfO,SAAS,WAAW,SAA8C;AACjE,QAAA,QAAQ,UAAU,SAAS,QAAQ;AACrC,MAAA,CAAC,MAAO,QAAO,CAAC;AAGpB,QAAM,UAAkC,CAAA,GAClC,QAAQ,MAAM,MAAM,GAAG;AAC7B,aAAW,QAAQ,OAAO;AACxB,UAAM,CAAC,KAAKA,MAAK,IAAI,KAAK,KAAK,EAAE,MAAM,GAAG,EAAE,IAAI,CAAK,MAAA,EAAE,MAAM;AACzD,KAAC,OAAO,CAACA,WACb,QAAQ,GAAG,IAAIA;AAAAA,EAAA;AAIV,SAAA;AACT;ACXgB,SAAA,UAAU,SAAsB,KAAa,OAAqB;AAChF,QAAM,UAAU,EAAE,GAAG,WAAW,OAAO,GAAG,CAAC,GAAG,GAAG,SAC3C,SAAS,OAAO,QAAQ,OAAO,EAAE,IAAI,CAAC,CAACC,MAAKD,MAAK,MAAM,GAAGC,IAAG,IAAID,MAAK,EAAE,EAAE,KAAK,IAAI;AAC/E,YAAA,SAAS,UAAU,MAAM;AACrC;ACQgB,SAAA,kBAAkB,SAAkC,SAA6B;AAC/F,QAAM,EAAE,OAAO,gBAAgB,WAAW,cAAkB,IAAA;AAGvD,MAAA;AAGL,QAAI,kBAAkB,SAAS;AAC7B,UAAI,UAAQ,eAAe,KAAqB,OAAA,IAAI,MAAM,yCAAyC;AACnG,UAAI,CAAC,cAAqB,OAAA,IAAI,MAAM,6EAA6E;AACjH,cAAQ,IAAI,aAAa,IAAI,eAAe,KAAK;AAAA,IAAA,WAI1C,kBAAkB;AACzB,cAAQ,OAAO,QAAQ,QAAQ,CAC/B,GAAA,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAAA,GAC3C,gBAAe,UAAU,QAAQ,KAAK,SAAS,eAAe,KAAK,IAClE,UAAU,QAAQ,KAAK,SAAS,iBAAiB,UAAU,KAAK,EAAE;AAAA,aAIhE,kBAAkB,UAAU;AACnC,UAAI,CAAC,cAAqB,OAAA,IAAI,MAAM,8EAA8E;AAClH,cAAQ,OAAO,QAAQ,QAAQ,CAAA,GAC/B,QAAQ,KAAK,UAAU,QAAQ,KAAK,WAAW,CAC/C,GAAA,UAAU,QAAQ,KAAK,SAAS,eAAe,KAAK;AAAA,IAAA;AAAA;AAExD;ACpDA,MAAM,cAAc,uEAGd,UAAU,oBAAI,IAAI,CAAC,OAAO,QAAQ,OAAO,SAAS,UAAU,QAAQ,SAAS,CAAC;AAWpE,SAAA,gBAAgB,SAAkC,OAAe,SAA6B;AACtG,QAAA,EAAE,QAAQ,YAAY,SAGtB,QAAQ,YAAY,KAAK,KAAK;AACpC,MAAI,CAAC,OAAO,OAAc,OAAA,IAAI,MAAM,iEAAiE;AAC/F,QAAA,cAAc,UAAU,MAAM,OAAO,UAAU,OAC/C,eAAe,WAAW,MAAM,OAAO;AAG7C,MAAI,CAAC,aAAoB,OAAA,IAAI,MAAM,uEAAuE;AAGpG,QAAA,cAAc,YAAY,YAAY;AAExC,MAAA,CADkB,QAAQ,IAAI,WAAW,SACnB,IAAI,MAAM,+DAA+D,WAAW,gBAAgB;AAG9H,UAAQ,OAAO,QAAQ,QAAQ,CAC/B,GAAA,QAAQ,KAAK,SAAS,aACtB,QAAQ,MAAM,IAAI,IAAI,YAAY,GAGlC,QAAQ,IAAI,YAAY,QAAQ,IAAI,SAAS,SAAS,GAAG,IAAI,MAAM,OAAO,KAAK,MAAM,CAAC,IAAI,MAAM,OAAO;AACzG;AC4EO,SAAS,aAAa,OAAe,UAAwB,IAAoB;AAChF,QAAA;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EAAA,IACD,SACE,UAAmC,EAAE,QACrC,aAAa,aAAa,IAAI,IAAI,OAAO;AAG/B,kBAAA,SAAS,OAAO,EAAE,SAAS,OAAQ,CAAA,GACnDE,kBAAAA,uBAAuB,SAAS,EAAE,YAAY,cAAc,WAAA,CAAY,GACxE,sBAAsB,SAAS,EAAE,UAAU,UAAU;AAGrD,QAAM,gBAAgB,QAAQ,MAAM,QAAQ,iBAAiB,OACvD,qBAAqB,CAAC,QAAQ,OAAO,OAAO,EAAE,SAAS,aAAa;AAC1E,SAAAC,kBAAAA,kBAAkB,SAAS,EAAE,kBAAkB,OAAO,qBAAqB,QAAQ,SAAS,WAAW,CAAC,GACxG,kBAAkB,SAAS,EAAE,OAAO,eAAe,cAAe,CAAA,GAClE,iBAAiB,SAAS,EAAE,MAAM,qBAAqB,QAAQ,aAAa,OAAW,CAAA,GACvF,oBAAoB,SAAS,EAAE,QAAA,CAAS,GAGjC;AACT;ACpJA,gBAAiB,iCAAiC,UAAoB,SAAiE;AACrI,QAAM,EAAE,SAAS,WAAW,QAAQ,MAAU,IAAA;AAC1C,MAAA;AACF,UAAM,OAAO,SAAS;AACtB,QAAI,SAAS,KAAY,OAAA,IAAI,MAAM,gDAAgD;AAC7E,UAAA,SAAS,KAAK,UAAU;AACjB,eAAA;AACX,YAAM,EAAE,MAAM,MAAU,IAAA,MAAM,OAAO,KAAK;AAC1C,UAAI,KAAM;AACV,YAAM,QAAQ,IAAI,YAAY,EAAE,OAAO,KAAK,EAAE,KAAA,EAAO,MAAM,IAAI,EAAE,OAAO,OAAO;AAG/E,iBAAW,QAAQ,OAAO;AAClB,cAAA,UAAU,KAAK,MAAM,IAAI;AAC3B,kBAAQ,OAAO,OAAO,GAC1B,MAAM;AAAA,MAAA;AAAA,IACR;AAEE,iBAAW,UAAU,QAAQ;AAAA,WAE5B,OAAO;AACR,eAAS,QAAQ,KAAc;AAAA,EAAA,UAErC;AACM,aAAO,MAAM,QAAQ;AAAA,EAAA;AAE7B;AAWgB,SAAA,yBAAyB,UAAoB,SAAuE;AAC5H,QAAA,mBAAmB,iCAAiC,UAAU,OAAO;AAC3E,SAAOC,UAAAA,UAAU,gBAAgB;AACnC;AChCA,eAAsB,eAAe,UAAoB,UAA0B,IAAsB;AACvG,QAAM,EAAE,SAAS,WAAW,QAAQ,OAAO,UAAA,IAAc,SACnD,cAAc,SAAS,QAAQ,IAAI,cAAc;AAGvD,MAAI,CAAC,SAAS;AACR,UAAA,aAAW,UAAU,QAAQ,GAC7B,SAAO,MAAM,QAAQ,GACnB,IAAI,MAAM,SAAS,UAAU;AAIjC,MAAA,SAAS,WAAW,KAAK;AACvB,iBAAW,UAAU,QAAQ,GAC7B,SAAO,MAAM,QAAQ;AACzB;AAAA,EAAA;AAIE,SAAA,aAAa,WAAW,OAAO,IAC1B,MAAM,SAAS,KACnB,EAAA,KAAK,CAAC,UACD,UAAQ,OAAO,IAAI,GACnB,aAAW,UAAU,QAAQ,GAC1B,KACR,EACA,MAAM,CAAC,UAAiB;AACnB,UAAA,WAAS,QAAQ,KAAK,GACpB;AAAA,EAAA,CACP,EACA,QAAQ,MAAM;AACT,aAAO,MAAM,QAAQ;AAAA,EAAA,CAC1B,IAID,gBAAgB,qBACX,MAAM,SAAS,OACnB,KAAK,CAAC,UACD,UAAQ,OAAO,IAAI,GACnB,aAAW,UAAU,QAAQ,GAC1B,KACR,EACA,MAAM,CAAC,UAAiB;AACnB,UAAA,WAAS,QAAQ,KAAK,GACpB;AAAA,EAAA,CACP,EACA,QAAQ,MAAM;AACT,aAAO,MAAM,QAAQ;AAAA,EAAA,CAC1B,IAID,gBAAgB,4BACX,yBAAyB,UAAU,OAAO,KAG/C,aAAW,UAAU,QAAQ,GAC7B,SAAO,MAAM,QAAQ,GAClB,SAAS;AAClB;;;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/chunks/B6pUErTM.js b/dist/chunks/B6pUErTM.js
new file mode 100644
index 0000000000000000000000000000000000000000..19f9960ab4241f2b93353d729e0e0423bf82153a
--- /dev/null
+++ b/dist/chunks/B6pUErTM.js
@@ -0,0 +1,46 @@
+const EXP_PATH_PARAMETER = /:([\w-]+)|%7B([\w-]+)%7D/g;
+function parseRequestParameters(context, options) {
+  const { url } = context, { parameters } = options;
+  if (parameters === void 0 || typeof parameters != "object" || parameters === null || url === void 0) return;
+  if (!(url instanceof URL)) throw new Error("The `url` must be an instance of `URL`.");
+  const pathParameters = url.pathname.match(EXP_PATH_PARAMETER);
+  if (pathParameters)
+    for (const parameter of pathParameters.values()) {
+      const key = parameter.replaceAll(EXP_PATH_PARAMETER, "$1$2"), value = parameters[key];
+      (typeof value == "string" && value.length > 0 || typeof value == "number" && Number.isFinite(value) || typeof value == "boolean") && (url.pathname = url.pathname.replace(parameter, value.toString()), delete parameters[key]);
+    }
+}
+function toSearchParams(object, options = {}) {
+  const { format = "flat" } = options, search = new URLSearchParams();
+  for (const key in object) {
+    const value = object[key];
+    if (value !== void 0)
+      if (Array.isArray(value)) {
+        if (format === "brackets") for (const v of value) search.append(`${key}[]`, String(v));
+        else if (format === "indices") for (const [i, v] of value.entries()) search.append(`${key}[${i}]`, String(v));
+        else if (format === "comma") search.append(key, value.join(","));
+        else if (format === "path") for (const [i, v] of value.entries()) search.append(`${key}.${i}`, String(v));
+        else if (format === "flat") for (const v of value) search.append(key, String(v));
+      } else
+        search.append(key, value.toString());
+  }
+  return search;
+}
+function parseRequestQuery(context, options) {
+  const { url } = context, { query, queryArrayFormat } = options;
+  if (url === void 0) return;
+  if (!(url instanceof URL)) throw new Error("The `url` must be an instance of `URL.");
+  if (typeof query != "object" || query === null) return;
+  const queryObject = {};
+  for (const key in query) {
+    const value = query[key];
+    (typeof value == "string" && value.length > 0 || typeof value == "number" && Number.isFinite(value) || typeof value == "boolean" || Array.isArray(value) && value.length > 0 && value.every((v) => typeof v == "string" || typeof v == "number" || typeof v == "boolean")) && (queryObject[key] = value, delete query[key]);
+  }
+  url.search = toSearchParams(queryObject, { format: queryArrayFormat }).toString();
+}
+export {
+  parseRequestQuery as a,
+  parseRequestParameters as p,
+  toSearchParams as t
+};
+//# sourceMappingURL=B6pUErTM.js.map
diff --git a/dist/chunks/B6pUErTM.js.map b/dist/chunks/B6pUErTM.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..118dec9981b1567389e6ec5b7783371d620a11d0
--- /dev/null
+++ b/dist/chunks/B6pUErTM.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"B6pUErTM.js","sources":["../../utils/parseRequestParameters.ts","../../utils/toSearchParams.ts","../../utils/parseRequestQuery.ts"],"sourcesContent":["import type { FetchOptions, RequestContext } from './parseRequest'\n\n/** Regular expression to match path parameters in the URL. */\nconst EXP_PATH_PARAMETER = /:([\\w-]+)|%7B([\\w-]+)%7D/g\n\n/**\n * Parse the request parameters from the request data. This function will mutate the\n * `url` object of the context to include the path parameters based on the provided data.\n *\n * @param context The request context to mutate.\n * @param options The options to pass to the request.\n * @example\n *\n * // Using `express` style path parameters.\n * const context = { url: new URL('https://api.example.com/users/:id') }\n * parseRequestParameters(context, { parameters: { id: 1 } })\n * console.log(context.url.pathname) // 'https://api.example.com/users/1'\n *\n * // Using `OpenAPI` style path parameters.\n * const context = { url: new URL('https://api.example.com/users/{id}') }\n * parseRequestParameters(context, { parameters: { id: 1 } })\n * console.log(context.url.pathname) // 'https://api.example.com/users/1'\n */\nexport function parseRequestParameters(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { url } = context\n  const { parameters } = options\n\n  // --- Return early if the parameters is not an object.\n  if (parameters === undefined || typeof parameters !== 'object' || parameters === null || url === undefined) return\n  if (url instanceof URL === false) throw new Error('The `url` must be an instance of `URL`.')\n\n  // --- If the method has a parameter, fill the path with the data.\n  const pathParameters = url.pathname.match(EXP_PATH_PARAMETER)\n  if (!pathParameters) return\n\n  // --- Apply the path parameters to the URL.\n  for (const parameter of pathParameters.values()) {\n    const key = parameter.replaceAll(EXP_PATH_PARAMETER, '$1$2')\n    const value = parameters[key]\n\n    // --- If the parameter is provided, replace the path with the value.\n    if (\n      (typeof value === 'string' && value.length > 0)\n      || (typeof value === 'number' && Number.isFinite(value))\n      || (typeof value === 'boolean')\n    ) {\n      url.pathname = url.pathname.replace(parameter, value.toString())\n      delete parameters[key]\n    }\n  }\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport type { MaybeArray } from '@unshared/types'\n\n/** An object that can be converted to a query string. */\nexport type SearchParamsObject = Record<string, MaybeArray<boolean | number | string> | undefined>\n\n/** The search array format options. */\nexport type SearchArrayFormat = 'brackets' | 'comma' | 'flat' | 'indices' | 'path'\n\n/** Options for the query string conversion. */\nexport interface ToSearchParamsOptions {\n\n  /**\n   * Defines how to handle arrays in the object. There is no standard way to\n   * represent arrays in query strings, so this option allows you to choose\n   * how to handle them. Additionally, you can provide a custom function to\n   * handle it yourself.\n   *\n   * - `brackets` (default): Convert arrays to `key[]=value&key[]=value` format.\n   * - `indices`: Convert arrays to `key[0]=value&key[1]=value` format.\n   * - `comma`: Convert arrays to `key=value1,value2` format.\n   * - `path`: Convert arrays to `key.0=value&key.1=value` format.\n   * - `flat`: Convert arrays to `key=value1&key=value2` format.\n   *\n   * @default 'flat'\n   */\n  format?: SearchArrayFormat\n}\n\n/**\n * Convert object to query string parameters. Converting all values to strings\n * and arrays to `key[0]=value&key[1]=value` format.\n *\n * @param object The object to convert to a query string.\n * @param options The query string options.\n * @returns The `URLSearchParams` object.\n */\nexport function toSearchParams(object: SearchParamsObject, options: ToSearchParamsOptions = {}): URLSearchParams {\n  const { format = 'flat' } = options\n  const search = new URLSearchParams()\n  for (const key in object) {\n    const value = object[key]\n    if (value === undefined) continue\n\n    // --- Convert arrays based on the format.\n    if (Array.isArray(value)) {\n      if (format === 'brackets') for (const v of value) search.append(`${key}[]`, String(v))\n      else if (format === 'indices') for (const [i, v] of value.entries()) search.append(`${key}[${i}]`, String(v))\n      else if (format === 'comma') search.append(key, value.join(','))\n      else if (format === 'path') for (const [i, v] of value.entries()) search.append(`${key}.${i}`, String(v))\n      else if (format === 'flat') for (const v of value) search.append(key, String(v))\n    }\n\n    // --- Convert all values to strings.\n    else { search.append(key, value.toString()) }\n  }\n\n  // --- Return the query string.\n  return search\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport type { FetchOptions, RequestContext } from './parseRequest'\nimport type { SearchParamsObject as SearchParametersObject } from './toSearchParams'\nimport { toSearchParams } from './toSearchParams'\n\n/**\n * Parse the query parameters from the request data. This function will append\n * the query parameters to the URL based on the method and the data provided.\n *\n * @param context The request context to modify.\n * @param options The options to pass to the request.\n */\nexport function parseRequestQuery(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { url } = context\n  const { query, queryArrayFormat } = options\n\n  // --- Return early if the query is not an object or the URL is not provided.\n  if (url === undefined) return\n  if (url instanceof URL === false) throw new Error('The `url` must be an instance of `URL.')\n  if (typeof query !== 'object' || query === null) return\n\n  // --- Append the `data` to the query parameters if the method does not expect a body.\n  const queryObject: SearchParametersObject = {}\n  for (const key in query) {\n    const value = query[key]\n    if (\n      (typeof value === 'string' && value.length > 0)\n      || (typeof value === 'number' && Number.isFinite(value))\n      || (typeof value === 'boolean')\n      || Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean')\n    ) {\n      queryObject[key] = value\n      delete query[key]\n    }\n  }\n\n  // --- Apply the query parameters to the URL.\n  url.search = toSearchParams(queryObject, { format: queryArrayFormat }).toString()\n}\n"],"names":[],"mappings":"AAGA,MAAM,qBAAqB;AAoBX,SAAA,uBAAuB,SAAkC,SAA6B;AACpG,QAAM,EAAE,IAAI,IAAI,SACV,EAAE,WAAe,IAAA;AAGnB,MAAA,eAAe,UAAa,OAAO,cAAe,YAAY,eAAe,QAAQ,QAAQ,OAAW;AAC5G,MAAI,EAAe,eAAA,KAAqB,OAAA,IAAI,MAAM,yCAAyC;AAG3F,QAAM,iBAAiB,IAAI,SAAS,MAAM,kBAAkB;AACvD,MAAA;AAGM,eAAA,aAAa,eAAe,UAAU;AACzC,YAAA,MAAM,UAAU,WAAW,oBAAoB,MAAM,GACrD,QAAQ,WAAW,GAAG;AAG5B,OACG,OAAO,SAAU,YAAY,MAAM,SAAS,KACzC,OAAO,SAAU,YAAY,OAAO,SAAS,KAAK,KAClD,OAAO,SAAU,eAErB,IAAI,WAAW,IAAI,SAAS,QAAQ,WAAW,MAAM,SAAA,CAAU,GAC/D,OAAO,WAAW,GAAG;AAAA,IAAA;AAG3B;ACbO,SAAS,eAAe,QAA4B,UAAiC,IAAqB;AAC/G,QAAM,EAAE,SAAS,OAAA,IAAW,SACtB,SAAS,IAAI,gBAAgB;AACnC,aAAW,OAAO,QAAQ;AAClB,UAAA,QAAQ,OAAO,GAAG;AACxB,QAAI,UAAU;AAGV,UAAA,MAAM,QAAQ,KAAK;AACrB,YAAI,WAAW,WAAuB,YAAA,KAAK,MAAO,QAAO,OAAO,GAAG,GAAG,MAAM,OAAO,CAAC,CAAC;AAAA,iBAC5E,WAAW,UAAW,YAAW,CAAC,GAAG,CAAC,KAAK,MAAM,UAAkB,QAAA,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;AAAA,iBACnG,WAAW,QAAgB,QAAA,OAAO,KAAK,MAAM,KAAK,GAAG,CAAC;AAAA,iBACtD,WAAW,OAAQ,YAAW,CAAC,GAAG,CAAC,KAAK,MAAM,UAAkB,QAAA,OAAO,GAAG,GAAG,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,iBAC/F,WAAW,OAAQ,YAAW,KAAK,cAAc,OAAO,KAAK,OAAO,CAAC,CAAC;AAAA;AAI1E,eAAO,OAAO,KAAK,MAAM,SAAA,CAAU;AAAA,EAAA;AAIrC,SAAA;AACT;AC/CgB,SAAA,kBAAkB,SAAkC,SAA6B;AAC/F,QAAM,EAAE,IAAI,IAAI,SACV,EAAE,OAAO,qBAAqB;AAGpC,MAAI,QAAQ,OAAW;AACvB,MAAI,EAAe,eAAA,KAAqB,OAAA,IAAI,MAAM,wCAAwC;AAC1F,MAAI,OAAO,SAAU,YAAY,UAAU,KAAM;AAGjD,QAAM,cAAsC,CAAC;AAC7C,aAAW,OAAO,OAAO;AACjB,UAAA,QAAQ,MAAM,GAAG;AACvB,KACG,OAAO,SAAU,YAAY,MAAM,SAAS,KACzC,OAAO,SAAU,YAAY,OAAO,SAAS,KAAK,KAClD,OAAO,SAAU,aAClB,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,KAAK,MAAM,MAAM,CAAA,MAAK,OAAO,KAAM,YAAY,OAAO,KAAM,YAAY,OAAO,KAAM,SAAS,OAExI,YAAY,GAAG,IAAI,OACnB,OAAO,MAAM,GAAG;AAAA,EAAA;AAKhB,MAAA,SAAS,eAAe,aAAa,EAAE,QAAQ,iBAAiB,CAAC,EAAE,SAAS;AAClF;"}
\ No newline at end of file
diff --git a/dist/chunks/BDxlAULu.cjs b/dist/chunks/BDxlAULu.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..1065b525d001301ce33fc6f033768cee06e07910
--- /dev/null
+++ b/dist/chunks/BDxlAULu.cjs
@@ -0,0 +1,45 @@
+"use strict";
+const EXP_PATH_PARAMETER = /:([\w-]+)|%7B([\w-]+)%7D/g;
+function parseRequestParameters(context, options) {
+  const { url } = context, { parameters } = options;
+  if (parameters === void 0 || typeof parameters != "object" || parameters === null || url === void 0) return;
+  if (!(url instanceof URL)) throw new Error("The `url` must be an instance of `URL`.");
+  const pathParameters = url.pathname.match(EXP_PATH_PARAMETER);
+  if (pathParameters)
+    for (const parameter of pathParameters.values()) {
+      const key = parameter.replaceAll(EXP_PATH_PARAMETER, "$1$2"), value = parameters[key];
+      (typeof value == "string" && value.length > 0 || typeof value == "number" && Number.isFinite(value) || typeof value == "boolean") && (url.pathname = url.pathname.replace(parameter, value.toString()), delete parameters[key]);
+    }
+}
+function toSearchParams(object, options = {}) {
+  const { format = "flat" } = options, search = new URLSearchParams();
+  for (const key in object) {
+    const value = object[key];
+    if (value !== void 0)
+      if (Array.isArray(value)) {
+        if (format === "brackets") for (const v of value) search.append(`${key}[]`, String(v));
+        else if (format === "indices") for (const [i, v] of value.entries()) search.append(`${key}[${i}]`, String(v));
+        else if (format === "comma") search.append(key, value.join(","));
+        else if (format === "path") for (const [i, v] of value.entries()) search.append(`${key}.${i}`, String(v));
+        else if (format === "flat") for (const v of value) search.append(key, String(v));
+      } else
+        search.append(key, value.toString());
+  }
+  return search;
+}
+function parseRequestQuery(context, options) {
+  const { url } = context, { query, queryArrayFormat } = options;
+  if (url === void 0) return;
+  if (!(url instanceof URL)) throw new Error("The `url` must be an instance of `URL.");
+  if (typeof query != "object" || query === null) return;
+  const queryObject = {};
+  for (const key in query) {
+    const value = query[key];
+    (typeof value == "string" && value.length > 0 || typeof value == "number" && Number.isFinite(value) || typeof value == "boolean" || Array.isArray(value) && value.length > 0 && value.every((v) => typeof v == "string" || typeof v == "number" || typeof v == "boolean")) && (queryObject[key] = value, delete query[key]);
+  }
+  url.search = toSearchParams(queryObject, { format: queryArrayFormat }).toString();
+}
+exports.parseRequestParameters = parseRequestParameters;
+exports.parseRequestQuery = parseRequestQuery;
+exports.toSearchParams = toSearchParams;
+//# sourceMappingURL=BDxlAULu.cjs.map
diff --git a/dist/chunks/BDxlAULu.cjs.map b/dist/chunks/BDxlAULu.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..72c534f8342d38753ed5855a33c15fe30ad38435
--- /dev/null
+++ b/dist/chunks/BDxlAULu.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"BDxlAULu.cjs","sources":["../../utils/parseRequestParameters.ts","../../utils/toSearchParams.ts","../../utils/parseRequestQuery.ts"],"sourcesContent":["import type { FetchOptions, RequestContext } from './parseRequest'\n\n/** Regular expression to match path parameters in the URL. */\nconst EXP_PATH_PARAMETER = /:([\\w-]+)|%7B([\\w-]+)%7D/g\n\n/**\n * Parse the request parameters from the request data. This function will mutate the\n * `url` object of the context to include the path parameters based on the provided data.\n *\n * @param context The request context to mutate.\n * @param options The options to pass to the request.\n * @example\n *\n * // Using `express` style path parameters.\n * const context = { url: new URL('https://api.example.com/users/:id') }\n * parseRequestParameters(context, { parameters: { id: 1 } })\n * console.log(context.url.pathname) // 'https://api.example.com/users/1'\n *\n * // Using `OpenAPI` style path parameters.\n * const context = { url: new URL('https://api.example.com/users/{id}') }\n * parseRequestParameters(context, { parameters: { id: 1 } })\n * console.log(context.url.pathname) // 'https://api.example.com/users/1'\n */\nexport function parseRequestParameters(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { url } = context\n  const { parameters } = options\n\n  // --- Return early if the parameters is not an object.\n  if (parameters === undefined || typeof parameters !== 'object' || parameters === null || url === undefined) return\n  if (url instanceof URL === false) throw new Error('The `url` must be an instance of `URL`.')\n\n  // --- If the method has a parameter, fill the path with the data.\n  const pathParameters = url.pathname.match(EXP_PATH_PARAMETER)\n  if (!pathParameters) return\n\n  // --- Apply the path parameters to the URL.\n  for (const parameter of pathParameters.values()) {\n    const key = parameter.replaceAll(EXP_PATH_PARAMETER, '$1$2')\n    const value = parameters[key]\n\n    // --- If the parameter is provided, replace the path with the value.\n    if (\n      (typeof value === 'string' && value.length > 0)\n      || (typeof value === 'number' && Number.isFinite(value))\n      || (typeof value === 'boolean')\n    ) {\n      url.pathname = url.pathname.replace(parameter, value.toString())\n      delete parameters[key]\n    }\n  }\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport type { MaybeArray } from '@unshared/types'\n\n/** An object that can be converted to a query string. */\nexport type SearchParamsObject = Record<string, MaybeArray<boolean | number | string> | undefined>\n\n/** The search array format options. */\nexport type SearchArrayFormat = 'brackets' | 'comma' | 'flat' | 'indices' | 'path'\n\n/** Options for the query string conversion. */\nexport interface ToSearchParamsOptions {\n\n  /**\n   * Defines how to handle arrays in the object. There is no standard way to\n   * represent arrays in query strings, so this option allows you to choose\n   * how to handle them. Additionally, you can provide a custom function to\n   * handle it yourself.\n   *\n   * - `brackets` (default): Convert arrays to `key[]=value&key[]=value` format.\n   * - `indices`: Convert arrays to `key[0]=value&key[1]=value` format.\n   * - `comma`: Convert arrays to `key=value1,value2` format.\n   * - `path`: Convert arrays to `key.0=value&key.1=value` format.\n   * - `flat`: Convert arrays to `key=value1&key=value2` format.\n   *\n   * @default 'flat'\n   */\n  format?: SearchArrayFormat\n}\n\n/**\n * Convert object to query string parameters. Converting all values to strings\n * and arrays to `key[0]=value&key[1]=value` format.\n *\n * @param object The object to convert to a query string.\n * @param options The query string options.\n * @returns The `URLSearchParams` object.\n */\nexport function toSearchParams(object: SearchParamsObject, options: ToSearchParamsOptions = {}): URLSearchParams {\n  const { format = 'flat' } = options\n  const search = new URLSearchParams()\n  for (const key in object) {\n    const value = object[key]\n    if (value === undefined) continue\n\n    // --- Convert arrays based on the format.\n    if (Array.isArray(value)) {\n      if (format === 'brackets') for (const v of value) search.append(`${key}[]`, String(v))\n      else if (format === 'indices') for (const [i, v] of value.entries()) search.append(`${key}[${i}]`, String(v))\n      else if (format === 'comma') search.append(key, value.join(','))\n      else if (format === 'path') for (const [i, v] of value.entries()) search.append(`${key}.${i}`, String(v))\n      else if (format === 'flat') for (const v of value) search.append(key, String(v))\n    }\n\n    // --- Convert all values to strings.\n    else { search.append(key, value.toString()) }\n  }\n\n  // --- Return the query string.\n  return search\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport type { FetchOptions, RequestContext } from './parseRequest'\nimport type { SearchParamsObject as SearchParametersObject } from './toSearchParams'\nimport { toSearchParams } from './toSearchParams'\n\n/**\n * Parse the query parameters from the request data. This function will append\n * the query parameters to the URL based on the method and the data provided.\n *\n * @param context The request context to modify.\n * @param options The options to pass to the request.\n */\nexport function parseRequestQuery(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { url } = context\n  const { query, queryArrayFormat } = options\n\n  // --- Return early if the query is not an object or the URL is not provided.\n  if (url === undefined) return\n  if (url instanceof URL === false) throw new Error('The `url` must be an instance of `URL.')\n  if (typeof query !== 'object' || query === null) return\n\n  // --- Append the `data` to the query parameters if the method does not expect a body.\n  const queryObject: SearchParametersObject = {}\n  for (const key in query) {\n    const value = query[key]\n    if (\n      (typeof value === 'string' && value.length > 0)\n      || (typeof value === 'number' && Number.isFinite(value))\n      || (typeof value === 'boolean')\n      || Array.isArray(value) && value.length > 0 && value.every(v => typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean')\n    ) {\n      queryObject[key] = value\n      delete query[key]\n    }\n  }\n\n  // --- Apply the query parameters to the URL.\n  url.search = toSearchParams(queryObject, { format: queryArrayFormat }).toString()\n}\n"],"names":[],"mappings":";AAGA,MAAM,qBAAqB;AAoBX,SAAA,uBAAuB,SAAkC,SAA6B;AACpG,QAAM,EAAE,IAAI,IAAI,SACV,EAAE,WAAe,IAAA;AAGnB,MAAA,eAAe,UAAa,OAAO,cAAe,YAAY,eAAe,QAAQ,QAAQ,OAAW;AAC5G,MAAI,EAAe,eAAA,KAAqB,OAAA,IAAI,MAAM,yCAAyC;AAG3F,QAAM,iBAAiB,IAAI,SAAS,MAAM,kBAAkB;AACvD,MAAA;AAGM,eAAA,aAAa,eAAe,UAAU;AACzC,YAAA,MAAM,UAAU,WAAW,oBAAoB,MAAM,GACrD,QAAQ,WAAW,GAAG;AAG5B,OACG,OAAO,SAAU,YAAY,MAAM,SAAS,KACzC,OAAO,SAAU,YAAY,OAAO,SAAS,KAAK,KAClD,OAAO,SAAU,eAErB,IAAI,WAAW,IAAI,SAAS,QAAQ,WAAW,MAAM,SAAA,CAAU,GAC/D,OAAO,WAAW,GAAG;AAAA,IAAA;AAG3B;ACbO,SAAS,eAAe,QAA4B,UAAiC,IAAqB;AAC/G,QAAM,EAAE,SAAS,OAAA,IAAW,SACtB,SAAS,IAAI,gBAAgB;AACnC,aAAW,OAAO,QAAQ;AAClB,UAAA,QAAQ,OAAO,GAAG;AACxB,QAAI,UAAU;AAGV,UAAA,MAAM,QAAQ,KAAK;AACrB,YAAI,WAAW,WAAuB,YAAA,KAAK,MAAO,QAAO,OAAO,GAAG,GAAG,MAAM,OAAO,CAAC,CAAC;AAAA,iBAC5E,WAAW,UAAW,YAAW,CAAC,GAAG,CAAC,KAAK,MAAM,UAAkB,QAAA,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;AAAA,iBACnG,WAAW,QAAgB,QAAA,OAAO,KAAK,MAAM,KAAK,GAAG,CAAC;AAAA,iBACtD,WAAW,OAAQ,YAAW,CAAC,GAAG,CAAC,KAAK,MAAM,UAAkB,QAAA,OAAO,GAAG,GAAG,IAAI,CAAC,IAAI,OAAO,CAAC,CAAC;AAAA,iBAC/F,WAAW,OAAQ,YAAW,KAAK,cAAc,OAAO,KAAK,OAAO,CAAC,CAAC;AAAA;AAI1E,eAAO,OAAO,KAAK,MAAM,SAAA,CAAU;AAAA,EAAA;AAIrC,SAAA;AACT;AC/CgB,SAAA,kBAAkB,SAAkC,SAA6B;AAC/F,QAAM,EAAE,IAAI,IAAI,SACV,EAAE,OAAO,qBAAqB;AAGpC,MAAI,QAAQ,OAAW;AACvB,MAAI,EAAe,eAAA,KAAqB,OAAA,IAAI,MAAM,wCAAwC;AAC1F,MAAI,OAAO,SAAU,YAAY,UAAU,KAAM;AAGjD,QAAM,cAAsC,CAAC;AAC7C,aAAW,OAAO,OAAO;AACjB,UAAA,QAAQ,MAAM,GAAG;AACvB,KACG,OAAO,SAAU,YAAY,MAAM,SAAS,KACzC,OAAO,SAAU,YAAY,OAAO,SAAS,KAAK,KAClD,OAAO,SAAU,aAClB,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,KAAK,MAAM,MAAM,CAAA,MAAK,OAAO,KAAM,YAAY,OAAO,KAAM,YAAY,OAAO,KAAM,SAAS,OAExI,YAAY,GAAG,IAAI,OACnB,OAAO,MAAM,GAAG;AAAA,EAAA;AAKhB,MAAA,SAAS,eAAe,aAAa,EAAE,QAAQ,iBAAiB,CAAC,EAAE,SAAS;AAClF;;;;"}
\ No newline at end of file
diff --git a/dist/chunks/BZ5qrH6f.d.ts b/dist/chunks/BZ5qrH6f.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d8c4615974741b5e0d4313b82c99093f6a1137fa
--- /dev/null
+++ b/dist/chunks/BZ5qrH6f.d.ts
@@ -0,0 +1,164 @@
+import { MaybeArray, MaybeLiteral, ObjectLike, Loose, UnionMerge } from '@unshared/types';
+import { HttpHeader } from '../HttpHeaders.js';
+import { HttpMethod } from '../HttpMethods.js';
+
+/** An object that can be converted to a query string. */
+type SearchParamsObject = Record<string, MaybeArray<boolean | number | string> | undefined>;
+/** The search array format options. */
+type SearchArrayFormat = 'brackets' | 'comma' | 'flat' | 'indices' | 'path';
+/** Options for the query string conversion. */
+interface ToSearchParamsOptions {
+    /**
+     * Defines how to handle arrays in the object. There is no standard way to
+     * represent arrays in query strings, so this option allows you to choose
+     * how to handle them. Additionally, you can provide a custom function to
+     * handle it yourself.
+     *
+     * - `brackets` (default): Convert arrays to `key[]=value&key[]=value` format.
+     * - `indices`: Convert arrays to `key[0]=value&key[1]=value` format.
+     * - `comma`: Convert arrays to `key=value1,value2` format.
+     * - `path`: Convert arrays to `key.0=value&key.1=value` format.
+     * - `flat`: Convert arrays to `key=value1&key=value2` format.
+     *
+     * @default 'flat'
+     */
+    format?: SearchArrayFormat;
+}
+/**
+ * Convert object to query string parameters. Converting all values to strings
+ * and arrays to `key[0]=value&key[1]=value` format.
+ *
+ * @param object The object to convert to a query string.
+ * @param options The query string options.
+ * @returns The `URLSearchParams` object.
+ */
+declare function toSearchParams(object: SearchParamsObject, options?: ToSearchParamsOptions): URLSearchParams;
+
+/** The methods to use for the request. */
+type FetchMethod = Lowercase<keyof typeof HttpMethod> | Uppercase<keyof typeof HttpMethod>;
+/** Headers to include in the request. */
+type FetchHeaders = Partial<Record<MaybeLiteral<HttpHeader>, number | string>>;
+/** Options to pass to the request. */
+interface FetchOptions<Method extends FetchMethod = FetchMethod, BaseUrl extends string = string, Parameters extends ObjectLike = ObjectLike, Query extends ObjectLike = ObjectLike, Body = unknown, Headers extends ObjectLike = ObjectLike> extends Omit<RequestInit, 'body' | 'headers' | 'method'> {
+    /**
+     * The method to use for the request.
+     *
+     * @example 'GET'
+     */
+    method?: Method;
+    /**
+     * The base URL to use for the request. This URL will be used to resolve the
+     * path and query parameters of the request.
+     *
+     * @example 'https://api.example.com'
+     */
+    baseUrl?: BaseUrl;
+    /**
+     * The data to include in the request. This data will be used to populate the
+     * query parameters, body, and headers of the request based on the method type.
+     *
+     * @example { id: 1 }
+     */
+    data?: Loose<UnionMerge<Body | Headers | Query>>;
+    /**
+     * The path parameters to include in the request.
+     */
+    parameters?: Parameters;
+    /**
+     * The query parameters to include in the request.
+     */
+    query?: Loose<Query>;
+    /**
+     * The format to use when serializing the query parameters.
+     */
+    queryArrayFormat?: SearchArrayFormat;
+    /**
+     * The body to include in the request.
+     */
+    body?: Body extends ObjectLike ? Loose<Body> : Body;
+    /**
+     * The headers to include in the request.
+     */
+    headers?: FetchHeaders & Headers;
+    /**
+     * The username for basic authentication.
+     */
+    username?: string;
+    /**
+     * The password for basic authentication.
+     */
+    password?: string;
+    /**
+     * The token for API key authentication.
+     */
+    token?: string;
+    /**
+     * The location where the token should be included in the request.
+     */
+    tokenLocation?: 'cookie' | 'header' | 'query';
+    /**
+     * The name of the key to use in the request for the token.
+     */
+    tokenProperty?: string;
+}
+interface RequestContext {
+    url: URL;
+    init: RequestInit;
+}
+/**
+ * Resolves the request body and/or query parameters based on the method type. This function
+ * will mutate the `init` object to include the request body and headers based on the data type.
+ *
+ * @param route The name of the route to fetch.
+ * @param options The options to pass to the request.
+ * @returns The URL and the `RequestInit` object.
+ */
+declare function parseRequest(route: string, options?: FetchOptions): RequestContext;
+
+interface RequestOptions<Method extends FetchMethod = FetchMethod, BaseUrl extends string = string, Parameters extends ObjectLike = ObjectLike, Query extends ObjectLike = ObjectLike, Body = unknown, Headers extends ObjectLike = ObjectLike, Data = any, Response = globalThis.Response> extends FetchOptions<Method, BaseUrl, Parameters, Query, Body, Headers> {
+    /**
+     * The callback that is called when an error occurs during the request.
+     */
+    onError?: (error: Error) => any;
+    /**
+     * The callback that is called when data is received from the request. This callback
+     * will be called for each chunk of data that is received from the request.
+     */
+    onData?: (data: Data) => any;
+    /**
+     * The callback that is called when the request is successful. This callback will be
+     * called after the request is complete and all data has been received.
+     */
+    onSuccess?: (response: Response) => any;
+    /**
+     * The callback that is called when the status code is not OK. This callback will be called
+     * after the request is complete and before the data is consumed.
+     */
+    onFailure?: (response: Response) => any;
+    /**
+     * The callback that is called when the request is complete. This callback will be called
+     * after the request is complete and all data has been received.
+     */
+    onEnd?: (response: Response) => any;
+}
+/**
+ * Fetch a route from the API and return the data. If the client was instantiated with an
+ * application, the route name will be inferred from the application routes. Otherwise, you
+ * can pass the route name as a string.
+ *
+ * @param route The name of the route to fetch.
+ * @param options The options to pass to the request.
+ * @returns The data from the API.
+ * @example
+ * // Declare the application type.
+ * type App = Application<[ModuleProduct]>
+ *
+ * // Create a type-safe client for the application.
+ * const request = createClient<App>()
+ *
+ * // Fetch the data from the API.
+ * const data = request('GET /api/product/:id', { data: { id: '1' } })
+ */
+declare function request(route: string, options?: RequestOptions): Promise<unknown>;
+
+export { type FetchMethod as F, type RequestOptions as R, type SearchParamsObject as S, type ToSearchParamsOptions as T, type FetchOptions as a, type RequestContext as b, type FetchHeaders as c, type SearchArrayFormat as d, parseRequest as p, request as r, toSearchParams as t };
diff --git a/dist/chunks/B_Gz6Yz8.js b/dist/chunks/B_Gz6Yz8.js
new file mode 100644
index 0000000000000000000000000000000000000000..1d9f2b10e0fdd3e945e583a69a78c6052e599d16
--- /dev/null
+++ b/dist/chunks/B_Gz6Yz8.js
@@ -0,0 +1,54 @@
+function getServerUrl(specification) {
+  if (!specification || typeof specification != "object" || specification === null)
+    throw new Error("Invalid OpenAPI specification.");
+  if ("servers" in specification && Array.isArray(specification.servers) && specification.servers.length > 0 && "url" in specification.servers[0] && typeof specification.servers[0].url == "string" && specification.servers[0].url.length > 0)
+    return specification.servers[0].url;
+  if ("host" in specification && typeof specification.host == "string") {
+    const scheme = "schemes" in specification && Array.isArray(specification.schemes) && specification.schemes.length > 0 && typeof specification.schemes[0] == "string" ? specification.schemes[0] : "https", basePath = "basePath" in specification && typeof specification.basePath == "string" && specification.basePath.length > 0 ? specification.basePath : "/";
+    return `${scheme}://${specification.host}${basePath}`;
+  }
+  throw new Error("No base URL found in the OpenAPI specification.");
+}
+const methods = ["get", "put", "post", "delete", "options", "head", "patch"];
+function resolveOperation(document, operationId) {
+  if (!document || typeof document != "object" || document === null || !("paths" in document) || typeof document.paths != "object" || document.paths === null)
+    throw new Error("Missing paths object in the OpenAPI specification.");
+  const paths = document.paths;
+  for (const path in paths) {
+    const route = paths[path];
+    if (!(typeof route != "object" || route === null))
+      for (const method of methods) {
+        const operation = route[method];
+        if (!(!(method in route) || typeof operation != "object" || operation === null || !("operationId" in operation) || operation.operationId !== operationId))
+          return { ...route[method], method, path };
+      }
+  }
+  throw new Error(`Operation "${operationId}" not found in specification.`);
+}
+function isOpenAPIV3(value) {
+  return typeof value == "object" && value !== null && "openapi" in value && value.openapi === "3.0.0";
+}
+function resolveOperationTokenOptions(document, operation) {
+  if (!isOpenAPIV3(document)) return {};
+  const security = operation.security ?? document.security;
+  if (!security) return {};
+  const securityScheme = document?.components?.securitySchemes;
+  if (!securityScheme) return {};
+  for (const requirement of security)
+    for (const key in requirement) {
+      const scheme = securityScheme[key];
+      if (!(typeof scheme != "object" || scheme === null) && scheme.type === "apiKey")
+        return {
+          tokenLocation: scheme.in,
+          tokenProperty: scheme.name
+        };
+    }
+  return {};
+}
+export {
+  resolveOperationTokenOptions as a,
+  getServerUrl as g,
+  isOpenAPIV3 as i,
+  resolveOperation as r
+};
+//# sourceMappingURL=B_Gz6Yz8.js.map
diff --git a/dist/chunks/B_Gz6Yz8.js.map b/dist/chunks/B_Gz6Yz8.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..7efd324a37cf6429415004d1c51dc975e87d1ed8
--- /dev/null
+++ b/dist/chunks/B_Gz6Yz8.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"B_Gz6Yz8.js","sources":["../../openapi/getServerUrl.ts","../../openapi/resolveOperation.ts","../../openapi/isOpenAPIV3.ts","../../openapi/resolveOperationTokenOptions.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Get the base URL of an OpenAPI specification. */\nexport type ServerUrl<T> =\n\n  // --- Handle OpenAPI 2.0 specifications.\n  T extends {\n    host: infer Host extends string\n    basePath?: infer BasePath extends string\n    schemes?: Array<infer Scheme extends string>\n  }\n    ? `${Scheme}://${Host}${BasePath}`\n\n    // --- Handle OpenAPI 3.0 specifications.\n    : T extends { servers: Array<{ url: infer U extends string }> }\n      ? U\n      : string\n\n/**\n * Given an OpenAPI specification, get the first base URL.\n *\n * @param specification The OpenAPI specification.\n * @returns The first base URL.\n * @example getBaseUrl(specification) // 'https://api.example.com/v1'\n */\nexport function getServerUrl<T>(specification: T): ServerUrl<T> {\n\n  // --- Ensure the specification is an object.\n  if (\n    !specification\n    || typeof specification !== 'object'\n    || specification === null)\n    throw new Error('Invalid OpenAPI specification.')\n\n  // --- Handle OpenAPI 3.0 specifications.\n  if (\n    'servers' in specification\n    && Array.isArray(specification.servers)\n    && specification.servers.length > 0\n    && 'url' in specification.servers[0]\n    && typeof specification.servers[0].url === 'string'\n    && specification.servers[0].url.length > 0)\n    return specification.servers[0].url as ServerUrl<T>\n\n  // --- Handle OpenAPI 2.0 specifications.\n  if (\n    'host' in specification\n    && typeof specification.host === 'string') {\n\n    const scheme = (\n      'schemes' in specification\n      && Array.isArray(specification.schemes)\n      && specification.schemes.length > 0\n      && typeof specification.schemes[0] === 'string')\n      ? specification.schemes[0]\n      : 'https'\n\n    const basePath = (\n      'basePath' in specification\n      && typeof specification.basePath === 'string'\n      && specification.basePath.length > 0)\n      ? specification.basePath\n      : '/'\n\n    return `${scheme}://${specification.host}${basePath}` as ServerUrl<T>\n  }\n\n  throw new Error('No base URL found in the OpenAPI specification.')\n}\n","import type { CollectKey, Pretty } from '@unshared/types'\nimport type { OpenAPI } from 'openapi-types'\nimport type { FetchMethod } from '../utils/parseRequest'\n\n/** The HTTP methods supported by OpenAPI. */\nconst methods = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch'] as const\n\n/** Union of all operation IDs in the specification. */\nexport type OperationId<T> =\nT extends { paths: infer P }\n  ? P extends Record<string, infer R>\n    ? R extends Record<string, infer O>\n      ? O extends { operationId: infer N }\n        ? N\n        : string\n      : string\n    : string\n  : string\n\n/** A union of possible Operations types in the specification. */\nexport type Operation = OpenAPI.Operation & { method: FetchMethod; path: string }\n\n/** Find an operation by its operationId in an OpenAPI specification. */\nexport type OperationById<T, U extends OperationId<T>> =\n  T extends { paths: infer P }\n    ? CollectKey<P> extends Record<string, infer R>\n      ? CollectKey<R> extends Record<string, infer O>\n        ? O extends { $key: [infer P extends string, infer M extends string]; operationId: U }\n          ? Pretty<Omit<O, '$key'> & { method: M; path: P }>\n          : never\n        : never\n      : never\n    : never\n\n/**\n * Given an OpenAPI specification, find an operation by its operationId.\n *\n * @param document The OpenAPI specification document.\n * @param operationId The operationId of the operation to resolve.\n * @returns The resolved operation.\n * @example resolveOperation(document, 'getUser') // { method: 'get', path: '/users/{username}', ... }\n */\nexport function resolveOperation<T, U extends OperationId<T>>(document: T, operationId: U): OperationById<T, U>\nexport function resolveOperation(document: object, operationId: string): Operation\nexport function resolveOperation(document: object, operationId: string): Operation {\n\n  // --- Validate the specification.\n  if (!document\n    || typeof document !== 'object'\n    || document === null\n    || 'paths' in document === false\n    || typeof document.paths !== 'object'\n    || document.paths === null)\n    throw new Error('Missing paths object in the OpenAPI specification.')\n\n  // --- Search for the operation in the specification's paths.\n  const paths = document.paths as OpenAPI.Document['paths']\n  for (const path in paths) {\n    const route = paths[path]\n    if (typeof route !== 'object' || route === null) continue\n\n    // --- Search in each method for the operation.\n    for (const method of methods) {\n      const operation = route[method]\n      if (method in route === false\n        || typeof operation !== 'object'\n        || operation === null\n        || 'operationId' in operation === false\n        || operation.operationId !== operationId) continue\n\n      // --- Route was found, return the operation.\n      return { ...route[method], method, path }\n    }\n  }\n\n  // --- Throw an error if the operation was not found.\n  throw new Error(`Operation \"${operationId}\" not found in specification.`)\n}\n","/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV3 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v3.0 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v3.0 specification, `false` otherwise.\n * @example isOpenAPIV3({ openapi: '3.0.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV3(value: unknown): value is OpenAPIV3.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'openapi' in value\n    && value.openapi === '3.0.0'\n}\n","import type { OpenAPI, OpenAPIV3 as V3 } from 'openapi-types'\nimport { isOpenAPIV3 } from './isOpenAPIV3'\n\nexport interface TokenOptions {\n  tokenLocation?: 'cookie' | 'header' | 'query'\n  tokenProperty?: string\n}\n\n/**\n * Resolve the location of the apiKey token based on the OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param operation The OpenAPI operation object.\n * @returns The location of the apiKey token ('query' | 'cookie' | 'header').\n * @example resolveOperationTokenOptions(document, operation) // => { tokenLocation: 'header', tokenProperty: 'X-API-Key' }\n */\nexport function resolveOperationTokenOptions(document: object, operation: OpenAPI.Operation): TokenOptions {\n  if (!isOpenAPIV3(document)) return {}\n\n  // --- Find the security scheme in the OpenAPI specification.\n  const security = operation.security ?? document.security\n  if (!security) return {}\n  const securityScheme = document?.components?.securitySchemes\n  if (!securityScheme) return {}\n\n  // --- Find the first security scheme that is an apiKey.\n  for (const requirement of security) {\n    for (const key in requirement) {\n      const scheme = securityScheme[key] as V3.SecuritySchemeObject\n      if (typeof scheme !== 'object' || scheme === null) continue\n      if (scheme.type === 'apiKey') {\n        return {\n          tokenLocation: scheme.in as 'cookie' | 'header' | 'query',\n          tokenProperty: scheme.name,\n        }\n      }\n    }\n  }\n\n  // --- Return an empty object if no apiKey was found.\n  return {}\n}\n"],"names":[],"mappings":"AAwBO,SAAS,aAAgB,eAAgC;AAG9D,MACE,CAAC,iBACE,OAAO,iBAAkB,YACzB,kBAAkB;AACf,UAAA,IAAI,MAAM,gCAAgC;AAGlD,MACE,aAAa,iBACV,MAAM,QAAQ,cAAc,OAAO,KACnC,cAAc,QAAQ,SAAS,KAC/B,SAAS,cAAc,QAAQ,CAAC,KAChC,OAAO,cAAc,QAAQ,CAAC,EAAE,OAAQ,YACxC,cAAc,QAAQ,CAAC,EAAE,IAAI,SAAS;AAClC,WAAA,cAAc,QAAQ,CAAC,EAAE;AAGlC,MACE,UAAU,iBACP,OAAO,cAAc,QAAS,UAAU;AAE3C,UAAM,SACJ,aAAa,iBACV,MAAM,QAAQ,cAAc,OAAO,KACnC,cAAc,QAAQ,SAAS,KAC/B,OAAO,cAAc,QAAQ,CAAC,KAAM,WACrC,cAAc,QAAQ,CAAC,IACvB,SAEE,WACJ,cAAc,iBACX,OAAO,cAAc,YAAa,YAClC,cAAc,SAAS,SAAS,IACjC,cAAc,WACd;AAEJ,WAAO,GAAG,MAAM,MAAM,cAAc,IAAI,GAAG,QAAQ;AAAA,EAAA;AAG/C,QAAA,IAAI,MAAM,iDAAiD;AACnE;AC9DA,MAAM,UAAU,CAAC,OAAO,OAAO,QAAQ,UAAU,WAAW,QAAQ,OAAO;AAuC3D,SAAA,iBAAiB,UAAkB,aAAgC;AAGjF,MAAI,CAAC,YACA,OAAO,YAAa,YACpB,aAAa,QACb,EAAW,WAAA,aACX,OAAO,SAAS,SAAU,YAC1B,SAAS,UAAU;AAChB,UAAA,IAAI,MAAM,oDAAoD;AAGtE,QAAM,QAAQ,SAAS;AACvB,aAAW,QAAQ,OAAO;AAClB,UAAA,QAAQ,MAAM,IAAI;AACpB,QAAA,EAAA,OAAO,SAAU,YAAY,UAAU;AAG3C,iBAAW,UAAU,SAAS;AACtB,cAAA,YAAY,MAAM,MAAM;AAC1B,YAAA,EAAA,EAAA,UAAU,UACT,OAAO,aAAc,YACrB,cAAc,QACd,EAAA,iBAAiB,cACjB,UAAU,gBAAgB;AAG/B,iBAAO,EAAE,GAAG,MAAM,MAAM,GAAG,QAAQ,KAAK;AAAA,MAAA;AAAA,EAC1C;AAIF,QAAM,IAAI,MAAM,cAAc,WAAW,+BAA+B;AAC1E;ACnEO,SAAS,YAAY,OAA6C;AAChE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACCgB,SAAA,6BAA6B,UAAkB,WAA4C;AACzG,MAAI,CAAC,YAAY,QAAQ,UAAU,CAAC;AAG9B,QAAA,WAAW,UAAU,YAAY,SAAS;AAC5C,MAAA,CAAC,SAAU,QAAO,CAAC;AACjB,QAAA,iBAAiB,UAAU,YAAY;AACzC,MAAA,CAAC,eAAgB,QAAO,CAAC;AAG7B,aAAW,eAAe;AACxB,eAAW,OAAO,aAAa;AACvB,YAAA,SAAS,eAAe,GAAG;AACjC,UAAI,SAAO,UAAW,YAAY,WAAW,SACzC,OAAO,SAAS;AACX,eAAA;AAAA,UACL,eAAe,OAAO;AAAA,UACtB,eAAe,OAAO;AAAA,QACxB;AAAA,IAAA;AAMN,SAAO,CAAC;AACV;"}
\ No newline at end of file
diff --git a/dist/chunks/BdFNzMcu.cjs b/dist/chunks/BdFNzMcu.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..15ab56e031a455774abfdb22337a7cce4eb95869
--- /dev/null
+++ b/dist/chunks/BdFNzMcu.cjs
@@ -0,0 +1,84 @@
+"use strict";
+var functions = require("@unshared/functions"), parseRequestQuery = require("./BDxlAULu.cjs");
+const EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, PROTOCOLS = /* @__PURE__ */ new Set(["ws", "wss"]);
+function parseConnectUrl(parameters, channel, options) {
+  const { baseUrl, protocol } = options, match = EXP_CONNECTION_CHANNEL.exec(channel);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeProtocol = protocol ?? match.groups.protocol ?? "ws", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const protocolLower = routeProtocol.toLowerCase();
+  if (!PROTOCOLS.has(protocolLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeProtocol}\` is invalid.`);
+  parameters.url = new URL(routeBaseUrl), parameters.url.pathname += parameters.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path, parameters.protocol = protocolLower;
+}
+function parseConnectOptions(channel, options) {
+  const { baseUrl, protocol, data, parameters = data, query = data } = options, wsParameters = { url: new URL("about:blank") };
+  return parseConnectUrl(wsParameters, channel, { baseUrl, protocol }), parseRequestQuery.parseRequestParameters(wsParameters, { parameters }), parseRequestQuery.parseRequestQuery(wsParameters, { query }), wsParameters;
+}
+class WebSocketChannel {
+  constructor(channel, options) {
+    this.channel = channel, this.options = options;
+  }
+  /** The WebSocket connection to the server. */
+  webSocket;
+  /**
+   * Open a new WebSocket connection to the server. The connection will be opened with the given
+   * URL and protocols. If the connection is already open, the connection will be closed before
+   * opening a new connection. Also add the event listeners that were passed in the options.
+   *
+   * @returns The WebSocket connection.
+   */
+  async open() {
+    this.webSocket && await this.close();
+    const { url, protocol } = parseConnectOptions(this.channel, this.options);
+    this.webSocket = new WebSocket(url, protocol);
+    const promise = new Promise((resolve, rejects) => {
+      this.webSocket.addEventListener("error", () => rejects(new Error("Failed to open the WebSocket connection")), { once: !0 }), this.webSocket.addEventListener("open", () => {
+        this.options.initialPayload && this.send(this.options.initialPayload), resolve();
+      }, { once: !0 });
+    });
+    return this.options.onOpen && this.on("open", this.options.onOpen, { once: !0 }), this.options.onClose && this.on("close", this.options.onClose, { once: !0 }), this.options.onError && this.on("error", this.options.onError), this.options.onMessage && this.on("message", (message) => this.options.onMessage(message)), this.webSocket.addEventListener("close", (event) => {
+      event.code !== 1e3 && this.options.autoReconnect && (this.options.reconnectLimit && event.wasClean || setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0));
+    }, { once: !0 }), promise.then(() => this);
+  }
+  /**
+   * Send a payload to the server. The payload will be serialized to JSON before sending.
+   *
+   * @param payload The data to send to the server.
+   */
+  send(payload) {
+    if (!this.webSocket) throw new Error("WebSocket connection is not open");
+    const json = JSON.stringify(payload);
+    this.webSocket.send(json);
+  }
+  on(event, callback, options) {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    const listener = async (event2) => {
+      if (event2.type !== "message") return callback(event2);
+      let data = event2.data;
+      data instanceof Blob && (data = await data.text());
+      try {
+        data = JSON.parse(data);
+      } catch {
+        console.error("Failed to parse the message:", data);
+      }
+      callback(data);
+    };
+    return this.webSocket.addEventListener(event, listener, options), () => this.webSocket.removeEventListener(event, listener);
+  }
+  /**
+   * Close the WebSocket connection to the server. The connection will not be able to send or receive
+   * messages after it is closed.
+   */
+  async close() {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    this.webSocket.readyState !== WebSocket.CLOSED && this.webSocket.readyState !== WebSocket.CLOSING && (this.webSocket.close(1e3, "Client closed the connection"), await new Promise((resolve) => this.webSocket.addEventListener("close", () => resolve())));
+  }
+}
+function connect(route, options) {
+  const channel = new WebSocketChannel(route, options);
+  return functions.awaitable(channel, () => channel.open());
+}
+exports.WebSocketChannel = WebSocketChannel;
+exports.connect = connect;
+exports.parseConnectOptions = parseConnectOptions;
+//# sourceMappingURL=BdFNzMcu.cjs.map
diff --git a/dist/chunks/BdFNzMcu.cjs.map b/dist/chunks/BdFNzMcu.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..468e8165fac8e2c5d936b0552cec2ffb5a753645
--- /dev/null
+++ b/dist/chunks/BdFNzMcu.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"BdFNzMcu.cjs","sources":["../../websocket/parseConnectOptions.ts","../../websocket/connect.ts"],"sourcesContent":["import type { Loose, ObjectLike, UnionMerge } from '@unshared/types'\nimport { parseRequestParameters } from '../utils/parseRequestParameters'\nimport { parseRequestQuery } from '../utils/parseRequestQuery'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid WebSocket protocols. */\nconst PROTOCOLS = new Set(['ws', 'wss'])\n\n/** The protocols to use for the connection. */\nexport type ConnectProtocol = 'WS' | 'WSS'\n\n/** Options to pass to the `createChannel` function. */\nexport interface ConnectOptions<\n  BaseUrl extends string = string,\n  Query extends ObjectLike = ObjectLike,\n  Parameters extends ObjectLike = ObjectLike,\n  ClientData extends ObjectLike = any,\n  ServerData extends ObjectLike = any,\n> {\n\n  /** The protocol to use when connecting to the server. */\n  protocol?: Lowercase<ConnectProtocol> | Uppercase<ConnectProtocol>\n\n  /** The base URL to connect to. */\n  baseUrl?: BaseUrl\n\n  /**\n   * The path parameters to use when connecting to the server. These parameters will be used to\n   * fill in the path parameters of the connection URL.\n   *\n   * @example { id: 1 }\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to use when connecting to the server. These parameters will be used to\n   * fill in the query parameters of the connection URL.\n   *\n   * @example { limit: 10, offset: 0 }\n   */\n  query?: Loose<Query>\n\n  /**\n   * The data to send when creating the connection. Namely, the path parameters\n   * to use when connecting to the server.\n   *\n   * @example\n   *\n   * // Create a new connection to `http://localhost:8080/users/1`.\n   * connect('GET /users/:id', {\n   *   data: { id: 1 },\n   *   baseUrl: 'http://localhost:8080'\n   * })\n   */\n  data?: UnionMerge<Loose<Query> | Parameters>\n\n  /**\n   * The payload to send when creating the connection. Namely, the initial message\n   * to send to the server when the connection is established.\n   */\n  initialPayload?: Loose<ClientData>\n\n  /**\n   * Weather to reconnect the connection when it is closed unexpectedly. If `true`,\n   * the connection will automatically reconnect when it is closed. If `false`, the\n   * connection will not reconnect when it is closed.\n   *\n   * @default false\n   */\n  autoReconnect?: boolean\n\n  /**\n   * The delay in milliseconds to wait before reconnecting the connection. This delay\n   * will be used to wait before reconnecting the connection after it is closed.\n   *\n   * @default 0\n   */\n  reconnectDelay?: number\n\n  /**\n   * The maximum number of times to reconnect the connection before giving up. This\n   * number will be used to determine when to stop trying to reconnect the connection.\n   *\n   * @default 3\n   */\n  reconnectLimit?: number\n\n  /**\n   * The function to call when the connection is opened. This function will be called\n   * when the connection is successfully opened or reconnected.\n   */\n  onOpen?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed with an error. This function will\n   * be called when the connection is closed unexpectedly with an error.\n   */\n  onError?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed. This function will be called\n   * when the connection is closed unexpectedly or when the connection is closed manually.\n   */\n  onClose?: (event: CloseEvent) => void\n\n  /**\n   * The function to call when a message is received from the server. This function will\n   * be called when a message is received from the server.\n   */\n  onMessage?: (data: ServerData) => void\n}\n\nexport interface WebSocketParameters {\n  url: URL\n  protocol?: 'ws' | 'wss'\n}\n\nfunction parseConnectUrl(parameters: WebSocketParameters, channel: string, options: ConnectOptions): void {\n  const { baseUrl, protocol } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_CONNECTION_CHANNEL.exec(channel)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeProtocol = protocol ?? match.groups.protocol ?? 'ws'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const protocolLower = routeProtocol.toLowerCase()\n  const protocolIsValid = PROTOCOLS.has(protocolLower)\n  if (!protocolIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeProtocol}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  parameters.url = new URL(routeBaseUrl)\n  parameters.url.pathname += parameters.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n  parameters.protocol = protocolLower as 'ws' | 'wss'\n}\n\nexport function parseConnectOptions(channel: string, options: ConnectOptions): WebSocketParameters {\n  const { baseUrl, protocol, data, parameters = data, query = data } = options\n  const wsParameters: WebSocketParameters = { url: new URL('about:blank') }\n  parseConnectUrl(wsParameters, channel, { baseUrl, protocol })\n  parseRequestParameters(wsParameters, { parameters })\n  parseRequestQuery(wsParameters, { query })\n  return wsParameters\n}\n","import type { Awaitable } from '@unshared/functions'\nimport type { ConnectOptions } from './parseConnectOptions'\nimport { awaitable } from '@unshared/functions'\nimport { parseConnectOptions } from './parseConnectOptions'\n\ntype RemoveListener = () => void\n\ntype ClientData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, infer R, any> ? R : any\n\ntype ServerData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, any, infer R> ? R : any\n\nexport class WebSocketChannel<T extends ConnectOptions = ConnectOptions> {\n  constructor(public channel: string, public options: T) {}\n\n  /** The WebSocket connection to the server. */\n  public webSocket: undefined | WebSocket\n\n  /**\n   * Open a new WebSocket connection to the server. The connection will be opened with the given\n   * URL and protocols. If the connection is already open, the connection will be closed before\n   * opening a new connection. Also add the event listeners that were passed in the options.\n   *\n   * @returns The WebSocket connection.\n   */\n  async open(): Promise<this> {\n    if (this.webSocket) await this.close()\n    const { url, protocol } = parseConnectOptions(this.channel, this.options)\n    this.webSocket = new WebSocket(url, protocol)\n\n    // --- Return a promise that resolves when the connection is opened.\n    const promise = new Promise<void>((resolve, rejects) => {\n      this.webSocket!.addEventListener('error', () => rejects(new Error('Failed to open the WebSocket connection')), { once: true })\n      this.webSocket!.addEventListener('open', () => {\n        if (this.options.initialPayload) this.send(this.options.initialPayload as ClientData<T>)\n        resolve()\n      }, { once: true })\n    })\n\n    // --- Add the options' hooks to the WebSocket connection.\n    if (this.options.onOpen) this.on('open', this.options.onOpen, { once: true })\n    if (this.options.onClose) this.on('close', this.options.onClose, { once: true })\n    if (this.options.onError) this.on('error', this.options.onError)\n    if (this.options.onMessage) this.on('message', message => this.options.onMessage!(message))\n\n    // --- Handle reconnection when the connection is closed unexpectedly.\n    this.webSocket.addEventListener('close', (event) => {\n      if (event.code === 1000) return\n      if (!this.options.autoReconnect) return\n      if (this.options.reconnectLimit && event.wasClean) return\n      setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0)\n    }, { once: true })\n\n    return promise.then(() => this)\n  }\n\n  /**\n   * Send a payload to the server. The payload will be serialized to JSON before sending.\n   *\n   * @param payload The data to send to the server.\n   */\n  send(payload: ClientData<T>) {\n    if (!this.webSocket) throw new Error('WebSocket connection is not open')\n    const json = JSON.stringify(payload)\n    this.webSocket.send(json)\n  }\n\n  /**\n   * Listen for events from the server. The event will be deserialized from JSON before calling the callback.\n   *\n   * @param event The event to listen for.\n   * @param callback The callback to call when the event is received.\n   * @returns A function to remove the event listener.\n   */\n  on(event: 'message', callback: (data: ServerData<T>) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'close', callback: (event: CloseEvent) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'error', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'open', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: string, callback: (data: any) => void, options?: AddEventListenerOptions) {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n\n    const listener = async(event: CloseEvent | Event | MessageEvent<Blob>): Promise<void> => {\n      if (event.type !== 'message') return callback(event)\n      // @ts-expect-error: `data` exists on the event.\n      let data = event.data as unknown\n      if (data instanceof Blob) data = await data.text()\n      try { data = JSON.parse(data as string) }\n      catch { console.error('Failed to parse the message:', data) }\n      callback(data)\n    }\n\n    /* eslint-disable @typescript-eslint/no-misused-promises */\n    this.webSocket.addEventListener(event, listener, options)\n    return () => this.webSocket!.removeEventListener(event, listener)\n    /* eslint-enable @typescript-eslint/no-misused-promises */\n  }\n\n  /**\n   * Close the WebSocket connection to the server. The connection will not be able to send or receive\n   * messages after it is closed.\n   */\n  async close() {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n    if (this.webSocket.readyState === WebSocket.CLOSED) return\n    if (this.webSocket.readyState === WebSocket.CLOSING) return\n    this.webSocket.close(1000, 'Client closed the connection')\n    await new Promise<void>(resolve => this.webSocket!.addEventListener('close', () => resolve()))\n  }\n}\n\n/**\n * Create a new WebSocket connection to the server with the given path. The connection will\n * automatically reconnect if the connection is closed unexpectedly.\n *\n * @param route The name of the route to connect to.\n * @param options The options to pass to the connection.\n * @returns The WebSocket connection.\n */\nexport function connect(route: string, options: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n  const channel = new WebSocketChannel(route, options)\n  return awaitable(channel, () => channel.open())\n}\n"],"names":["parseRequestParameters","parseRequestQuery","event","awaitable"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/chunks/BwI3JmT5.js b/dist/chunks/BwI3JmT5.js
new file mode 100644
index 0000000000000000000000000000000000000000..67938de873e807ecc4a261e4e3d0e16b7cd360c2
--- /dev/null
+++ b/dist/chunks/BwI3JmT5.js
@@ -0,0 +1,191 @@
+import { p as parseRequestParameters, a as parseRequestQuery } from "./B6pUErTM.js";
+import { awaitable } from "@unshared/functions/awaitable";
+function isObjectLike(value) {
+  return typeof value == "object" && value !== null && value.constructor === Object;
+}
+function setHeader(headers, key, value) {
+  if (value = String(value), headers instanceof Headers)
+    headers.set(key, value);
+  else if (Array.isArray(headers)) {
+    const keyLower = key.toLowerCase(), index = headers.findIndex(([k]) => k.toLowerCase() === keyLower);
+    index === -1 && headers.push([key, value]), headers[index] = [key, value];
+  } else if (typeof headers == "object" && headers !== null) {
+    const keyLower = key.toLowerCase();
+    for (const k in headers)
+      if (k.toLowerCase() === keyLower) {
+        headers[k] = value;
+        return;
+      }
+    headers[key] = value;
+  }
+}
+function parseRequestBasicAuth(context, options) {
+  const { username, password } = options;
+  if (typeof username != "string" || typeof password != "string") return;
+  const credentials = btoa(`${username}:${password}`);
+  context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Authorization", `Basic ${credentials}`);
+}
+function isFormDataLike(value) {
+  if (typeof value != "object" || value === null) return !1;
+  if (value instanceof FormData) return !0;
+  const values = Object.values(value);
+  return values.length === 0 ? !1 : values.every((x) => x instanceof File ? !0 : Array.isArray(x) ? x.every((item) => item instanceof File) : x instanceof Blob);
+}
+function toFormData(object) {
+  if (object instanceof FormData) return object;
+  const formData = new FormData();
+  for (const key in object) {
+    const value = object[key];
+    if (value !== void 0)
+      if (Array.isArray(value))
+        for (const item of value)
+          formData.append(key, item);
+      else
+        formData.append(key, value);
+  }
+  return formData;
+}
+function parseRequestBody(context, options) {
+  const { body } = options;
+  context.init?.method && (["get", "head", "delete"].includes(context.init.method) || body != null && (isFormDataLike(body) ? (context.init.body = toFormData(body), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "multipart/form-data")) : body instanceof ReadableStream ? (context.init.body = body, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "application/octet-stream")) : body instanceof File ? (context.init.body = body.stream(), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Disposition", `attachment; filename="${body.name}"`), setHeader(context.init.headers, "Content-Type", body.type), setHeader(context.init.headers, "Content-Length", body.size), setHeader(context.init.headers, "Content-Transfer-Encoding", "binary")) : isObjectLike(body) ? (context.init.body = JSON.stringify(body), context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, "Content-Type", "application/json")) : context.init.body = body));
+}
+function parseRequestHeaders(context, options) {
+  const { headers } = options;
+  for (const key in headers) {
+    const value = headers[key];
+    (typeof value != "string" || value.length === 0) && typeof value != "number" || (context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setHeader(context.init.headers, key, value));
+  }
+}
+function getHeader(headers, key) {
+  if (headers instanceof Headers)
+    return headers.get(key) ?? void 0;
+  if (Array.isArray(headers)) {
+    const keyLower = key.toLowerCase(), header = headers.find(([k]) => k.toLowerCase() === keyLower);
+    return header ? header[1] : void 0;
+  } else {
+    const keyLower = key.toLowerCase(), keys = Object.keys(headers), index = keys.findIndex((k) => k.toLowerCase() === keyLower);
+    return index === -1 ? void 0 : headers[keys[index]];
+  }
+}
+function getCookies(headers) {
+  const value = getHeader(headers, "Cookie");
+  if (!value) return {};
+  const cookies = {}, parts = value.split(";");
+  for (const part of parts) {
+    const [key, value2] = part.trim().split("=").map((v) => v.trim());
+    !key || !value2 || (cookies[key] = value2);
+  }
+  return cookies;
+}
+function setCookie(headers, key, value) {
+  const cookies = { ...getCookies(headers), [key]: value }, header = Object.entries(cookies).map(([key2, value2]) => `${key2}=${value2}`).join("; ");
+  setHeader(headers, "Cookie", header);
+}
+function parseRequestToken(context, options) {
+  const { token, tokenLocation = "headers", tokenProperty } = options;
+  if (token) {
+    if (tokenLocation === "query") {
+      if (!(context.url instanceof URL)) throw new Error("The `url` must be an instance of `URL`.");
+      if (!tokenProperty) throw new Error("The `tokenProperty` must be provided when using `tokenLocation` of `query`.");
+      context.url.searchParams.set(tokenProperty, token);
+    } else if (tokenLocation === "header")
+      context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, tokenProperty ? setHeader(context.init.headers, tokenProperty, token) : setHeader(context.init.headers, "Authorization", `Bearer ${token}`);
+    else if (tokenLocation === "cookie") {
+      if (!tokenProperty) throw new Error("The `tokenProperty` must be provided when using `tokenLocation` of `cookie`.");
+      context.init = context.init ?? {}, context.init.headers = context.init.headers ?? {}, setCookie(context.init.headers, tokenProperty, token);
+    }
+  }
+}
+const EXP_REQUEST = /^((?<method>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, METHODS = /* @__PURE__ */ new Set(["get", "post", "put", "patch", "delete", "head", "options"]);
+function parseRequestUrl(context, route, options) {
+  const { method, baseUrl } = options, match = EXP_REQUEST.exec(route);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeMethod = method ?? match.groups.method ?? "get", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const methodLower = routeMethod.toLowerCase();
+  if (!METHODS.has(methodLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeMethod}\` is invalid.`);
+  context.init = context.init ?? {}, context.init.method = methodLower, context.url = new URL(routeBaseUrl), context.url.pathname += context.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path;
+}
+function parseRequest(route, options = {}) {
+  const {
+    username,
+    password,
+    token,
+    tokenLocation,
+    tokenProperty,
+    data,
+    body,
+    query,
+    parameters,
+    headers,
+    method,
+    baseUrl,
+    queryArrayFormat,
+    ...init
+  } = options, context = { init }, dataObject = isObjectLike(data) ? data : void 0;
+  parseRequestUrl(context, route, { baseUrl, method }), parseRequestParameters(context, { parameters: parameters ?? dataObject }), parseRequestBasicAuth(context, { username, password });
+  const requestMethod = context.init?.method?.toLowerCase() ?? "get", requestExpectsBody = ["post", "put", "patch"].includes(requestMethod);
+  return parseRequestQuery(context, { queryArrayFormat, query: requestExpectsBody ? query : query ?? dataObject }), parseRequestToken(context, { token, tokenLocation, tokenProperty }), parseRequestBody(context, { body: requestExpectsBody ? body ?? dataObject : void 0 }), parseRequestHeaders(context, { headers }), context;
+}
+async function* createResponseStreamJsonIterator(response, options) {
+  const { onError, onSuccess, onData, onEnd } = options;
+  try {
+    const body = response.body;
+    if (body === null) throw new Error("Could not read the response body, it is empty.");
+    const reader = body.getReader();
+    for (; ; ) {
+      const { done, value } = await reader.read();
+      if (done) break;
+      const parts = new TextDecoder().decode(value).trim().split("\0").filter(Boolean);
+      for (const part of parts) {
+        const payload = JSON.parse(part);
+        onData && onData(payload), yield payload;
+      }
+    }
+    onSuccess && onSuccess(response);
+  } catch (error) {
+    onError && onError(error);
+  } finally {
+    onEnd && onEnd(response);
+  }
+}
+function handleResponseStreamJson(response, options) {
+  const responseIterator = createResponseStreamJsonIterator(response, options);
+  return awaitable(responseIterator);
+}
+async function handleResponse(response, options = {}) {
+  const { onError, onSuccess, onData, onEnd, onFailure } = options, contentType = response.headers.get("Content-Type");
+  if (!response.ok)
+    throw onFailure && onFailure(response), onEnd && onEnd(response), new Error(response.statusText);
+  if (response.status === 204) {
+    onSuccess && onSuccess(response), onEnd && onEnd(response);
+    return;
+  }
+  return contentType?.startsWith("text/") ? await response.text().then((data) => (onData && onData(data), onSuccess && onSuccess(response), data)).catch((error) => {
+    throw onError && onError(error), error;
+  }).finally(() => {
+    onEnd && onEnd(response);
+  }) : contentType === "application/json" ? await response.json().then((data) => (onData && onData(data), onSuccess && onSuccess(response), data)).catch((error) => {
+    throw onError && onError(error), error;
+  }).finally(() => {
+    onEnd && onEnd(response);
+  }) : contentType === "application/stream+json" ? handleResponseStreamJson(response, options) : (onSuccess && onSuccess(response), onEnd && onEnd(response), response.body);
+}
+export {
+  getHeader as a,
+  handleResponseStreamJson as b,
+  isObjectLike as c,
+  parseRequestBasicAuth as d,
+  parseRequestBody as e,
+  parseRequestHeaders as f,
+  getCookies as g,
+  handleResponse as h,
+  isFormDataLike as i,
+  parseRequestToken as j,
+  parseRequestUrl as k,
+  setHeader as l,
+  parseRequest as p,
+  setCookie as s,
+  toFormData as t
+};
+//# sourceMappingURL=BwI3JmT5.js.map
diff --git a/dist/chunks/BwI3JmT5.js.map b/dist/chunks/BwI3JmT5.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..48ba101e66e6f082de6505a121ac683c319b6724
--- /dev/null
+++ b/dist/chunks/BwI3JmT5.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"BwI3JmT5.js","sources":["../../utils/isObjectLike.ts","../../utils/setHeader.ts","../../utils/parseRequestBasicAuth.ts","../../utils/isFormDataLike.ts","../../utils/toFormData.ts","../../utils/parseRequestBody.ts","../../utils/parseRequestHeaders.ts","../../utils/getHeader.ts","../../utils/getCookies.ts","../../utils/setCookie.ts","../../utils/parseRequestToken.ts","../../utils/parseRequestUrl.ts","../../utils/parseRequest.ts","../../utils/handleResponseStreamJson.ts","../../utils/handleResponse.ts"],"sourcesContent":["import type { ObjectLike } from '@unshared/types'\n\n/**\n * Predicate to check if a value is an object-like value.\n *\n * @param value The value to check.\n * @returns `true` if the value is an object-like value, `false` otherwise.\n * @example isObjectLike({}) // true\n */\nexport function isObjectLike(value: unknown): value is ObjectLike {\n  return typeof value === 'object' && value !== null && value.constructor === Object\n}\n","/**\n * Set a header in the `HeadersInit` object whether it is a `Headers` instance, an\n * array of key-value pairs, or an object. It is also case-insensitive, meaning that\n * if a header with the same key but different case is found, it will be replaced.\n *\n * @param headers The headers to set the key-value pair in.\n * @param key The key of the header to set.\n * @param value The value of the header to set.\n * @example\n * const headers = new Headers()\n * setHeader(headers, 'Content-Type', 'application/json')\n * console.log(headers.get('Content-Type')) // 'application/json'\n */\nexport function setHeader(headers: HeadersInit, key: string, value: number | string): void {\n  value = String(value)\n  if (headers instanceof Headers) {\n    headers.set(key, value)\n  }\n  else if (Array.isArray(headers)) {\n    const keyLower = key.toLowerCase()\n    const index = headers.findIndex(([k]) => k.toLowerCase() === keyLower)\n    if (index === -1) headers.push([key, value])\n    headers[index] = [key, value]\n  }\n  else if (typeof headers === 'object' && headers !== null) {\n    const keyLower = key.toLowerCase()\n    for (const k in headers) {\n      if (k.toLowerCase() !== keyLower) continue\n      headers[k] = value\n      return\n    }\n    headers[key] = value\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the basic authentication headers based on the provided username and password.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n *\n * // Append the `Authorization` header to the request.\n * const context = {}\n * parseRequestBasicAuth(context, { username: 'user', password: 'pass' })\n *\n * // Will mutate the `init` object to include the headers.\n * console.log(context) // => { init: { headers: { 'Authorization': 'Basic dXNlcjpwYXNz' } } }\n */\nexport function parseRequestBasicAuth(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { username, password } = options\n\n  // --- Return early if the username or password is not provided.\n  if (typeof username !== 'string' || typeof password !== 'string') return\n\n  // --- Encode the credentials and set the Authorization header.\n  const credentials = btoa(`${username}:${password}`)\n  context.init = context.init ?? {}\n  context.init.headers = context.init.headers ?? {}\n  setHeader(context.init.headers, 'Authorization', `Basic ${credentials}`)\n}\n","/**\n * A type that represents a FormData-like object, which is a plain object with\n * nested Blob, File, or FileList values. Or a FormData instance.\n */\nexport type FormDataLike = FormData | Record<string, Blob | File | FileList>\n\n/**\n * Predicate to check if a value is FormData-like, meaning it is a plain object\n * with nested Blob, File, or FileList values.\n *\n * @param value The value to check.\n * @returns `true` if the value is FormData-like, `false` otherwise.\n * @example isFormDataLike({ file: new File(['test'], 'test.txt') }) // true\n */\nexport function isFormDataLike(value: unknown): value is FormDataLike {\n  if (typeof value !== 'object' || value === null) return false\n  if (value instanceof FormData) return true\n  const values = Object.values(value)\n  if (values.length === 0) return false\n  return values.every((x) => {\n    if (x instanceof File) return true\n    if (Array.isArray(x)) return x.every(item => item instanceof File)\n    return x instanceof Blob\n  })\n}\n","import type { FormDataLike } from './isFormDataLike'\n\n/**\n * Casts an object that may contain `Blob`, `File`, or `FileList` values to a `FormData` object.\n *\n * @param object The object to cast to a `FormData` object.\n * @returns The `FormData` object.\n */\nexport function toFormData(object: FormDataLike): FormData {\n  if (object instanceof FormData) return object\n  const formData = new FormData()\n  for (const key in object) {\n    const value = object[key]\n    if (value === undefined) continue\n    if (Array.isArray(value)) {\n      for (const item of value)\n        formData.append(key, item as Blob | string)\n    }\n    else {\n      formData.append(key, value as Blob | string)\n    }\n  }\n  return formData\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { isFormDataLike } from './isFormDataLike'\nimport { isObjectLike } from './isObjectLike'\nimport { setHeader } from './setHeader'\nimport { toFormData } from './toFormData'\n\n/**\n * Parse the request body based on the provided data and options.\n *\n * @param context The request context.\n * @param options The request options.\n */\nexport function parseRequestBody(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { body } = options\n\n  // --- If the method is `GET`, `HEAD`, or `DELETE`, return early.\n  if (!context.init?.method) return\n  if (['get', 'head', 'delete'].includes(context.init.method)) return\n\n  // --- If no data is provided, return early.\n  if (body === null || body === undefined) return\n\n  // --- If data contains a `File` object, create a FormData object.\n  if (isFormDataLike(body)) {\n    context.init.body = toFormData(body)\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'multipart/form-data')\n  }\n\n  // --- If the data is a `ReadableStream`, pass it directly to the body.\n  else if (body instanceof ReadableStream) {\n    context.init.body = body\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'application/octet-stream')\n  }\n\n  // --- If the data is a Blob, pass it directly to the body.\n  else if (body instanceof File) {\n    context.init.body = body.stream()\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Disposition', `attachment; filename=\"${body.name}\"`)\n    setHeader(context.init.headers, 'Content-Type', body.type)\n    setHeader(context.init.headers, 'Content-Length', body.size)\n    setHeader(context.init.headers, 'Content-Transfer-Encoding', 'binary')\n  }\n\n  // --- Otherwise, stringify the data and set the content type to JSON.\n  else if (isObjectLike(body)) {\n    context.init.body = JSON.stringify(body)\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, 'Content-Type', 'application/json')\n  }\n\n  // --- For all other data types, set the body directly.\n  else {\n    context.init.body = body as BodyInit\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the request headers based on the provided data and options.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n *\n * // Append the `Content-Type` header to the request.\n * const context = {}\n * parseRequestHeaders(context, { headers: { 'Content-Type': 'application/json' } })\n *\n * // Will mutate the `init` object to include the headers.\n * console.log(context) // => { init: { headers: { 'Content-Type': 'application/json' } } }\n */\nexport function parseRequestHeaders(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { headers } = options\n\n  // --- Merge the headers with the existing headers.\n  for (const key in headers) {\n    const value = headers[key]\n    if (((typeof value !== 'string' || value.length === 0) && typeof value !== 'number')) continue\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    setHeader(context.init.headers, key, value)\n  }\n}\n","/**\n * Get a header value from the `HeadersInit` object.\n *\n * @param headers The headers to get the key-value pair from.\n * @param key The key of the header to get.\n * @returns The value of the header.\n * @example\n * const headers = new Headers({ 'Content-Type': 'application/json' })\n * const contentType = getHeader(headers, 'Content-Type')\n * console.log(contentType) // 'application/json'\n */\nexport function getHeader(headers: HeadersInit, key: string): string | undefined {\n  if (headers instanceof Headers) {\n    return headers.get(key) ?? undefined\n  }\n  else if (Array.isArray(headers)) {\n    const keyLower = key.toLowerCase()\n    const header = headers.find(([k]) => k.toLowerCase() === keyLower)\n    return header ? header[1] : undefined\n  }\n  else {\n    const keyLower = key.toLowerCase()\n    const keys = Object.keys(headers)\n    const index = keys.findIndex(k => k.toLowerCase() === keyLower)\n    return index === -1 ? undefined : headers[keys[index]]\n  }\n}\n","import { getHeader } from './getHeader'\n\n/**\n * Extract the cookies from the `HeadersInit` object.\n *\n * @param headers The headers to extract the cookies from.\n * @returns An array of cookies.\n * @example\n * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })\n * const cookies = getCookies(headers) // { key1: 'value1', key2: 'value2' }\n */\nexport function getCookies(headers: HeadersInit): Record<string, string> {\n  const value = getHeader(headers, 'Cookie')\n  if (!value) return {}\n\n  // --- Parse the cookie header.\n  const cookies: Record<string, string> = {}\n  const parts = value.split(';')\n  for (const part of parts) {\n    const [key, value] = part.trim().split('=').map(v => v.trim())\n    if (!key || !value) continue\n    cookies[key] = value\n  }\n\n  // --- Return the cookies.\n  return cookies\n}\n","import { getCookies } from './getCookies'\nimport { setHeader } from './setHeader'\n\n/**\n * Set a cookie in the `HeadersInit` object.\n *\n * @param headers The headers to set the cookie in.\n * @param key The key of the cookie to set.\n * @param value The value of the cookie to set.\n * @example\n * const headers = new Headers()\n * const cookie = { key: 'key1', value: 'value1', path: '/', secure: true }\n * setCookie(headers, cookie)\n * console.log(headers.get('Cookie')) // 'key1=value1; Path=/; Secure'\n */\nexport function setCookie(headers: HeadersInit, key: string, value: string): void {\n  const cookies = { ...getCookies(headers), [key]: value }\n  const header = Object.entries(cookies).map(([key, value]) => `${key}=${value}`).join('; ')\n  setHeader(headers, 'Cookie', header)\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\nimport { setCookie } from './setCookie'\nimport { setHeader } from './setHeader'\n\n/**\n * Parse the token and dynamically extend either the query, headers, or cookies.\n *\n * @param context The request context.\n * @param options The request options.\n * @example\n * // Append the `token` to the query parameters.\n * const context = { url: new URL('https://example.com') }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'query', tokenProperty: 'token' })\n * console.log(context.url.searchParams.get('token')) // 'my-token'\n *\n * @example\n * // Append the `token` to the headers.\n * const context = { init: { headers: new Headers() } }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'header', tokenProperty: 'Authorization' })\n * console.log(context.init.headers.get('Authorization')) // 'Bearer my-token'\n *\n * @example\n * // Append the `token` to the cookies.\n * const context = { init: { headers: new Headers() } }\n * parseRequestToken(context, { token: 'my-token', tokenLocation: 'cookie', tokenProperty: 'token' })\n * console.log(context.init.headers.get('Cookie')) // 'token=my-token'\n */\nexport function parseRequestToken(context: Partial<RequestContext>, options: FetchOptions): void {\n  const { token, tokenLocation = 'headers', tokenProperty } = options\n\n  // --- Return early if the token is not provided.\n  if (!token) return\n\n  // --- Append the token to the query parameters.\n  if (tokenLocation === 'query') {\n    if (context.url instanceof URL === false) throw new Error('The `url` must be an instance of `URL`.')\n    if (!tokenProperty) throw new Error('The `tokenProperty` must be provided when using `tokenLocation` of `query`.')\n    context.url.searchParams.set(tokenProperty, token)\n  }\n\n  // --- Append the token to the path parameters.\n  else if (tokenLocation === 'header') {\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    if (tokenProperty) setHeader(context.init.headers, tokenProperty, token)\n    else setHeader(context.init.headers, 'Authorization', `Bearer ${token}`)\n  }\n\n  // --- Append the token to the cookie header.\n  else if (tokenLocation === 'cookie') {\n    if (!tokenProperty) throw new Error('The `tokenProperty` must be provided when using `tokenLocation` of `cookie`.')\n    context.init = context.init ?? {}\n    context.init.headers = context.init.headers ?? {}\n    setCookie(context.init.headers, tokenProperty, token)\n  }\n}\n","import type { FetchOptions, RequestContext } from './parseRequest'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_REQUEST = /^((?<method>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid HTTP methods. */\nconst METHODS = new Set(['get', 'post', 'put', 'patch', 'delete', 'head', 'options'])\n\n/**\n * Parses the route name to extract the URL and method. It allows the url and method to be\n * provided in the route name, or in the options object. The method will default to 'get'.\n *\n * @param context The request context to mutate.\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @example parseRequestUrl('GET /users', { baseUrl: 'https://api.example.com' }, context)\n */\nexport function parseRequestUrl(context: Partial<RequestContext>, route: string, options: FetchOptions): void {\n  const { method, baseUrl } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_REQUEST.exec(route)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeMethod = method ?? match.groups.method ?? 'get'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const methodLower = routeMethod.toLowerCase()\n  const methodIsValid = METHODS.has(methodLower)\n  if (!methodIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeMethod}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  context.init = context.init ?? {}\n  context.init.method = methodLower\n  context.url = new URL(routeBaseUrl)\n\n  // --- Append the path to the URL while making sure there are no double slashes.\n  context.url.pathname += context.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n}\n","import type { Loose, MaybeLiteral, ObjectLike } from '@unshared/types'\nimport type { UnionMerge } from '@unshared/types'\nimport type { HttpHeader } from '../HttpHeaders'\nimport type { HttpMethod } from '../HttpMethods'\nimport type { SearchArrayFormat } from './toSearchParams'\nimport { isObjectLike } from './isObjectLike'\nimport { parseRequestBasicAuth } from './parseRequestBasicAuth'\nimport { parseRequestBody } from './parseRequestBody'\nimport { parseRequestHeaders } from './parseRequestHeaders'\nimport { parseRequestParameters } from './parseRequestParameters'\nimport { parseRequestQuery } from './parseRequestQuery'\nimport { parseRequestToken } from './parseRequestToken'\nimport { parseRequestUrl } from './parseRequestUrl'\n\n/** The methods to use for the request. */\nexport type FetchMethod = Lowercase<keyof typeof HttpMethod> | Uppercase<keyof typeof HttpMethod>\n\n/** Headers to include in the request. */\nexport type FetchHeaders = Partial<Record<MaybeLiteral<HttpHeader>, number | string>>\n\n/** Options to pass to the request. */\nexport interface FetchOptions<\n  Method extends FetchMethod = FetchMethod,\n  BaseUrl extends string = string,\n  Parameters extends ObjectLike = ObjectLike,\n  Query extends ObjectLike = ObjectLike,\n  Body = unknown,\n  Headers extends ObjectLike = ObjectLike,\n> extends Omit<RequestInit, 'body' | 'headers' | 'method'> {\n\n  /**\n   * The method to use for the request.\n   *\n   * @example 'GET'\n   */\n  method?: Method\n\n  /**\n   * The base URL to use for the request. This URL will be used to resolve the\n   * path and query parameters of the request.\n   *\n   * @example 'https://api.example.com'\n   */\n  baseUrl?: BaseUrl\n\n  /**\n   * The data to include in the request. This data will be used to populate the\n   * query parameters, body, and headers of the request based on the method type.\n   *\n   * @example { id: 1 }\n   */\n  data?: Loose<UnionMerge<Body | Headers | Query>>\n\n  /**\n   * The path parameters to include in the request.\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to include in the request.\n   */\n  query?: Loose<Query>\n\n  /**\n   * The format to use when serializing the query parameters.\n   */\n  queryArrayFormat?: SearchArrayFormat\n\n  /**\n   * The body to include in the request.\n   */\n  body?: Body extends ObjectLike ? Loose<Body> : Body\n\n  /**\n   * The headers to include in the request.\n   */\n  headers?: FetchHeaders & Headers\n\n  /**\n   * The username for basic authentication.\n   */\n  username?: string\n\n  /**\n   * The password for basic authentication.\n   */\n  password?: string\n\n  /**\n   * The token for API key authentication.\n   */\n  token?: string\n\n  /**\n   * The location where the token should be included in the request.\n   */\n  tokenLocation?: 'cookie' | 'header' | 'query'\n\n  /**\n   * The name of the key to use in the request for the token.\n   */\n  tokenProperty?: string\n}\n\nexport interface RequestContext {\n  url: URL\n  init: RequestInit\n}\n\n/**\n * Resolves the request body and/or query parameters based on the method type. This function\n * will mutate the `init` object to include the request body and headers based on the data type.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The URL and the `RequestInit` object.\n */\nexport function parseRequest(route: string, options: FetchOptions = {}): RequestContext {\n  const {\n    username,\n    password,\n    token,\n    tokenLocation,\n    tokenProperty,\n    data,\n    body,\n    query,\n    parameters,\n    headers,\n    method,\n    baseUrl,\n    queryArrayFormat,\n    ...init\n  } = options\n  const context: Partial<RequestContext> = { init }\n  const dataObject = isObjectLike(data) ? data : undefined\n\n  // --- Parse the URL and insert the path parameters.\n  parseRequestUrl(context, route, { baseUrl, method })\n  parseRequestParameters(context, { parameters: parameters ?? dataObject })\n  parseRequestBasicAuth(context, { username, password })\n\n  // --- Depending on the method, parse the query, body, and headers.\n  const requestMethod = context.init?.method?.toLowerCase() ?? 'get'\n  const requestExpectsBody = ['post', 'put', 'patch'].includes(requestMethod)\n  parseRequestQuery(context, { queryArrayFormat, query: requestExpectsBody ? query : query ?? dataObject })\n  parseRequestToken(context, { token, tokenLocation, tokenProperty })\n  parseRequestBody(context, { body: requestExpectsBody ? body ?? dataObject : undefined })\n  parseRequestHeaders(context, { headers })\n\n  // --- Return the context with the URL and the `RequestInit` object.\n  return context as RequestContext\n}\n","import type { Awaitable } from '@unshared/functions/awaitable'\nimport type { RequestOptions } from './request'\nimport { awaitable } from '@unshared/functions/awaitable'\n\nasync function * createResponseStreamJsonIterator(response: Response, options: RequestOptions): AsyncGenerator<unknown, void, unknown> {\n  const { onError, onSuccess, onData, onEnd } = options\n  try {\n    const body = response.body\n    if (body === null) throw new Error('Could not read the response body, it is empty.')\n    const reader = body.getReader()\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) break\n      const parts = new TextDecoder().decode(value).trim().split('\\0').filter(Boolean)\n\n      // --- For each part, parse as JSON and yield the data.\n      for (const part of parts) {\n        const payload = JSON.parse(part) as unknown\n        if (onData) onData(payload)\n        yield payload\n      }\n    }\n    if (onSuccess) onSuccess(response)\n  }\n  catch (error) {\n    if (onError) onError(error as Error)\n  }\n  finally {\n    if (onEnd) onEnd(response)\n  }\n}\n\n/**\n * Handle a request response where the content type is a stream of JSON objects. This function\n * will parse the JSON objects and yield the data to the caller. If an error occurs, the `onError`\n * callback will be called and the function will return.\n *\n * @param response The response to handle.\n * @param options The options to pass to the request.\n * @returns An awaitable iterator that yields the parsed JSON objects.\n */\nexport function handleResponseStreamJson(response: Response, options: RequestOptions): Awaitable<AsyncIterable<unknown>, unknown[]> {\n  const responseIterator = createResponseStreamJsonIterator(response, options)\n  return awaitable(responseIterator)\n}\n","import type { RequestOptions } from './request'\nimport { handleResponseStreamJson } from './handleResponseStreamJson'\n\n/**\n * Handle a request response. This function will parse the response based on the content type and\n * return the data. If an error occurs, the `onError` callback will be called and the function will\n * throw an error.\n *\n * @param response The response to handle.\n * @param options The options to pass to the request.\n * @returns The parsed data from the response.\n */\nexport async function handleResponse(response: Response, options: RequestOptions = {}): Promise<unknown> {\n  const { onError, onSuccess, onData, onEnd, onFailure } = options\n  const contentType = response.headers.get('Content-Type')\n\n  // --- If the response is not OK, throw an error with the response message.\n  if (!response.ok) {\n    if (onFailure) onFailure(response)\n    if (onEnd) onEnd(response)\n    throw new Error(response.statusText)\n  }\n\n  // --- If the status code is 204, return an empty response early.\n  if (response.status === 204) {\n    if (onSuccess) onSuccess(response)\n    if (onEnd) onEnd(response)\n    return\n  }\n\n  // --- If the response is a text content type, return the text response.\n  if (contentType?.startsWith('text/')) {\n    return await response.text()\n      .then((data) => {\n        if (onData) onData(data)\n        if (onSuccess) onSuccess(response)\n        return data\n      })\n      .catch((error: Error) => {\n        if (onError) onError(error)\n        throw error\n      })\n      .finally(() => {\n        if (onEnd) onEnd(response)\n      })\n  }\n\n  // --- If the response is a application/json, parse the JSON and return it.\n  if (contentType === 'application/json') {\n    return await response.json()\n      .then((data) => {\n        if (onData) onData(data)\n        if (onSuccess) onSuccess(response)\n        return data as unknown\n      })\n      .catch((error: Error) => {\n        if (onError) onError(error)\n        throw error\n      })\n      .finally(() => {\n        if (onEnd) onEnd(response)\n      })\n  }\n\n  // --- If the response is a application/stream+json, return an iterator that parses the JSON.\n  if (contentType === 'application/stream+json')\n    return handleResponseStreamJson(response, options)\n\n  // --- Otherwise, fallback to returning the response body as-is.\n  if (onSuccess) onSuccess(response)\n  if (onEnd) onEnd(response)\n  return response.body\n}\n"],"names":["value","key"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/chunks/Bys4-xE2.js b/dist/chunks/Bys4-xE2.js
new file mode 100644
index 0000000000000000000000000000000000000000..e5135fd77ea2fedbc6d14c596a0f964a59af8e15
--- /dev/null
+++ b/dist/chunks/Bys4-xE2.js
@@ -0,0 +1,86 @@
+import { awaitable } from "@unshared/functions";
+import { p as parseRequestParameters, a as parseRequestQuery } from "./B6pUErTM.js";
+const EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\/{2}[^/]+)?(?<path>\/[^\s?]*)/i, PROTOCOLS = /* @__PURE__ */ new Set(["ws", "wss"]);
+function parseConnectUrl(parameters, channel, options) {
+  const { baseUrl, protocol } = options, match = EXP_CONNECTION_CHANNEL.exec(channel);
+  if (!match?.groups) throw new Error("Could not resolve the `RequestInit` object: Invalid route name.");
+  const routeProtocol = protocol ?? match.groups.protocol ?? "ws", routeBaseUrl = baseUrl ?? match.groups.url;
+  if (!routeBaseUrl) throw new Error("Could not resolve the `RequestInit` object: the `baseUrl` is missing.");
+  const protocolLower = routeProtocol.toLowerCase();
+  if (!PROTOCOLS.has(protocolLower)) throw new Error(`Could not resolve the \`RequestInit\` object:, the method \`${routeProtocol}\` is invalid.`);
+  parameters.url = new URL(routeBaseUrl), parameters.url.pathname += parameters.url.pathname.endsWith("/") ? match.groups.path.slice(1) : match.groups.path, parameters.protocol = protocolLower;
+}
+function parseConnectOptions(channel, options) {
+  const { baseUrl, protocol, data, parameters = data, query = data } = options, wsParameters = { url: new URL("about:blank") };
+  return parseConnectUrl(wsParameters, channel, { baseUrl, protocol }), parseRequestParameters(wsParameters, { parameters }), parseRequestQuery(wsParameters, { query }), wsParameters;
+}
+class WebSocketChannel {
+  constructor(channel, options) {
+    this.channel = channel, this.options = options;
+  }
+  /** The WebSocket connection to the server. */
+  webSocket;
+  /**
+   * Open a new WebSocket connection to the server. The connection will be opened with the given
+   * URL and protocols. If the connection is already open, the connection will be closed before
+   * opening a new connection. Also add the event listeners that were passed in the options.
+   *
+   * @returns The WebSocket connection.
+   */
+  async open() {
+    this.webSocket && await this.close();
+    const { url, protocol } = parseConnectOptions(this.channel, this.options);
+    this.webSocket = new WebSocket(url, protocol);
+    const promise = new Promise((resolve, rejects) => {
+      this.webSocket.addEventListener("error", () => rejects(new Error("Failed to open the WebSocket connection")), { once: !0 }), this.webSocket.addEventListener("open", () => {
+        this.options.initialPayload && this.send(this.options.initialPayload), resolve();
+      }, { once: !0 });
+    });
+    return this.options.onOpen && this.on("open", this.options.onOpen, { once: !0 }), this.options.onClose && this.on("close", this.options.onClose, { once: !0 }), this.options.onError && this.on("error", this.options.onError), this.options.onMessage && this.on("message", (message) => this.options.onMessage(message)), this.webSocket.addEventListener("close", (event) => {
+      event.code !== 1e3 && this.options.autoReconnect && (this.options.reconnectLimit && event.wasClean || setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0));
+    }, { once: !0 }), promise.then(() => this);
+  }
+  /**
+   * Send a payload to the server. The payload will be serialized to JSON before sending.
+   *
+   * @param payload The data to send to the server.
+   */
+  send(payload) {
+    if (!this.webSocket) throw new Error("WebSocket connection is not open");
+    const json = JSON.stringify(payload);
+    this.webSocket.send(json);
+  }
+  on(event, callback, options) {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    const listener = async (event2) => {
+      if (event2.type !== "message") return callback(event2);
+      let data = event2.data;
+      data instanceof Blob && (data = await data.text());
+      try {
+        data = JSON.parse(data);
+      } catch {
+        console.error("Failed to parse the message:", data);
+      }
+      callback(data);
+    };
+    return this.webSocket.addEventListener(event, listener, options), () => this.webSocket.removeEventListener(event, listener);
+  }
+  /**
+   * Close the WebSocket connection to the server. The connection will not be able to send or receive
+   * messages after it is closed.
+   */
+  async close() {
+    if (!this.webSocket) throw new Error("WebSocket connection has not been opened yet");
+    this.webSocket.readyState !== WebSocket.CLOSED && this.webSocket.readyState !== WebSocket.CLOSING && (this.webSocket.close(1e3, "Client closed the connection"), await new Promise((resolve) => this.webSocket.addEventListener("close", () => resolve())));
+  }
+}
+function connect(route, options) {
+  const channel = new WebSocketChannel(route, options);
+  return awaitable(channel, () => channel.open());
+}
+export {
+  WebSocketChannel as W,
+  connect as c,
+  parseConnectOptions as p
+};
+//# sourceMappingURL=Bys4-xE2.js.map
diff --git a/dist/chunks/Bys4-xE2.js.map b/dist/chunks/Bys4-xE2.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..988ddaed949b0fa880508c331c4ef8c8ef2c0458
--- /dev/null
+++ b/dist/chunks/Bys4-xE2.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Bys4-xE2.js","sources":["../../websocket/parseConnectOptions.ts","../../websocket/connect.ts"],"sourcesContent":["import type { Loose, ObjectLike, UnionMerge } from '@unshared/types'\nimport { parseRequestParameters } from '../utils/parseRequestParameters'\nimport { parseRequestQuery } from '../utils/parseRequestQuery'\n\n/** Regular expression to match the request method and URL. */\nconst EXP_CONNECTION_CHANNEL = /^((?<protocol>[a-z]+) )?(?<url>[^:]+?:\\/{2}[^/]+)?(?<path>\\/[^\\s?]*)/i\n\n/** Valid WebSocket protocols. */\nconst PROTOCOLS = new Set(['ws', 'wss'])\n\n/** The protocols to use for the connection. */\nexport type ConnectProtocol = 'WS' | 'WSS'\n\n/** Options to pass to the `createChannel` function. */\nexport interface ConnectOptions<\n  BaseUrl extends string = string,\n  Query extends ObjectLike = ObjectLike,\n  Parameters extends ObjectLike = ObjectLike,\n  ClientData extends ObjectLike = any,\n  ServerData extends ObjectLike = any,\n> {\n\n  /** The protocol to use when connecting to the server. */\n  protocol?: Lowercase<ConnectProtocol> | Uppercase<ConnectProtocol>\n\n  /** The base URL to connect to. */\n  baseUrl?: BaseUrl\n\n  /**\n   * The path parameters to use when connecting to the server. These parameters will be used to\n   * fill in the path parameters of the connection URL.\n   *\n   * @example { id: 1 }\n   */\n  parameters?: Parameters\n\n  /**\n   * The query parameters to use when connecting to the server. These parameters will be used to\n   * fill in the query parameters of the connection URL.\n   *\n   * @example { limit: 10, offset: 0 }\n   */\n  query?: Loose<Query>\n\n  /**\n   * The data to send when creating the connection. Namely, the path parameters\n   * to use when connecting to the server.\n   *\n   * @example\n   *\n   * // Create a new connection to `http://localhost:8080/users/1`.\n   * connect('GET /users/:id', {\n   *   data: { id: 1 },\n   *   baseUrl: 'http://localhost:8080'\n   * })\n   */\n  data?: UnionMerge<Loose<Query> | Parameters>\n\n  /**\n   * The payload to send when creating the connection. Namely, the initial message\n   * to send to the server when the connection is established.\n   */\n  initialPayload?: Loose<ClientData>\n\n  /**\n   * Weather to reconnect the connection when it is closed unexpectedly. If `true`,\n   * the connection will automatically reconnect when it is closed. If `false`, the\n   * connection will not reconnect when it is closed.\n   *\n   * @default false\n   */\n  autoReconnect?: boolean\n\n  /**\n   * The delay in milliseconds to wait before reconnecting the connection. This delay\n   * will be used to wait before reconnecting the connection after it is closed.\n   *\n   * @default 0\n   */\n  reconnectDelay?: number\n\n  /**\n   * The maximum number of times to reconnect the connection before giving up. This\n   * number will be used to determine when to stop trying to reconnect the connection.\n   *\n   * @default 3\n   */\n  reconnectLimit?: number\n\n  /**\n   * The function to call when the connection is opened. This function will be called\n   * when the connection is successfully opened or reconnected.\n   */\n  onOpen?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed with an error. This function will\n   * be called when the connection is closed unexpectedly with an error.\n   */\n  onError?: (event: Event) => void\n\n  /**\n   * The function to call when the connection is closed. This function will be called\n   * when the connection is closed unexpectedly or when the connection is closed manually.\n   */\n  onClose?: (event: CloseEvent) => void\n\n  /**\n   * The function to call when a message is received from the server. This function will\n   * be called when a message is received from the server.\n   */\n  onMessage?: (data: ServerData) => void\n}\n\nexport interface WebSocketParameters {\n  url: URL\n  protocol?: 'ws' | 'wss'\n}\n\nfunction parseConnectUrl(parameters: WebSocketParameters, channel: string, options: ConnectOptions): void {\n  const { baseUrl, protocol } = options\n\n  // --- Extract the path, method, and base URL from the route name.\n  const match = EXP_CONNECTION_CHANNEL.exec(channel)\n  if (!match?.groups) throw new Error('Could not resolve the `RequestInit` object: Invalid route name.')\n  const routeProtocol = protocol ?? match.groups.protocol ?? 'ws'\n  const routeBaseUrl = baseUrl ?? match.groups.url\n\n  // --- Assert the base URL is provided, either in the options or the route name.\n  if (!routeBaseUrl) throw new Error('Could not resolve the `RequestInit` object: the `baseUrl` is missing.')\n\n  // --- Assert the method is valid.\n  const protocolLower = routeProtocol.toLowerCase()\n  const protocolIsValid = PROTOCOLS.has(protocolLower)\n  if (!protocolIsValid) throw new Error(`Could not resolve the \\`RequestInit\\` object:, the method \\`${routeProtocol}\\` is invalid.`)\n\n  // --- Create the url and apply the method.\n  parameters.url = new URL(routeBaseUrl)\n  parameters.url.pathname += parameters.url.pathname.endsWith('/') ? match.groups.path.slice(1) : match.groups.path\n  parameters.protocol = protocolLower as 'ws' | 'wss'\n}\n\nexport function parseConnectOptions(channel: string, options: ConnectOptions): WebSocketParameters {\n  const { baseUrl, protocol, data, parameters = data, query = data } = options\n  const wsParameters: WebSocketParameters = { url: new URL('about:blank') }\n  parseConnectUrl(wsParameters, channel, { baseUrl, protocol })\n  parseRequestParameters(wsParameters, { parameters })\n  parseRequestQuery(wsParameters, { query })\n  return wsParameters\n}\n","import type { Awaitable } from '@unshared/functions'\nimport type { ConnectOptions } from './parseConnectOptions'\nimport { awaitable } from '@unshared/functions'\nimport { parseConnectOptions } from './parseConnectOptions'\n\ntype RemoveListener = () => void\n\ntype ClientData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, infer R, any> ? R : any\n\ntype ServerData<T extends ConnectOptions> =\n  T extends ConnectOptions<any, any, any, any, infer R> ? R : any\n\nexport class WebSocketChannel<T extends ConnectOptions = ConnectOptions> {\n  constructor(public channel: string, public options: T) {}\n\n  /** The WebSocket connection to the server. */\n  public webSocket: undefined | WebSocket\n\n  /**\n   * Open a new WebSocket connection to the server. The connection will be opened with the given\n   * URL and protocols. If the connection is already open, the connection will be closed before\n   * opening a new connection. Also add the event listeners that were passed in the options.\n   *\n   * @returns The WebSocket connection.\n   */\n  async open(): Promise<this> {\n    if (this.webSocket) await this.close()\n    const { url, protocol } = parseConnectOptions(this.channel, this.options)\n    this.webSocket = new WebSocket(url, protocol)\n\n    // --- Return a promise that resolves when the connection is opened.\n    const promise = new Promise<void>((resolve, rejects) => {\n      this.webSocket!.addEventListener('error', () => rejects(new Error('Failed to open the WebSocket connection')), { once: true })\n      this.webSocket!.addEventListener('open', () => {\n        if (this.options.initialPayload) this.send(this.options.initialPayload as ClientData<T>)\n        resolve()\n      }, { once: true })\n    })\n\n    // --- Add the options' hooks to the WebSocket connection.\n    if (this.options.onOpen) this.on('open', this.options.onOpen, { once: true })\n    if (this.options.onClose) this.on('close', this.options.onClose, { once: true })\n    if (this.options.onError) this.on('error', this.options.onError)\n    if (this.options.onMessage) this.on('message', message => this.options.onMessage!(message))\n\n    // --- Handle reconnection when the connection is closed unexpectedly.\n    this.webSocket.addEventListener('close', (event) => {\n      if (event.code === 1000) return\n      if (!this.options.autoReconnect) return\n      if (this.options.reconnectLimit && event.wasClean) return\n      setTimeout(() => void this.open(), this.options.reconnectDelay ?? 0)\n    }, { once: true })\n\n    return promise.then(() => this)\n  }\n\n  /**\n   * Send a payload to the server. The payload will be serialized to JSON before sending.\n   *\n   * @param payload The data to send to the server.\n   */\n  send(payload: ClientData<T>) {\n    if (!this.webSocket) throw new Error('WebSocket connection is not open')\n    const json = JSON.stringify(payload)\n    this.webSocket.send(json)\n  }\n\n  /**\n   * Listen for events from the server. The event will be deserialized from JSON before calling the callback.\n   *\n   * @param event The event to listen for.\n   * @param callback The callback to call when the event is received.\n   * @returns A function to remove the event listener.\n   */\n  on(event: 'message', callback: (data: ServerData<T>) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'close', callback: (event: CloseEvent) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'error', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: 'open', callback: (event: Event) => void, options?: AddEventListenerOptions): RemoveListener\n  on(event: string, callback: (data: any) => void, options?: AddEventListenerOptions) {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n\n    const listener = async(event: CloseEvent | Event | MessageEvent<Blob>): Promise<void> => {\n      if (event.type !== 'message') return callback(event)\n      // @ts-expect-error: `data` exists on the event.\n      let data = event.data as unknown\n      if (data instanceof Blob) data = await data.text()\n      try { data = JSON.parse(data as string) }\n      catch { console.error('Failed to parse the message:', data) }\n      callback(data)\n    }\n\n    /* eslint-disable @typescript-eslint/no-misused-promises */\n    this.webSocket.addEventListener(event, listener, options)\n    return () => this.webSocket!.removeEventListener(event, listener)\n    /* eslint-enable @typescript-eslint/no-misused-promises */\n  }\n\n  /**\n   * Close the WebSocket connection to the server. The connection will not be able to send or receive\n   * messages after it is closed.\n   */\n  async close() {\n    if (!this.webSocket) throw new Error('WebSocket connection has not been opened yet')\n    if (this.webSocket.readyState === WebSocket.CLOSED) return\n    if (this.webSocket.readyState === WebSocket.CLOSING) return\n    this.webSocket.close(1000, 'Client closed the connection')\n    await new Promise<void>(resolve => this.webSocket!.addEventListener('close', () => resolve()))\n  }\n}\n\n/**\n * Create a new WebSocket connection to the server with the given path. The connection will\n * automatically reconnect if the connection is closed unexpectedly.\n *\n * @param route The name of the route to connect to.\n * @param options The options to pass to the connection.\n * @returns The WebSocket connection.\n */\nexport function connect(route: string, options: ConnectOptions): Awaitable<WebSocketChannel, WebSocketChannel> {\n  const channel = new WebSocketChannel(route, options)\n  return awaitable(channel, () => channel.open())\n}\n"],"names":["event"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/chunks/DEyigyGy.cjs b/dist/chunks/DEyigyGy.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..60e3794014df995ed72f75844bcb9631cd756962
--- /dev/null
+++ b/dist/chunks/DEyigyGy.cjs
@@ -0,0 +1,53 @@
+"use strict";
+function getServerUrl(specification) {
+  if (!specification || typeof specification != "object" || specification === null)
+    throw new Error("Invalid OpenAPI specification.");
+  if ("servers" in specification && Array.isArray(specification.servers) && specification.servers.length > 0 && "url" in specification.servers[0] && typeof specification.servers[0].url == "string" && specification.servers[0].url.length > 0)
+    return specification.servers[0].url;
+  if ("host" in specification && typeof specification.host == "string") {
+    const scheme = "schemes" in specification && Array.isArray(specification.schemes) && specification.schemes.length > 0 && typeof specification.schemes[0] == "string" ? specification.schemes[0] : "https", basePath = "basePath" in specification && typeof specification.basePath == "string" && specification.basePath.length > 0 ? specification.basePath : "/";
+    return `${scheme}://${specification.host}${basePath}`;
+  }
+  throw new Error("No base URL found in the OpenAPI specification.");
+}
+const methods = ["get", "put", "post", "delete", "options", "head", "patch"];
+function resolveOperation(document, operationId) {
+  if (!document || typeof document != "object" || document === null || !("paths" in document) || typeof document.paths != "object" || document.paths === null)
+    throw new Error("Missing paths object in the OpenAPI specification.");
+  const paths = document.paths;
+  for (const path in paths) {
+    const route = paths[path];
+    if (!(typeof route != "object" || route === null))
+      for (const method of methods) {
+        const operation = route[method];
+        if (!(!(method in route) || typeof operation != "object" || operation === null || !("operationId" in operation) || operation.operationId !== operationId))
+          return { ...route[method], method, path };
+      }
+  }
+  throw new Error(`Operation "${operationId}" not found in specification.`);
+}
+function isOpenAPIV3(value) {
+  return typeof value == "object" && value !== null && "openapi" in value && value.openapi === "3.0.0";
+}
+function resolveOperationTokenOptions(document, operation) {
+  if (!isOpenAPIV3(document)) return {};
+  const security = operation.security ?? document.security;
+  if (!security) return {};
+  const securityScheme = document?.components?.securitySchemes;
+  if (!securityScheme) return {};
+  for (const requirement of security)
+    for (const key in requirement) {
+      const scheme = securityScheme[key];
+      if (!(typeof scheme != "object" || scheme === null) && scheme.type === "apiKey")
+        return {
+          tokenLocation: scheme.in,
+          tokenProperty: scheme.name
+        };
+    }
+  return {};
+}
+exports.getServerUrl = getServerUrl;
+exports.isOpenAPIV3 = isOpenAPIV3;
+exports.resolveOperation = resolveOperation;
+exports.resolveOperationTokenOptions = resolveOperationTokenOptions;
+//# sourceMappingURL=DEyigyGy.cjs.map
diff --git a/dist/chunks/DEyigyGy.cjs.map b/dist/chunks/DEyigyGy.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..eb738892b1b616b9b3ecb13604eb7f756b4feadf
--- /dev/null
+++ b/dist/chunks/DEyigyGy.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"DEyigyGy.cjs","sources":["../../openapi/getServerUrl.ts","../../openapi/resolveOperation.ts","../../openapi/isOpenAPIV3.ts","../../openapi/resolveOperationTokenOptions.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Get the base URL of an OpenAPI specification. */\nexport type ServerUrl<T> =\n\n  // --- Handle OpenAPI 2.0 specifications.\n  T extends {\n    host: infer Host extends string\n    basePath?: infer BasePath extends string\n    schemes?: Array<infer Scheme extends string>\n  }\n    ? `${Scheme}://${Host}${BasePath}`\n\n    // --- Handle OpenAPI 3.0 specifications.\n    : T extends { servers: Array<{ url: infer U extends string }> }\n      ? U\n      : string\n\n/**\n * Given an OpenAPI specification, get the first base URL.\n *\n * @param specification The OpenAPI specification.\n * @returns The first base URL.\n * @example getBaseUrl(specification) // 'https://api.example.com/v1'\n */\nexport function getServerUrl<T>(specification: T): ServerUrl<T> {\n\n  // --- Ensure the specification is an object.\n  if (\n    !specification\n    || typeof specification !== 'object'\n    || specification === null)\n    throw new Error('Invalid OpenAPI specification.')\n\n  // --- Handle OpenAPI 3.0 specifications.\n  if (\n    'servers' in specification\n    && Array.isArray(specification.servers)\n    && specification.servers.length > 0\n    && 'url' in specification.servers[0]\n    && typeof specification.servers[0].url === 'string'\n    && specification.servers[0].url.length > 0)\n    return specification.servers[0].url as ServerUrl<T>\n\n  // --- Handle OpenAPI 2.0 specifications.\n  if (\n    'host' in specification\n    && typeof specification.host === 'string') {\n\n    const scheme = (\n      'schemes' in specification\n      && Array.isArray(specification.schemes)\n      && specification.schemes.length > 0\n      && typeof specification.schemes[0] === 'string')\n      ? specification.schemes[0]\n      : 'https'\n\n    const basePath = (\n      'basePath' in specification\n      && typeof specification.basePath === 'string'\n      && specification.basePath.length > 0)\n      ? specification.basePath\n      : '/'\n\n    return `${scheme}://${specification.host}${basePath}` as ServerUrl<T>\n  }\n\n  throw new Error('No base URL found in the OpenAPI specification.')\n}\n","import type { CollectKey, Pretty } from '@unshared/types'\nimport type { OpenAPI } from 'openapi-types'\nimport type { FetchMethod } from '../utils/parseRequest'\n\n/** The HTTP methods supported by OpenAPI. */\nconst methods = ['get', 'put', 'post', 'delete', 'options', 'head', 'patch'] as const\n\n/** Union of all operation IDs in the specification. */\nexport type OperationId<T> =\nT extends { paths: infer P }\n  ? P extends Record<string, infer R>\n    ? R extends Record<string, infer O>\n      ? O extends { operationId: infer N }\n        ? N\n        : string\n      : string\n    : string\n  : string\n\n/** A union of possible Operations types in the specification. */\nexport type Operation = OpenAPI.Operation & { method: FetchMethod; path: string }\n\n/** Find an operation by its operationId in an OpenAPI specification. */\nexport type OperationById<T, U extends OperationId<T>> =\n  T extends { paths: infer P }\n    ? CollectKey<P> extends Record<string, infer R>\n      ? CollectKey<R> extends Record<string, infer O>\n        ? O extends { $key: [infer P extends string, infer M extends string]; operationId: U }\n          ? Pretty<Omit<O, '$key'> & { method: M; path: P }>\n          : never\n        : never\n      : never\n    : never\n\n/**\n * Given an OpenAPI specification, find an operation by its operationId.\n *\n * @param document The OpenAPI specification document.\n * @param operationId The operationId of the operation to resolve.\n * @returns The resolved operation.\n * @example resolveOperation(document, 'getUser') // { method: 'get', path: '/users/{username}', ... }\n */\nexport function resolveOperation<T, U extends OperationId<T>>(document: T, operationId: U): OperationById<T, U>\nexport function resolveOperation(document: object, operationId: string): Operation\nexport function resolveOperation(document: object, operationId: string): Operation {\n\n  // --- Validate the specification.\n  if (!document\n    || typeof document !== 'object'\n    || document === null\n    || 'paths' in document === false\n    || typeof document.paths !== 'object'\n    || document.paths === null)\n    throw new Error('Missing paths object in the OpenAPI specification.')\n\n  // --- Search for the operation in the specification's paths.\n  const paths = document.paths as OpenAPI.Document['paths']\n  for (const path in paths) {\n    const route = paths[path]\n    if (typeof route !== 'object' || route === null) continue\n\n    // --- Search in each method for the operation.\n    for (const method of methods) {\n      const operation = route[method]\n      if (method in route === false\n        || typeof operation !== 'object'\n        || operation === null\n        || 'operationId' in operation === false\n        || operation.operationId !== operationId) continue\n\n      // --- Route was found, return the operation.\n      return { ...route[method], method, path }\n    }\n  }\n\n  // --- Throw an error if the operation was not found.\n  throw new Error(`Operation \"${operationId}\" not found in specification.`)\n}\n","/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV3 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v3.0 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v3.0 specification, `false` otherwise.\n * @example isOpenAPIV3({ openapi: '3.0.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV3(value: unknown): value is OpenAPIV3.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'openapi' in value\n    && value.openapi === '3.0.0'\n}\n","import type { OpenAPI, OpenAPIV3 as V3 } from 'openapi-types'\nimport { isOpenAPIV3 } from './isOpenAPIV3'\n\nexport interface TokenOptions {\n  tokenLocation?: 'cookie' | 'header' | 'query'\n  tokenProperty?: string\n}\n\n/**\n * Resolve the location of the apiKey token based on the OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param operation The OpenAPI operation object.\n * @returns The location of the apiKey token ('query' | 'cookie' | 'header').\n * @example resolveOperationTokenOptions(document, operation) // => { tokenLocation: 'header', tokenProperty: 'X-API-Key' }\n */\nexport function resolveOperationTokenOptions(document: object, operation: OpenAPI.Operation): TokenOptions {\n  if (!isOpenAPIV3(document)) return {}\n\n  // --- Find the security scheme in the OpenAPI specification.\n  const security = operation.security ?? document.security\n  if (!security) return {}\n  const securityScheme = document?.components?.securitySchemes\n  if (!securityScheme) return {}\n\n  // --- Find the first security scheme that is an apiKey.\n  for (const requirement of security) {\n    for (const key in requirement) {\n      const scheme = securityScheme[key] as V3.SecuritySchemeObject\n      if (typeof scheme !== 'object' || scheme === null) continue\n      if (scheme.type === 'apiKey') {\n        return {\n          tokenLocation: scheme.in as 'cookie' | 'header' | 'query',\n          tokenProperty: scheme.name,\n        }\n      }\n    }\n  }\n\n  // --- Return an empty object if no apiKey was found.\n  return {}\n}\n"],"names":[],"mappings":";AAwBO,SAAS,aAAgB,eAAgC;AAG9D,MACE,CAAC,iBACE,OAAO,iBAAkB,YACzB,kBAAkB;AACf,UAAA,IAAI,MAAM,gCAAgC;AAGlD,MACE,aAAa,iBACV,MAAM,QAAQ,cAAc,OAAO,KACnC,cAAc,QAAQ,SAAS,KAC/B,SAAS,cAAc,QAAQ,CAAC,KAChC,OAAO,cAAc,QAAQ,CAAC,EAAE,OAAQ,YACxC,cAAc,QAAQ,CAAC,EAAE,IAAI,SAAS;AAClC,WAAA,cAAc,QAAQ,CAAC,EAAE;AAGlC,MACE,UAAU,iBACP,OAAO,cAAc,QAAS,UAAU;AAE3C,UAAM,SACJ,aAAa,iBACV,MAAM,QAAQ,cAAc,OAAO,KACnC,cAAc,QAAQ,SAAS,KAC/B,OAAO,cAAc,QAAQ,CAAC,KAAM,WACrC,cAAc,QAAQ,CAAC,IACvB,SAEE,WACJ,cAAc,iBACX,OAAO,cAAc,YAAa,YAClC,cAAc,SAAS,SAAS,IACjC,cAAc,WACd;AAEJ,WAAO,GAAG,MAAM,MAAM,cAAc,IAAI,GAAG,QAAQ;AAAA,EAAA;AAG/C,QAAA,IAAI,MAAM,iDAAiD;AACnE;AC9DA,MAAM,UAAU,CAAC,OAAO,OAAO,QAAQ,UAAU,WAAW,QAAQ,OAAO;AAuC3D,SAAA,iBAAiB,UAAkB,aAAgC;AAGjF,MAAI,CAAC,YACA,OAAO,YAAa,YACpB,aAAa,QACb,EAAW,WAAA,aACX,OAAO,SAAS,SAAU,YAC1B,SAAS,UAAU;AAChB,UAAA,IAAI,MAAM,oDAAoD;AAGtE,QAAM,QAAQ,SAAS;AACvB,aAAW,QAAQ,OAAO;AAClB,UAAA,QAAQ,MAAM,IAAI;AACpB,QAAA,EAAA,OAAO,SAAU,YAAY,UAAU;AAG3C,iBAAW,UAAU,SAAS;AACtB,cAAA,YAAY,MAAM,MAAM;AAC1B,YAAA,EAAA,EAAA,UAAU,UACT,OAAO,aAAc,YACrB,cAAc,QACd,EAAA,iBAAiB,cACjB,UAAU,gBAAgB;AAG/B,iBAAO,EAAE,GAAG,MAAM,MAAM,GAAG,QAAQ,KAAK;AAAA,MAAA;AAAA,EAC1C;AAIF,QAAM,IAAI,MAAM,cAAc,WAAW,+BAA+B;AAC1E;ACnEO,SAAS,YAAY,OAA6C;AAChE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACCgB,SAAA,6BAA6B,UAAkB,WAA4C;AACzG,MAAI,CAAC,YAAY,QAAQ,UAAU,CAAC;AAG9B,QAAA,WAAW,UAAU,YAAY,SAAS;AAC5C,MAAA,CAAC,SAAU,QAAO,CAAC;AACjB,QAAA,iBAAiB,UAAU,YAAY;AACzC,MAAA,CAAC,eAAgB,QAAO,CAAC;AAG7B,aAAW,eAAe;AACxB,eAAW,OAAO,aAAa;AACvB,YAAA,SAAS,eAAe,GAAG;AACjC,UAAI,SAAO,UAAW,YAAY,WAAW,SACzC,OAAO,SAAS;AACX,eAAA;AAAA,UACL,eAAe,OAAO;AAAA,UACtB,eAAe,OAAO;AAAA,QACxB;AAAA,IAAA;AAMN,SAAO,CAAC;AACV;;;;;"}
\ No newline at end of file
diff --git a/dist/chunks/YA_gLiBm.cjs b/dist/chunks/YA_gLiBm.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..7616f20b095d625f947fb4635957e379b71cee78
--- /dev/null
+++ b/dist/chunks/YA_gLiBm.cjs
@@ -0,0 +1,14 @@
+"use strict";
+var handleResponse = require("./B3X3mHFx.cjs");
+async function fetch(route, options = {}) {
+  const { url, init } = handleResponse.parseRequest(route, options);
+  if (!url) throw new Error("Could not parse request URL");
+  return await globalThis.fetch(url, init);
+}
+async function request(route, options = {}) {
+  const response = await fetch(route, options);
+  return await handleResponse.handleResponse(response, options);
+}
+exports.fetch = fetch;
+exports.request = request;
+//# sourceMappingURL=YA_gLiBm.cjs.map
diff --git a/dist/chunks/YA_gLiBm.cjs.map b/dist/chunks/YA_gLiBm.cjs.map
new file mode 100644
index 0000000000000000000000000000000000000000..e85c8201a74e1890cb9037fc9297b874ed060a45
--- /dev/null
+++ b/dist/chunks/YA_gLiBm.cjs.map
@@ -0,0 +1 @@
+{"version":3,"file":"YA_gLiBm.cjs","sources":["../../utils/fetch.ts","../../utils/request.ts"],"sourcesContent":["import type { FetchOptions } from './parseRequest'\nimport { parseRequest } from './parseRequest'\n\n/**\n * Fetch a route with the provided options. This function will parse the route and\n * options to create a `Request` object and return the response from the server.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The response from the server.\n * @example fetch('GET /users', { query: { limit: 10 } })\n */\nexport async function fetch(route: string, options?: FetchOptions): Promise<Response>\nexport async function fetch(route: string, options: FetchOptions = {}): Promise<Response> {\n  const { url, init } = parseRequest(route, options)\n  if (!url) throw new Error('Could not parse request URL')\n  return await globalThis.fetch(url, init)\n}\n","import type { ObjectLike } from '@unshared/types'\nimport type { FetchMethod, FetchOptions } from './parseRequest'\nimport { fetch } from './fetch'\nimport { handleResponse } from './handleResponse'\n\nexport interface RequestOptions<\n  Method extends FetchMethod = FetchMethod,\n  BaseUrl extends string = string,\n  Parameters extends ObjectLike = ObjectLike,\n  Query extends ObjectLike = ObjectLike,\n  Body = unknown,\n  Headers extends ObjectLike = ObjectLike,\n  Data = any,\n  Response = globalThis.Response,\n> extends\n  FetchOptions<Method, BaseUrl, Parameters, Query, Body, Headers> {\n\n  /**\n   * The callback that is called when an error occurs during the request.\n   */\n  onError?: (error: Error) => any\n\n  /**\n   * The callback that is called when data is received from the request. This callback\n   * will be called for each chunk of data that is received from the request.\n   */\n  onData?: (data: Data) => any\n\n  /**\n   * The callback that is called when the request is successful. This callback will be\n   * called after the request is complete and all data has been received.\n   */\n  onSuccess?: (response: Response) => any\n\n  /**\n   * The callback that is called when the status code is not OK. This callback will be called\n   * after the request is complete and before the data is consumed.\n   */\n  onFailure?: (response: Response) => any\n\n  /**\n   * The callback that is called when the request is complete. This callback will be called\n   * after the request is complete and all data has been received.\n   */\n  onEnd?: (response: Response) => any\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param route The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request(route: string, options?: RequestOptions): Promise<unknown>\nexport async function request(route: string, options: RequestOptions = {}): Promise<unknown> {\n  const response = await fetch(route, options)\n  return await handleResponse(response, options)\n}\n"],"names":["parseRequest","handleResponse"],"mappings":";;AAaA,eAAsB,MAAM,OAAe,UAAwB,IAAuB;AACxF,QAAM,EAAE,KAAK,KAAA,IAASA,eAAAA,aAAa,OAAO,OAAO;AACjD,MAAI,CAAC,IAAW,OAAA,IAAI,MAAM,6BAA6B;AACvD,SAAO,MAAM,WAAW,MAAM,KAAK,IAAI;AACzC;ACiDA,eAAsB,QAAQ,OAAe,UAA0B,IAAsB;AAC3F,QAAM,WAAW,MAAM,MAAM,OAAO,OAAO;AACpC,SAAA,MAAMC,eAAAA,eAAe,UAAU,OAAO;AAC/C;;;"}
\ No newline at end of file
diff --git a/dist/createClient.cjs b/dist/createClient.cjs
index aae7d4abec17cd432789bc2bf8f9e45f13330739..47dcbec0e74a8fef8693163f6d09cde54d97940c 100644
--- a/dist/createClient.cjs
+++ b/dist/createClient.cjs
@@ -1,6 +1,7 @@
 "use strict";
-var attempt = require("@unshared/functions/attempt"), handleResponse = require("./chunks/Cayg8606.cjs"), request = require("./chunks/Du_W5H6e.cjs"), connect = require("./chunks/BMbsYNBd.cjs");
-require("./chunks/CYmaYL5B.cjs");
+var attempt = require("@unshared/functions/attempt"), request = require("./chunks/YA_gLiBm.cjs"), connect = require("./chunks/BdFNzMcu.cjs");
+require("./chunks/B3X3mHFx.cjs");
+require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
 require("@unshared/functions");
 class Client {
@@ -23,7 +24,7 @@ class Client {
    * @returns The response from the server.
    */
   fetch(route, options) {
-    return handleResponse.fetch(route, { ...this.options, ...options });
+    return request.fetch(route, { ...this.options, ...options });
   }
   /**
    * Fetch a route from the API and return the data. If the client was instantiated with an
diff --git a/dist/createClient.cjs.map b/dist/createClient.cjs.map
index 883a026e98e55dcede2595df1704bdb1575344bf..a94cd2d1c439af5ef7d73dd43ae556edd18d5577 100644
--- a/dist/createClient.cjs.map
+++ b/dist/createClient.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createClient.cjs","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Data<V>> {\n    return request(route, { ...this.options, ...options }) as Promise<Data<V>>\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Result<Data<V>>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string, V extends U[P]>(channel: P, options?: V): Awaitable<WebSocketChannel<V>, WebSocketChannel<V>> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options }) as Awaitable<WebSocketChannel<V>, WebSocketChannel<V>>\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":["fetch","request","attempt","connect"],"mappings":";;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWZ,MAAkD,OAAU,SAAgC;AAC1F,WAAAA,eAAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB9C,QAAoD,OAAU,SAA+B;AAC3F,WAAAC,QAAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBhD,eAA2D,OAAU,SAAuC;AACjH,WAAOC,QAAAA,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW5C,QAAoD,SAAY,SAAkE;AAChI,WAAAC,QAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;;;"}
\ No newline at end of file
+{"version":3,"file":"createClient.cjs","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>> {\n    return request(route, { ...this.options, ...options }) as Promise<Data<T[K]>>\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options }) as Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":["fetch","request","attempt","connect"],"mappings":";;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWZ,MAAkC,OAAU,SAAyE;AACnH,WAAAA,QAAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB9C,QAAoC,OAAU,SAAqC;AACjF,WAAAC,QAAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBhD,eAA2C,OAAU,SAA6C;AACvG,WAAOC,QAAAA,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW5C,QAAoC,SAAY,SAA2E;AACzH,WAAAC,QAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;;;"}
\ No newline at end of file
diff --git a/dist/createClient.d.ts b/dist/createClient.d.ts
index d450b2fa7cd17547fa635d3c7505d772b0a21dfb..634706cb426fa1ff86bc627113730b7938fa5efb 100644
--- a/dist/createClient.d.ts
+++ b/dist/createClient.d.ts
@@ -1,8 +1,8 @@
 import { Awaitable } from '@unshared/functions';
 import { Result } from '@unshared/functions/attempt';
 import { ServiceOptions } from './createService.js';
-import { O as OpenAPILike, a as OpenAPIOptionsMap } from './chunks/mHfUAX_g.js';
-import { R as RequestOptions } from './chunks/CO11DuYE.js';
+import { O as OpenAPILike, a as OpenAPIOptionsMap } from './chunks/3E8iuIR5.js';
+import { R as RequestOptions } from './chunks/BZ5qrH6f.js';
 import { WebSocketChannel, ConnectOptions } from './websocket.js';
 import '@unshared/types';
 import 'openapi-types';
@@ -30,7 +30,9 @@ declare class Client<T extends Routes = Routes, U extends Channels = Channels> {
      * @param options The options to pass to the request.
      * @returns The response from the server.
      */
-    fetch<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Response>;
+    fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & {
+        json: () => Promise<Data<T[K]>>;
+    }>;
     /**
      * Fetch a route from the API and return the data. If the client was instantiated with an
      * application, the route name will be inferred from the application routes. Otherwise, you
@@ -49,7 +51,7 @@ declare class Client<T extends Routes = Routes, U extends Channels = Channels> {
      * // Fetch the data from the API.
      * const data = request('GET /api/product/:id', { data: { id: '1' } })
      */
-    request<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Data<V>>;
+    request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>>;
     /**
      * Attempt to fetch a route from the API and return the data. If the client was instantiated with an
      * application, the route name will be inferred from the application routes. Otherwise, you
@@ -70,7 +72,7 @@ declare class Client<T extends Routes = Routes, U extends Channels = Channels> {
      * if (error) console.error(error)
      * else console.log(data)
      */
-    requestAttempt<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Result<Data<V>>>;
+    requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>>;
     /**
      * Create a new WebSocket connection to the server with the given path. The connection will
      * automatically reconnect if the connection is closed unexpectedly.
@@ -79,7 +81,7 @@ declare class Client<T extends Routes = Routes, U extends Channels = Channels> {
      * @param options The options to pass to the connection.
      * @returns The WebSocket connection.
      */
-    connect<P extends keyof U & string, V extends U[P]>(channel: P, options?: V): Awaitable<WebSocketChannel<V>, WebSocketChannel<V>>;
+    connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>;
 }
 /**
  * Create a new type-safe client for the application. The client can be used to fetch data from
diff --git a/dist/createClient.js b/dist/createClient.js
index 9eb4d1ac5fff7a8103feca243ac61e661c7422e8..0ab8a04f7b336a23357bfbfc98c7bf80c0b537f8 100644
--- a/dist/createClient.js
+++ b/dist/createClient.js
@@ -1,8 +1,8 @@
 import { attempt } from "@unshared/functions/attempt";
-import { f as fetch } from "./chunks/BUeqbyph.js";
-import { r as request } from "./chunks/DJJsADWD.js";
-import { c as connect } from "./chunks/6IxvRpmY.js";
-import "./chunks/0ZzUT3m_.js";
+import { f as fetch, r as request } from "./chunks/2o4clKrH.js";
+import { c as connect } from "./chunks/Bys4-xE2.js";
+import "./chunks/BwI3JmT5.js";
+import "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
 import "@unshared/functions";
 class Client {
diff --git a/dist/createClient.js.map b/dist/createClient.js.map
index 43ec8c38f670de7fc114894017f0db2aff7a76f6..843ad2d0f8537704285cb249303f674f018a614b 100644
--- a/dist/createClient.js.map
+++ b/dist/createClient.js.map
@@ -1 +1 @@
-{"version":3,"file":"createClient.js","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Response> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Data<V>> {\n    return request(route, { ...this.options, ...options }) as Promise<Data<V>>\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string, V extends T[K]>(route: K, options?: V): Promise<Result<Data<V>>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string, V extends U[P]>(channel: P, options?: V): Awaitable<WebSocketChannel<V>, WebSocketChannel<V>> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options }) as Awaitable<WebSocketChannel<V>, WebSocketChannel<V>>\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":[],"mappings":";;;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWZ,MAAkD,OAAU,SAAgC;AAC1F,WAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB9C,QAAoD,OAAU,SAA+B;AAC3F,WAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBhD,eAA2D,OAAU,SAAuC;AACjH,WAAO,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW5C,QAAoD,SAAY,SAAkE;AAChI,WAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;"}
\ No newline at end of file
+{"version":3,"file":"createClient.js","sources":["../createClient.ts"],"sourcesContent":["import type { Awaitable } from '@unshared/functions'\nimport type { Result } from '@unshared/functions/attempt'\nimport type { ServiceOptions } from './createService'\nimport type { OpenAPILike, OpenAPIOptionsMap } from './openapi'\nimport type { RequestOptions } from './utils'\nimport type { ConnectOptions, WebSocketChannel } from './websocket'\nimport { attempt } from '@unshared/functions/attempt'\nimport { fetch } from './utils/fetch'\nimport { request } from './utils/request'\nimport { connect } from './websocket/connect'\n\ntype Data<T extends RequestOptions> = T extends RequestOptions<any, any, any, any, any, any, infer R, any> ? R : unknown\ntype Routes = Record<string, RequestOptions>\ntype Channels = Record<string, ConnectOptions>\n\nexport class Client<T extends Routes = Routes, U extends Channels = Channels> {\n\n  /**\n   * Create a new client for the application.\n   *\n   * @param options The options to pass to the client.\n   * @example new Client({ baseUrl: 'https://api.example.com' })\n   */\n  constructor(public options: RequestOptions = {}) {}\n\n  /**\n   * Fetch a route from the API and return the `Response` object. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The response from the server.\n   */\n  public fetch<K extends keyof T & string>(route: K, options?: T[K]): Promise<Response & { json: () => Promise<Data<T[K]>> }> {\n    return fetch(route, { ...this.options, ...options })\n  }\n\n  /**\n   * Fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns The data from the API.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const data = request('GET /api/product/:id', { data: { id: '1' } })\n   */\n  public request<K extends keyof T & string>(route: K, options?: T[K]): Promise<Data<T[K]>> {\n    return request(route, { ...this.options, ...options }) as Promise<Data<T[K]>>\n  }\n\n  /**\n   * Attempt to fetch a route from the API and return the data. If the client was instantiated with an\n   * application, the route name will be inferred from the application routes. Otherwise, you\n   * can pass the route name as a string.\n   *\n   * @param route The name of the route to fetch.\n   * @param options The options to pass to the request.\n   * @returns A result object with either the data or an error.\n   * @example\n   * // Declare the application type.\n   * type App = Application<[ModuleProduct]>\n   *\n   * // Create a type-safe client for the application.\n   * const request = createClient<App>()\n   *\n   * // Fetch the data from the API.\n   * const { data, error } = requestAttempt('GET /api/product/:id', { data: { id: '1' } })\n   * if (error) console.error(error)\n   * else console.log(data)\n   */\n  public requestAttempt<K extends keyof T & string>(route: K, options?: T[K]): Promise<Result<Data<T[K]>>> {\n    return attempt(() => this.request(route, options))\n  }\n\n  /**\n   * Create a new WebSocket connection to the server with the given path. The connection will\n   * automatically reconnect if the connection is closed unexpectedly.\n   *\n   * @param channel The path to connect to.\n   * @param options The options to pass to the connection.\n   * @returns The WebSocket connection.\n   */\n  public connect<P extends keyof U & string>(channel: P, options?: U[P]): Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>> {\n    return connect(channel, { baseUrl: this.options.baseUrl, ...options }) as Awaitable<WebSocketChannel<U[P]>, WebSocketChannel<U[P]>>\n  }\n}\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends OpenAPILike>(options?: ServiceOptions<T>): Client<OpenAPIOptionsMap<T>>\n\n/**\n * Create a new type-safe client for the application. The client can be used to fetch data from\n * the API and connect to the server using WebSockets with the given path.\n *\n * @param options The options to pass to the client.\n * @returns The client object with the request method.\n * @example\n * // Create a type-safe client for the application.\n * const client = createClient<[ModuleUser]>()\n *\n * // Fetch the data from the API.\n * const data = await client.request('GET /api/user/:id', { id: '1' })\n *\n * // Use the data from the API.\n * console.log(data) // { id: '1', name: 'John Doe' }\n */\nexport function createClient<T extends Routes = Routes, V extends Channels = Channels>(options?: RequestOptions): Client<T, V>\nexport function createClient(options?: RequestOptions): Client {\n  return new Client(options)\n}\n"],"names":[],"mappings":";;;;;;;AAeO,MAAM,OAAiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ5E,YAAmB,UAA0B,IAAI;AAA9B,SAAA,UAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWZ,MAAkC,OAAU,SAAyE;AACnH,WAAA,MAAM,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqB9C,QAAoC,OAAU,SAAqC;AACjF,WAAA,QAAQ,OAAO,EAAE,GAAG,KAAK,SAAS,GAAG,SAAS;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuBhD,eAA2C,OAAU,SAA6C;AACvG,WAAO,QAAQ,MAAM,KAAK,QAAQ,OAAO,OAAO,CAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAW5C,QAAoC,SAAY,SAA2E;AACzH,WAAA,QAAQ,SAAS,EAAE,SAAS,KAAK,QAAQ,SAAS,GAAG,SAAS;AAAA,EAAA;AAEzE;AAqCO,SAAS,aAAa,SAAkC;AACtD,SAAA,IAAI,OAAO,OAAO;AAC3B;"}
\ No newline at end of file
diff --git a/dist/createService.cjs b/dist/createService.cjs
index cc1b3917b03a26984455bdc838fe9bdbfa11bca3..e3324b720241d102dae7b8b162a7fef2cc11c6b4 100644
--- a/dist/createService.cjs
+++ b/dist/createService.cjs
@@ -1,12 +1,12 @@
 "use strict";
-var resolveOperation = require("./chunks/CtW2aMuA.cjs"), handleResponse = require("./chunks/Cayg8606.cjs");
-require("./chunks/CYmaYL5B.cjs");
+var resolveOperationTokenOptions = require("./chunks/DEyigyGy.cjs"), handleResponse = require("./chunks/B3X3mHFx.cjs");
+require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
 function createService(document, initialOptions) {
   return new Proxy({}, {
     get(_, id) {
       return async (data, options) => {
-        const baseUrl = resolveOperation.getServerUrl(document), operation = resolveOperation.resolveOperation(document, id), { method, path, responses = {} } = operation, response = await handleResponse.fetch(path, { method, baseUrl, data, ...initialOptions, ...options });
+        const baseUrl = resolveOperationTokenOptions.getServerUrl(document), operation = resolveOperationTokenOptions.resolveOperation(document, id), tokenOptions = resolveOperationTokenOptions.resolveOperationTokenOptions(document, operation), { method, path, responses = {} } = operation, { url, init } = handleResponse.parseRequest(path, { method, baseUrl, data, ...tokenOptions, ...initialOptions, ...options }), response = await globalThis.fetch(url, init);
         if (response.ok) return handleResponse.handleResponse(response, { ...initialOptions, ...options });
         const status = response.status.toString();
         throw status in responses && typeof responses[status] == "object" && responses[status] !== null && "description" in responses[status] && typeof responses[status].description == "string" ? new Error(responses[status].description) : new Error(response.statusText);
diff --git a/dist/createService.cjs.map b/dist/createService.cjs.map
index 10bd7f73a58d7043e0dad91510568935433f0ce3..409e858ff86048929cdb07fa3915b4b232b4110f 100644
--- a/dist/createService.cjs.map
+++ b/dist/createService.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createService.cjs","sources":["../createService.ts"],"sourcesContent":["import type { MaybeLiteral } from '@unshared/types'\nimport type { OpenAPIV3, Operation, OperationById, OperationId, OperationOptions, OperationResult, ServerUrl } from './openapi'\nimport type { RequestOptions } from './utils/request'\nimport { getServerUrl } from './openapi/getServerUrl'\nimport { resolveOperation } from './openapi/resolveOperation'\nimport { fetch } from './utils/fetch'\nimport { handleResponse } from './utils/handleResponse'\n\n/** A service instance for the given OpenAPI specification. */\nexport type Service<T> = {\n  [K in OperationId<T>]:\n  OperationById<T, K> extends infer U extends OperationById<T, K>\n    ? (data: OperationOptions<T, U>['data'], options?: OperationOptions<T, U>) => Promise<OperationResult<T, U>>\n    : never\n}\n\n/** The options to pass to the service client. */\nexport interface ServiceOptions<T = any> extends RequestOptions {\n  baseUrl?: MaybeLiteral<ServerUrl<T>>\n  headers?: T extends { openapi: string } ? OpenAPIV3.ServerHeaders<T> : never\n}\n\n/**\n * Create a new client instance for the given OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param initialOptions The initial options to use for every request.\n * @returns The client instance.\n * @example\n *\n * // Import the Giphy OpenAPI specification.\n * import Giphy from './giphy.openapi.json'\n *\n * // Create a new service instance for the Giphy API.\n * const service = createService(Giphy, { headers: { 'Bearer' } })\n *\n * // Request the \"searchGifs\" operation from the Giphy API.\n * await service.getGifs({ limit: 10, offset: 0, q: 'cats' }) // => { data: [...] }\n */\nexport function createService<T extends object>(document: Readonly<T>, initialOptions?: ServiceOptions<T>): Service<T> {\n  return new Proxy({}, {\n    get(_, id: OperationId<T>) {\n      return async(data: object, options: RequestOptions) => {\n\n        // --- Find the operation in the OpenAPI specification.\n        const baseUrl = getServerUrl(document)\n        const operation = resolveOperation(document, id) as Operation\n\n        // --- Fetch the relevant resource from the server.\n        const { method, path, responses = {} } = operation\n        const response = await fetch(path, { method, baseUrl, data, ...initialOptions, ...options })\n        if (response.ok) return handleResponse(response, { ...initialOptions, ...options })\n\n        // --- Throw an error if the response was not successful.\n        const status = response.status.toString()\n        if (status in responses\n          && typeof responses[status] === 'object'\n          && responses[status] !== null\n          && 'description' in responses[status]\n          && typeof responses[status].description === 'string')\n          throw new Error(responses[status].description)\n\n        // --- Throw a generic error if the response was not successful.\n        throw new Error(response.statusText)\n      }\n    },\n  }) as Service<T>\n}\n"],"names":["getServerUrl","resolveOperation","fetch","handleResponse"],"mappings":";;;;AAuCgB,SAAA,cAAgC,UAAuB,gBAAgD;AAC9G,SAAA,IAAI,MAAM,IAAI;AAAA,IACnB,IAAI,GAAG,IAAoB;AAClB,aAAA,OAAM,MAAc,YAA4B;AAGrD,cAAM,UAAUA,iBAAAA,aAAa,QAAQ,GAC/B,YAAYC,iBAAAA,iBAAiB,UAAU,EAAE,GAGzC,EAAE,QAAQ,MAAM,YAAY,GAAG,IAAI,WACnC,WAAW,MAAMC,eAAAA,MAAM,MAAM,EAAE,QAAQ,SAAS,MAAM,GAAG,gBAAgB,GAAG,SAAS;AACvF,YAAA,SAAS,GAAI,QAAOC,eAAe,eAAA,UAAU,EAAE,GAAG,gBAAgB,GAAG,SAAS;AAG5E,cAAA,SAAS,SAAS,OAAO,SAAS;AACxC,cAAI,UAAU,aACT,OAAO,UAAU,MAAM,KAAM,YAC7B,UAAU,MAAM,MAAM,QACtB,iBAAiB,UAAU,MAAM,KACjC,OAAO,UAAU,MAAM,EAAE,eAAgB,WACtC,IAAI,MAAM,UAAU,MAAM,EAAE,WAAW,IAGzC,IAAI,MAAM,SAAS,UAAU;AAAA,MACrC;AAAA,IAAA;AAAA,EACF,CACD;AACH;;"}
\ No newline at end of file
+{"version":3,"file":"createService.cjs","sources":["../createService.ts"],"sourcesContent":["import type { MaybeLiteral } from '@unshared/types'\nimport type { OpenAPIV3, Operation, OperationById, OperationId, OperationOptions, OperationResult, ServerUrl } from './openapi'\nimport type { RequestOptions } from './utils/request'\nimport { getServerUrl } from './openapi/getServerUrl'\nimport { resolveOperation } from './openapi/resolveOperation'\nimport { resolveOperationTokenOptions } from './openapi/resolveOperationTokenOptions'\nimport { handleResponse } from './utils/handleResponse'\nimport { parseRequest } from './utils/parseRequest'\n\n/** A service instance for the given OpenAPI specification. */\nexport type Service<T> = {\n  [K in OperationId<T>]:\n  OperationById<T, K> extends infer U extends OperationById<T, K>\n    ? (data: OperationOptions<T, U>['data'], options?: OperationOptions<T, U>) => Promise<OperationResult<T, U>>\n    : never\n}\n\n/** The options to pass to the service client. */\nexport interface ServiceOptions<T = any> extends RequestOptions {\n  baseUrl?: MaybeLiteral<ServerUrl<T>>\n  headers?: T extends { openapi: string } ? OpenAPIV3.ServerHeaders<T> : never\n}\n\n/**\n * Create a new client instance for the given OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param initialOptions The initial options to use for every request.\n * @returns The client instance.\n * @example\n *\n * // Import the Giphy OpenAPI specification.\n * import Giphy from './giphy.openapi.json'\n *\n * // Create a new service instance for the Giphy API.\n * const service = createService(Giphy, { headers: { 'Bearer' } })\n *\n * // Request the \"searchGifs\" operation from the Giphy API.\n * await service.getGifs({ limit: 10, offset: 0, q: 'cats' }) // => { data: [...] }\n */\nexport function createService<T extends object>(document: Readonly<T>, initialOptions?: ServiceOptions<T>): Service<T> {\n  return new Proxy({}, {\n    get(_, id: OperationId<T>) {\n      return async(data: object, options: RequestOptions) => {\n\n        // --- Find the operation in the OpenAPI specification.\n        const baseUrl = getServerUrl(document)\n        const operation = resolveOperation(document, id) as Operation\n        const tokenOptions = resolveOperationTokenOptions(document, operation)\n\n        // --- Fetch the relevant resource from the server.\n        const { method, path, responses = {} } = operation\n        const { url, init } = parseRequest(path, { method, baseUrl, data, ...tokenOptions, ...initialOptions, ...options })\n        const response = await globalThis.fetch(url, init)\n        if (response.ok) return handleResponse(response, { ...initialOptions, ...options })\n\n        // --- Throw an error if the response was not successful.\n        const status = response.status.toString()\n        if (status in responses\n          && typeof responses[status] === 'object'\n          && responses[status] !== null\n          && 'description' in responses[status]\n          && typeof responses[status].description === 'string')\n          throw new Error(responses[status].description)\n\n        // --- Throw a generic error if the response was not successful.\n        throw new Error(response.statusText)\n      }\n    },\n  }) as Service<T>\n}\n"],"names":["getServerUrl","resolveOperation","resolveOperationTokenOptions","parseRequest","handleResponse"],"mappings":";;;;AAwCgB,SAAA,cAAgC,UAAuB,gBAAgD;AAC9G,SAAA,IAAI,MAAM,IAAI;AAAA,IACnB,IAAI,GAAG,IAAoB;AAClB,aAAA,OAAM,MAAc,YAA4B;AAG/C,cAAA,UAAUA,0CAAa,QAAQ,GAC/B,YAAYC,8CAAiB,UAAU,EAAE,GACzC,eAAeC,6BAAAA,6BAA6B,UAAU,SAAS,GAG/D,EAAE,QAAQ,MAAM,YAAY,OAAO,WACnC,EAAE,KAAK,KAAA,IAASC,eAAAA,aAAa,MAAM,EAAE,QAAQ,SAAS,MAAM,GAAG,cAAc,GAAG,gBAAgB,GAAG,QAAS,CAAA,GAC5G,WAAW,MAAM,WAAW,MAAM,KAAK,IAAI;AAC7C,YAAA,SAAS,GAAI,QAAOC,eAAe,eAAA,UAAU,EAAE,GAAG,gBAAgB,GAAG,SAAS;AAG5E,cAAA,SAAS,SAAS,OAAO,SAAS;AACxC,cAAI,UAAU,aACT,OAAO,UAAU,MAAM,KAAM,YAC7B,UAAU,MAAM,MAAM,QACtB,iBAAiB,UAAU,MAAM,KACjC,OAAO,UAAU,MAAM,EAAE,eAAgB,WACtC,IAAI,MAAM,UAAU,MAAM,EAAE,WAAW,IAGzC,IAAI,MAAM,SAAS,UAAU;AAAA,MACrC;AAAA,IAAA;AAAA,EACF,CACD;AACH;;"}
\ No newline at end of file
diff --git a/dist/createService.d.ts b/dist/createService.d.ts
index c971a50adae9a94ea0a50edce0d1c36b359d0f39..213fce00d41cae7b571662c101e03c8487ee7696 100644
--- a/dist/createService.d.ts
+++ b/dist/createService.d.ts
@@ -1,6 +1,6 @@
 import { MaybeLiteral } from '@unshared/types';
-import { b as OperationId, c as OperationById, d as OperationOptions, e as OperationResult, S as ServerUrl, f as OpenAPIV3 } from './chunks/mHfUAX_g.js';
-import { R as RequestOptions } from './chunks/CO11DuYE.js';
+import { b as OperationId, c as OperationById, d as OperationOptions, e as OperationResult, S as ServerUrl, f as OpenAPIV3 } from './chunks/3E8iuIR5.js';
+import { R as RequestOptions } from './chunks/BZ5qrH6f.js';
 import 'openapi-types';
 import './HttpHeaders.js';
 import './HttpMethods.js';
diff --git a/dist/createService.js b/dist/createService.js
index 1fbcf1e36da41da7ac64a2e079f6bdd9ed63abdb..dedf8076349ee6f7a0f1f7986e17746378ed5988 100644
--- a/dist/createService.js
+++ b/dist/createService.js
@@ -1,12 +1,12 @@
-import { g as getServerUrl, r as resolveOperation } from "./chunks/Biic1J5b.js";
-import { f as fetch, h as handleResponse } from "./chunks/BUeqbyph.js";
-import "./chunks/0ZzUT3m_.js";
+import { g as getServerUrl, r as resolveOperation, a as resolveOperationTokenOptions } from "./chunks/B_Gz6Yz8.js";
+import { p as parseRequest, h as handleResponse } from "./chunks/BwI3JmT5.js";
+import "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
 function createService(document, initialOptions) {
   return new Proxy({}, {
     get(_, id) {
       return async (data, options) => {
-        const baseUrl = getServerUrl(document), operation = resolveOperation(document, id), { method, path, responses = {} } = operation, response = await fetch(path, { method, baseUrl, data, ...initialOptions, ...options });
+        const baseUrl = getServerUrl(document), operation = resolveOperation(document, id), tokenOptions = resolveOperationTokenOptions(document, operation), { method, path, responses = {} } = operation, { url, init } = parseRequest(path, { method, baseUrl, data, ...tokenOptions, ...initialOptions, ...options }), response = await globalThis.fetch(url, init);
         if (response.ok) return handleResponse(response, { ...initialOptions, ...options });
         const status = response.status.toString();
         throw status in responses && typeof responses[status] == "object" && responses[status] !== null && "description" in responses[status] && typeof responses[status].description == "string" ? new Error(responses[status].description) : new Error(response.statusText);
diff --git a/dist/createService.js.map b/dist/createService.js.map
index b73171552dae3ef452f13ce68bd767177ee123fb..b8e1b84a6cb2d32ea9d63a8cac132da67fd100ef 100644
--- a/dist/createService.js.map
+++ b/dist/createService.js.map
@@ -1 +1 @@
-{"version":3,"file":"createService.js","sources":["../createService.ts"],"sourcesContent":["import type { MaybeLiteral } from '@unshared/types'\nimport type { OpenAPIV3, Operation, OperationById, OperationId, OperationOptions, OperationResult, ServerUrl } from './openapi'\nimport type { RequestOptions } from './utils/request'\nimport { getServerUrl } from './openapi/getServerUrl'\nimport { resolveOperation } from './openapi/resolveOperation'\nimport { fetch } from './utils/fetch'\nimport { handleResponse } from './utils/handleResponse'\n\n/** A service instance for the given OpenAPI specification. */\nexport type Service<T> = {\n  [K in OperationId<T>]:\n  OperationById<T, K> extends infer U extends OperationById<T, K>\n    ? (data: OperationOptions<T, U>['data'], options?: OperationOptions<T, U>) => Promise<OperationResult<T, U>>\n    : never\n}\n\n/** The options to pass to the service client. */\nexport interface ServiceOptions<T = any> extends RequestOptions {\n  baseUrl?: MaybeLiteral<ServerUrl<T>>\n  headers?: T extends { openapi: string } ? OpenAPIV3.ServerHeaders<T> : never\n}\n\n/**\n * Create a new client instance for the given OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param initialOptions The initial options to use for every request.\n * @returns The client instance.\n * @example\n *\n * // Import the Giphy OpenAPI specification.\n * import Giphy from './giphy.openapi.json'\n *\n * // Create a new service instance for the Giphy API.\n * const service = createService(Giphy, { headers: { 'Bearer' } })\n *\n * // Request the \"searchGifs\" operation from the Giphy API.\n * await service.getGifs({ limit: 10, offset: 0, q: 'cats' }) // => { data: [...] }\n */\nexport function createService<T extends object>(document: Readonly<T>, initialOptions?: ServiceOptions<T>): Service<T> {\n  return new Proxy({}, {\n    get(_, id: OperationId<T>) {\n      return async(data: object, options: RequestOptions) => {\n\n        // --- Find the operation in the OpenAPI specification.\n        const baseUrl = getServerUrl(document)\n        const operation = resolveOperation(document, id) as Operation\n\n        // --- Fetch the relevant resource from the server.\n        const { method, path, responses = {} } = operation\n        const response = await fetch(path, { method, baseUrl, data, ...initialOptions, ...options })\n        if (response.ok) return handleResponse(response, { ...initialOptions, ...options })\n\n        // --- Throw an error if the response was not successful.\n        const status = response.status.toString()\n        if (status in responses\n          && typeof responses[status] === 'object'\n          && responses[status] !== null\n          && 'description' in responses[status]\n          && typeof responses[status].description === 'string')\n          throw new Error(responses[status].description)\n\n        // --- Throw a generic error if the response was not successful.\n        throw new Error(response.statusText)\n      }\n    },\n  }) as Service<T>\n}\n"],"names":[],"mappings":";;;;AAuCgB,SAAA,cAAgC,UAAuB,gBAAgD;AAC9G,SAAA,IAAI,MAAM,IAAI;AAAA,IACnB,IAAI,GAAG,IAAoB;AAClB,aAAA,OAAM,MAAc,YAA4B;AAGrD,cAAM,UAAU,aAAa,QAAQ,GAC/B,YAAY,iBAAiB,UAAU,EAAE,GAGzC,EAAE,QAAQ,MAAM,YAAY,GAAG,IAAI,WACnC,WAAW,MAAM,MAAM,MAAM,EAAE,QAAQ,SAAS,MAAM,GAAG,gBAAgB,GAAG,SAAS;AACvF,YAAA,SAAS,GAAI,QAAO,eAAe,UAAU,EAAE,GAAG,gBAAgB,GAAG,SAAS;AAG5E,cAAA,SAAS,SAAS,OAAO,SAAS;AACxC,cAAI,UAAU,aACT,OAAO,UAAU,MAAM,KAAM,YAC7B,UAAU,MAAM,MAAM,QACtB,iBAAiB,UAAU,MAAM,KACjC,OAAO,UAAU,MAAM,EAAE,eAAgB,WACtC,IAAI,MAAM,UAAU,MAAM,EAAE,WAAW,IAGzC,IAAI,MAAM,SAAS,UAAU;AAAA,MACrC;AAAA,IAAA;AAAA,EACF,CACD;AACH;"}
\ No newline at end of file
+{"version":3,"file":"createService.js","sources":["../createService.ts"],"sourcesContent":["import type { MaybeLiteral } from '@unshared/types'\nimport type { OpenAPIV3, Operation, OperationById, OperationId, OperationOptions, OperationResult, ServerUrl } from './openapi'\nimport type { RequestOptions } from './utils/request'\nimport { getServerUrl } from './openapi/getServerUrl'\nimport { resolveOperation } from './openapi/resolveOperation'\nimport { resolveOperationTokenOptions } from './openapi/resolveOperationTokenOptions'\nimport { handleResponse } from './utils/handleResponse'\nimport { parseRequest } from './utils/parseRequest'\n\n/** A service instance for the given OpenAPI specification. */\nexport type Service<T> = {\n  [K in OperationId<T>]:\n  OperationById<T, K> extends infer U extends OperationById<T, K>\n    ? (data: OperationOptions<T, U>['data'], options?: OperationOptions<T, U>) => Promise<OperationResult<T, U>>\n    : never\n}\n\n/** The options to pass to the service client. */\nexport interface ServiceOptions<T = any> extends RequestOptions {\n  baseUrl?: MaybeLiteral<ServerUrl<T>>\n  headers?: T extends { openapi: string } ? OpenAPIV3.ServerHeaders<T> : never\n}\n\n/**\n * Create a new client instance for the given OpenAPI specification.\n *\n * @param document The OpenAPI specification document.\n * @param initialOptions The initial options to use for every request.\n * @returns The client instance.\n * @example\n *\n * // Import the Giphy OpenAPI specification.\n * import Giphy from './giphy.openapi.json'\n *\n * // Create a new service instance for the Giphy API.\n * const service = createService(Giphy, { headers: { 'Bearer' } })\n *\n * // Request the \"searchGifs\" operation from the Giphy API.\n * await service.getGifs({ limit: 10, offset: 0, q: 'cats' }) // => { data: [...] }\n */\nexport function createService<T extends object>(document: Readonly<T>, initialOptions?: ServiceOptions<T>): Service<T> {\n  return new Proxy({}, {\n    get(_, id: OperationId<T>) {\n      return async(data: object, options: RequestOptions) => {\n\n        // --- Find the operation in the OpenAPI specification.\n        const baseUrl = getServerUrl(document)\n        const operation = resolveOperation(document, id) as Operation\n        const tokenOptions = resolveOperationTokenOptions(document, operation)\n\n        // --- Fetch the relevant resource from the server.\n        const { method, path, responses = {} } = operation\n        const { url, init } = parseRequest(path, { method, baseUrl, data, ...tokenOptions, ...initialOptions, ...options })\n        const response = await globalThis.fetch(url, init)\n        if (response.ok) return handleResponse(response, { ...initialOptions, ...options })\n\n        // --- Throw an error if the response was not successful.\n        const status = response.status.toString()\n        if (status in responses\n          && typeof responses[status] === 'object'\n          && responses[status] !== null\n          && 'description' in responses[status]\n          && typeof responses[status].description === 'string')\n          throw new Error(responses[status].description)\n\n        // --- Throw a generic error if the response was not successful.\n        throw new Error(response.statusText)\n      }\n    },\n  }) as Service<T>\n}\n"],"names":[],"mappings":";;;;AAwCgB,SAAA,cAAgC,UAAuB,gBAAgD;AAC9G,SAAA,IAAI,MAAM,IAAI;AAAA,IACnB,IAAI,GAAG,IAAoB;AAClB,aAAA,OAAM,MAAc,YAA4B;AAG/C,cAAA,UAAU,aAAa,QAAQ,GAC/B,YAAY,iBAAiB,UAAU,EAAE,GACzC,eAAe,6BAA6B,UAAU,SAAS,GAG/D,EAAE,QAAQ,MAAM,YAAY,OAAO,WACnC,EAAE,KAAK,KAAA,IAAS,aAAa,MAAM,EAAE,QAAQ,SAAS,MAAM,GAAG,cAAc,GAAG,gBAAgB,GAAG,QAAS,CAAA,GAC5G,WAAW,MAAM,WAAW,MAAM,KAAK,IAAI;AAC7C,YAAA,SAAS,GAAI,QAAO,eAAe,UAAU,EAAE,GAAG,gBAAgB,GAAG,SAAS;AAG5E,cAAA,SAAS,SAAS,OAAO,SAAS;AACxC,cAAI,UAAU,aACT,OAAO,UAAU,MAAM,KAAM,YAC7B,UAAU,MAAM,MAAM,QACtB,iBAAiB,UAAU,MAAM,KACjC,OAAO,UAAU,MAAM,EAAE,eAAgB,WACtC,IAAI,MAAM,UAAU,MAAM,EAAE,WAAW,IAGzC,IAAI,MAAM,SAAS,UAAU;AAAA,MACrC;AAAA,IAAA;AAAA,EACF,CACD;AACH;"}
\ No newline at end of file
diff --git a/dist/index.cjs b/dist/index.cjs
index a8c494f3472638d2b4ba755b1bd093b19b141e38..a65ca6978ee43981c5f6755278d8437fb5803bef 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -1,13 +1,13 @@
 "use strict";
 var createClient = require("./createClient.cjs"), createService = require("./createService.cjs"), HttpHeaders = require("./HttpHeaders.cjs"), HttpMethods = require("./HttpMethods.cjs"), HttpStatusCodes = require("./HttpStatusCodes.cjs");
 require("@unshared/functions/attempt");
-require("./chunks/Cayg8606.cjs");
-require("./chunks/CYmaYL5B.cjs");
+require("./chunks/YA_gLiBm.cjs");
+require("./chunks/B3X3mHFx.cjs");
+require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
-require("./chunks/Du_W5H6e.cjs");
-require("./chunks/BMbsYNBd.cjs");
+require("./chunks/BdFNzMcu.cjs");
 require("@unshared/functions");
-require("./chunks/CtW2aMuA.cjs");
+require("./chunks/DEyigyGy.cjs");
 exports.Client = createClient.Client;
 exports.createClient = createClient.createClient;
 exports.createService = createService.createService;
diff --git a/dist/index.d.ts b/dist/index.d.ts
index f7327ccbef0bd243288bc5655ebf9d78bf5916fa..1a594e24ac35b8098e30437eefc65d28029a070b 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -5,8 +5,8 @@ export { HttpMethod } from './HttpMethods.js';
 export { HttpStatusCode } from './HttpStatusCodes.js';
 import '@unshared/functions';
 import '@unshared/functions/attempt';
-import './chunks/mHfUAX_g.js';
+import './chunks/3E8iuIR5.js';
 import '@unshared/types';
-import './chunks/CO11DuYE.js';
+import './chunks/BZ5qrH6f.js';
 import 'openapi-types';
 import './websocket.js';
diff --git a/dist/index.js b/dist/index.js
index c316f401f0708d4da90fc041c2d42ff267d9deff..ba39dd75637102bb7f31cf26540c5dd0bcf0dab9 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -4,13 +4,13 @@ import { HttpHeader } from "./HttpHeaders.js";
 import { HttpMethod } from "./HttpMethods.js";
 import { HttpStatusCode } from "./HttpStatusCodes.js";
 import "@unshared/functions/attempt";
-import "./chunks/BUeqbyph.js";
-import "./chunks/0ZzUT3m_.js";
+import "./chunks/2o4clKrH.js";
+import "./chunks/BwI3JmT5.js";
+import "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
-import "./chunks/DJJsADWD.js";
-import "./chunks/6IxvRpmY.js";
+import "./chunks/Bys4-xE2.js";
 import "@unshared/functions";
-import "./chunks/Biic1J5b.js";
+import "./chunks/B_Gz6Yz8.js";
 export {
   Client,
   HttpHeader,
diff --git a/dist/openapi.cjs b/dist/openapi.cjs
index d1106e8f91892cc4ae042a11758d97c2e977ea8e..7777c8d79a12ff749438026a1bf3f8c774690605 100644
--- a/dist/openapi.cjs
+++ b/dist/openapi.cjs
@@ -1,5 +1,11 @@
 "use strict";
-var resolveOperation = require("./chunks/CtW2aMuA.cjs");
+var resolveOperationTokenOptions = require("./chunks/DEyigyGy.cjs");
+function isOpenAPIV2(value) {
+  return typeof value == "object" && value !== null && "swagger" in value && value.swagger === "2.0";
+}
+function isOpenAPIV3_1(value) {
+  return typeof value == "object" && value !== null && "openapi" in value && value.openapi === "3.1.0";
+}
 function isReferenceObject(value) {
   return typeof value == "object" && value !== null && "$ref" in value && typeof value.$ref == "string";
 }
@@ -27,8 +33,12 @@ function resolveDocument(value, document = value) {
     }
   });
 }
-exports.getServerUrl = resolveOperation.getServerUrl;
-exports.resolveOperation = resolveOperation.resolveOperation;
+exports.getServerUrl = resolveOperationTokenOptions.getServerUrl;
+exports.isOpenAPIV3 = resolveOperationTokenOptions.isOpenAPIV3;
+exports.resolveOperation = resolveOperationTokenOptions.resolveOperation;
+exports.resolveOperationTokenOptions = resolveOperationTokenOptions.resolveOperationTokenOptions;
+exports.isOpenAPIV2 = isOpenAPIV2;
+exports.isOpenAPIV3_1 = isOpenAPIV3_1;
 exports.isReferenceObject = isReferenceObject;
 exports.resolveDocument = resolveDocument;
 exports.resolveReference = resolveReference;
diff --git a/dist/openapi.cjs.map b/dist/openapi.cjs.map
index 62f298b5120a0604d44bc54a483922bbb9769157..f3e2afd2266a5143441e822144bcde5f1e67c6b4 100644
--- a/dist/openapi.cjs.map
+++ b/dist/openapi.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"openapi.cjs","sources":["../openapi/isReferenceObject.ts","../openapi/resolveReference.ts","../openapi/resolveDocument.ts"],"sourcesContent":["import type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'\n\nexport type OpenAPIReference =\n  | OpenAPIV2.ReferenceObject\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject\n\n/**\n * Check if a value is an {@linkcode OpenAPIReference}.\n *\n * @param value The value to check.\n * @returns `true` if the value is a reference object.\n * @example isReferenceObject({ $ref: '#/components/schemas/MySchema' }) // true\n */\nexport function isReferenceObject<T extends OpenAPIReference>(value: unknown): value is T {\n  return typeof value === 'object'\n    && value !== null\n    && '$ref' in value\n    && typeof value.$ref === 'string'\n}\n","import type { StringJoin, StringReplace, WriteableDeep } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport { isReferenceObject } from './isReferenceObject'\n\n/**\n * Decode an OpenAPI reference path by replacing the encoded characters with\n * their original values. This function will replace `~0` with `~` and `~1`\n * with `/`.\n *\n * @example DecodeReference<'#/foo~1bar~0baz'> // '#/foo/bar~baz'\n */\nexport type OpenAPIReferenceDecoded<T extends string> =\n  StringReplace<StringReplace<T, '~0', '~'>, '~1', '/'>\n\n/**\n * Extract the parts of a reference path as a tuple.\n *\n * @example OpenAPIV3ReferencePath<'#/paths/~1users~1{username}'> // ['paths', '/users/{username}']\n */\nexport type OpenAPIReferencePath<T extends string> =\n  T extends `#/${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n    : T extends `#/${infer P}` ? [P]\n      : T extends `${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n        : T extends `${infer P}` ? [P]\n          : []\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The result type.\n * @example Resolved<{ $ref: '#/info' }, { info: { title: string } }> // { title: string }\n */\nexport type OpenAPIReferenceResolved<\n  T extends OpenAPIReference,\n  D extends object,\n> =\n  D extends object\n    ? T extends { $ref: infer R extends string }\n\n      // --- Match last part of the reference.\n      ? OpenAPIReferencePath<R> extends [infer P extends string]\n        ? OpenAPIReferenceDecoded<P> extends keyof D\n          ? D[OpenAPIReferenceDecoded<P>] extends object\n            ? WriteableDeep<Omit<D[OpenAPIReferenceDecoded<P>], keyof T>>\n            : never\n          : never\n\n        // --- Match middle part of the reference.\n        : OpenAPIReferencePath<R> extends [infer P extends string, ...infer Rest extends string[]]\n          ? OpenAPIReferenceDecoded<P> extends keyof D\n            ? D[OpenAPIReferenceDecoded<P>] extends object\n              ? OpenAPIReferenceResolved<{ $ref: StringJoin<Rest, '/'> }, D[OpenAPIReferenceDecoded<P>]>\n              : never\n            : never\n          : never\n      : never\n    : never\n\n/**\n * Resolve an OpenAPI `ReferenceObject` to the component it references. If the\n * source is not a reference, the source will be returned.\n *\n * @private\n * @param reference The reference object to resolve.\n * @param document The OpenAPI document to resolve the reference from.\n * @returns The result component.\n * @example resolveReference({ $ref: '#/components/schemas/User' }, document)\n */\nexport function resolveReference<\n  T extends OpenAPIReference,\n  D extends object,\n>(reference: Readonly<T>, document: Readonly<D>): OpenAPIReferenceResolved<T, D> {\n\n  // --- Return the source if it is not a reference.\n  if (!isReferenceObject(reference))\n    throw new TypeError('Expected value to be an OpenAPI reference object.')\n\n  // --- Assert that the parameters are valid.\n  if (typeof document !== 'object' || document === null)\n    throw new TypeError('Expected OpenAPI specification to be an object.')\n\n  // --- Resolve the component with it's reference path.\n  const referenceParts = reference.$ref.replace(/^#\\//, '').split('/')\n  let result = document\n  for (const part of referenceParts) {\n    if (result === undefined) break\n    if (typeof result !== 'object' || result === null) break\n    const key = part.replaceAll('~1', '/').replaceAll('~0', '~')\n    // @ts-expect-error: assume the part is a key of the object.\n    result = result[key] as unknown\n  }\n\n  // --- Throw an error if the component could not be result.\n  if (result === undefined)\n    throw new Error(`Could not resolve OpenAPI component: ${reference.$ref}`)\n\n  // --- Return the result component.\n  return result as OpenAPIReferenceResolved<T, D>\n}\n","import type { ObjectLike, Substract } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport type { OpenAPIReferenceResolved } from './resolveReference'\nimport { isReferenceObject } from './isReferenceObject'\nimport { resolveReference as resolveReference } from './resolveReference'\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The resolved type.\n * @example\n * type Resolved = OpenAPIResolved<{\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' }\n *     }\n *   }\n * }>\n */\nexport type OpenAPIResolved<T, D = T, N extends number = 8> =\n  N extends 0 ? T\n    : T extends OpenAPIReference\n      ? D extends object ? OpenAPIResolved<OpenAPIReferenceResolved<T, D>, D, Substract<N, 1>> : never\n      : T extends object ? { -readonly [K in keyof T]: OpenAPIResolved<T[K], D, N> } : T\n\n/**\n * Recursively resolve all references in an OpenAPI specification. This function\n * will return a `Proxy` object that will resolve references on the fly.\n *\n * @param value The OpenAPI specification.\n * @returns The resolved OpenAPI specification.\n * @example\n * const resolved = resolveReferences({\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' },\n *     },\n *   },\n * })\n */\nexport function resolveDocument<T extends object>(value: Readonly<T>): OpenAPIResolved<T>\nexport function resolveDocument<T extends object, D>(value: Readonly<T>, document: Readonly<D>): OpenAPIResolved<T, D>\nexport function resolveDocument(value: Readonly<ObjectLike>, document = value): unknown {\n  return new Proxy(value, {\n    get(target, property: string) {\n      let value = target[property]\n\n      // --- Abort if no document is provided.\n      if (!document) return value\n\n      // --- Resolve the reference if it is a reference object.\n      if (isReferenceObject(value))\n        value = resolveReference(value, document)\n\n      // --- Recursively resolve references in objects.\n      if (typeof value === 'object' && value !== null)\n        return resolveDocument(value as ObjectLike, document)\n\n      // --- Return the value as is.\n      return value\n    },\n  })\n}\n"],"names":["value"],"mappings":";;AAcO,SAAS,kBAA8C,OAA4B;AACjF,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,UAAU,SACV,OAAO,MAAM,QAAS;AAC7B;ACmDgB,SAAA,iBAGd,WAAwB,UAAuD;AAG3E,MAAA,CAAC,kBAAkB,SAAS;AACxB,UAAA,IAAI,UAAU,mDAAmD;AAGrE,MAAA,OAAO,YAAa,YAAY,aAAa;AACzC,UAAA,IAAI,UAAU,iDAAiD;AAGjE,QAAA,iBAAiB,UAAU,KAAK,QAAQ,QAAQ,EAAE,EAAE,MAAM,GAAG;AACnE,MAAI,SAAS;AACb,aAAW,QAAQ,gBAAgB;AAEjC,QADI,WAAW,UACX,OAAO,UAAW,YAAY,WAAW,KAAM;AAC7C,UAAA,MAAM,KAAK,WAAW,MAAM,GAAG,EAAE,WAAW,MAAM,GAAG;AAE3D,aAAS,OAAO,GAAG;AAAA,EAAA;AAIrB,MAAI,WAAW;AACb,UAAM,IAAI,MAAM,wCAAwC,UAAU,IAAI,EAAE;AAGnE,SAAA;AACT;ACtDgB,SAAA,gBAAgB,OAA6B,WAAW,OAAgB;AAC/E,SAAA,IAAI,MAAM,OAAO;AAAA,IACtB,IAAI,QAAQ,UAAkB;AACxBA,UAAAA,SAAQ,OAAO,QAAQ;AAG3B,aAAK,YAGD,kBAAkBA,MAAK,MACzBA,SAAQ,iBAAiBA,QAAO,QAAQ,IAGtC,OAAOA,UAAU,YAAYA,WAAU,OAClC,gBAAgBA,QAAqB,QAAQ,IAG/CA,UAXeA;AAAAA,IAAA;AAAA,EAYxB,CACD;AACH;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"openapi.cjs","sources":["../openapi/isOpenAPIV2.ts","../openapi/isOpenAPIV3_1.ts","../openapi/isReferenceObject.ts","../openapi/resolveReference.ts","../openapi/resolveDocument.ts"],"sourcesContent":["/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV2 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v2 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v2 specification, `false` otherwise.\n * @example isOpenAPIV2({ swagger: '2.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV2(value: unknown): value is OpenAPIV2.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'swagger' in value\n    && value.swagger === '2.0'\n}\n","/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV3_1 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v3.1 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v3.1 specification, `false` otherwise.\n * @example isOpenAPIV3_1({ openapi: '3.1.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV3_1(value: unknown): value is OpenAPIV3_1.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'openapi' in value\n    && value.openapi === '3.1.0'\n}\n","import type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'\n\nexport type OpenAPIReference =\n  | OpenAPIV2.ReferenceObject\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject\n\n/**\n * Check if a value is an {@linkcode OpenAPIReference}.\n *\n * @param value The value to check.\n * @returns `true` if the value is a reference object.\n * @example isReferenceObject({ $ref: '#/components/schemas/MySchema' }) // true\n */\nexport function isReferenceObject<T extends OpenAPIReference>(value: unknown): value is T {\n  return typeof value === 'object'\n    && value !== null\n    && '$ref' in value\n    && typeof value.$ref === 'string'\n}\n","import type { StringJoin, StringReplace, WriteableDeep } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport { isReferenceObject } from './isReferenceObject'\n\n/**\n * Decode an OpenAPI reference path by replacing the encoded characters with\n * their original values. This function will replace `~0` with `~` and `~1`\n * with `/`.\n *\n * @example DecodeReference<'#/foo~1bar~0baz'> // '#/foo/bar~baz'\n */\nexport type OpenAPIReferenceDecoded<T extends string> =\n  StringReplace<StringReplace<T, '~0', '~'>, '~1', '/'>\n\n/**\n * Extract the parts of a reference path as a tuple.\n *\n * @example OpenAPIV3ReferencePath<'#/paths/~1users~1{username}'> // ['paths', '/users/{username}']\n */\nexport type OpenAPIReferencePath<T extends string> =\n  T extends `#/${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n    : T extends `#/${infer P}` ? [P]\n      : T extends `${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n        : T extends `${infer P}` ? [P]\n          : []\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The result type.\n * @example Resolved<{ $ref: '#/info' }, { info: { title: string } }> // { title: string }\n */\nexport type OpenAPIReferenceResolved<\n  T extends OpenAPIReference,\n  D extends object,\n> =\n  D extends object\n    ? T extends { $ref: infer R extends string }\n\n      // --- Match last part of the reference.\n      ? OpenAPIReferencePath<R> extends [infer P extends string]\n        ? OpenAPIReferenceDecoded<P> extends keyof D\n          ? D[OpenAPIReferenceDecoded<P>] extends object\n            ? WriteableDeep<Omit<D[OpenAPIReferenceDecoded<P>], keyof T>>\n            : never\n          : never\n\n        // --- Match middle part of the reference.\n        : OpenAPIReferencePath<R> extends [infer P extends string, ...infer Rest extends string[]]\n          ? OpenAPIReferenceDecoded<P> extends keyof D\n            ? D[OpenAPIReferenceDecoded<P>] extends object\n              ? OpenAPIReferenceResolved<{ $ref: StringJoin<Rest, '/'> }, D[OpenAPIReferenceDecoded<P>]>\n              : never\n            : never\n          : never\n      : never\n    : never\n\n/**\n * Resolve an OpenAPI `ReferenceObject` to the component it references. If the\n * source is not a reference, the source will be returned.\n *\n * @private\n * @param reference The reference object to resolve.\n * @param document The OpenAPI document to resolve the reference from.\n * @returns The result component.\n * @example resolveReference({ $ref: '#/components/schemas/User' }, document)\n */\nexport function resolveReference<\n  T extends OpenAPIReference,\n  D extends object,\n>(reference: Readonly<T>, document: Readonly<D>): OpenAPIReferenceResolved<T, D> {\n\n  // --- Return the source if it is not a reference.\n  if (!isReferenceObject(reference))\n    throw new TypeError('Expected value to be an OpenAPI reference object.')\n\n  // --- Assert that the parameters are valid.\n  if (typeof document !== 'object' || document === null)\n    throw new TypeError('Expected OpenAPI specification to be an object.')\n\n  // --- Resolve the component with it's reference path.\n  const referenceParts = reference.$ref.replace(/^#\\//, '').split('/')\n  let result = document\n  for (const part of referenceParts) {\n    if (result === undefined) break\n    if (typeof result !== 'object' || result === null) break\n    const key = part.replaceAll('~1', '/').replaceAll('~0', '~')\n    // @ts-expect-error: assume the part is a key of the object.\n    result = result[key] as unknown\n  }\n\n  // --- Throw an error if the component could not be result.\n  if (result === undefined)\n    throw new Error(`Could not resolve OpenAPI component: ${reference.$ref}`)\n\n  // --- Return the result component.\n  return result as OpenAPIReferenceResolved<T, D>\n}\n","import type { ObjectLike, Substract } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport type { OpenAPIReferenceResolved } from './resolveReference'\nimport { isReferenceObject } from './isReferenceObject'\nimport { resolveReference as resolveReference } from './resolveReference'\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The resolved type.\n * @example\n * type Resolved = OpenAPIResolved<{\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' }\n *     }\n *   }\n * }>\n */\nexport type OpenAPIResolved<T, D = T, N extends number = 8> =\n  N extends 0 ? T\n    : T extends OpenAPIReference\n      ? D extends object ? OpenAPIResolved<OpenAPIReferenceResolved<T, D>, D, Substract<N, 1>> : never\n      : T extends object ? { -readonly [K in keyof T]: OpenAPIResolved<T[K], D, N> } : T\n\n/**\n * Recursively resolve all references in an OpenAPI specification. This function\n * will return a `Proxy` object that will resolve references on the fly.\n *\n * @param value The OpenAPI specification.\n * @returns The resolved OpenAPI specification.\n * @example\n * const resolved = resolveReferences({\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' },\n *     },\n *   },\n * })\n */\nexport function resolveDocument<T extends object>(value: Readonly<T>): OpenAPIResolved<T>\nexport function resolveDocument<T extends object, D>(value: Readonly<T>, document: Readonly<D>): OpenAPIResolved<T, D>\nexport function resolveDocument(value: Readonly<ObjectLike>, document = value): unknown {\n  return new Proxy(value, {\n    get(target, property: string) {\n      let value = target[property]\n\n      // --- Abort if no document is provided.\n      if (!document) return value\n\n      // --- Resolve the reference if it is a reference object.\n      if (isReferenceObject(value))\n        value = resolveReference(value, document)\n\n      // --- Recursively resolve references in objects.\n      if (typeof value === 'object' && value !== null)\n        return resolveDocument(value as ObjectLike, document)\n\n      // --- Return the value as is.\n      return value\n    },\n  })\n}\n"],"names":["value"],"mappings":";;AAUO,SAAS,YAAY,OAA6C;AAChE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACLO,SAAS,cAAc,OAA+C;AACpE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACDO,SAAS,kBAA8C,OAA4B;AACjF,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,UAAU,SACV,OAAO,MAAM,QAAS;AAC7B;ACmDgB,SAAA,iBAGd,WAAwB,UAAuD;AAG3E,MAAA,CAAC,kBAAkB,SAAS;AACxB,UAAA,IAAI,UAAU,mDAAmD;AAGrE,MAAA,OAAO,YAAa,YAAY,aAAa;AACzC,UAAA,IAAI,UAAU,iDAAiD;AAGjE,QAAA,iBAAiB,UAAU,KAAK,QAAQ,QAAQ,EAAE,EAAE,MAAM,GAAG;AACnE,MAAI,SAAS;AACb,aAAW,QAAQ,gBAAgB;AAEjC,QADI,WAAW,UACX,OAAO,UAAW,YAAY,WAAW,KAAM;AAC7C,UAAA,MAAM,KAAK,WAAW,MAAM,GAAG,EAAE,WAAW,MAAM,GAAG;AAE3D,aAAS,OAAO,GAAG;AAAA,EAAA;AAIrB,MAAI,WAAW;AACb,UAAM,IAAI,MAAM,wCAAwC,UAAU,IAAI,EAAE;AAGnE,SAAA;AACT;ACtDgB,SAAA,gBAAgB,OAA6B,WAAW,OAAgB;AAC/E,SAAA,IAAI,MAAM,OAAO;AAAA,IACtB,IAAI,QAAQ,UAAkB;AACxBA,UAAAA,SAAQ,OAAO,QAAQ;AAG3B,aAAK,YAGD,kBAAkBA,MAAK,MACzBA,SAAQ,iBAAiBA,QAAO,QAAQ,IAGtC,OAAOA,UAAU,YAAYA,WAAU,OAClC,gBAAgBA,QAAqB,QAAQ,IAG/CA,UAXeA;AAAAA,IAAA;AAAA,EAYxB,CACD;AACH;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/openapi.d.ts b/dist/openapi.d.ts
index 812b25d931d079bb94dc6efd5031f7243360a409..b7e0246d15a0f8feab38c1da86630049fd25c0a2 100644
--- a/dist/openapi.d.ts
+++ b/dist/openapi.d.ts
@@ -1,10 +1,37 @@
-export { O as OpenAPILike, a as OpenAPIOptionsMap, h as OpenAPIV2, j as OpenAPIV2Like, f as OpenAPIV3, k as OpenAPIV3Like, i as Operation, c as OperationById, n as OperationByRoute, b as OperationId, d as OperationOptions, l as OperationResponse, e as OperationResult, m as OperationRoute, S as ServerUrl, g as getServerUrl, r as resolveOperation } from './chunks/mHfUAX_g.js';
-import { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types';
+export { O as OpenAPILike, a as OpenAPIOptionsMap, h as OpenAPIV2, j as OpenAPIV2Like, f as OpenAPIV3, k as OpenAPIV3Like, i as Operation, c as OperationById, n as OperationByRoute, b as OperationId, d as OperationOptions, l as OperationResponse, e as OperationResult, m as OperationRoute, S as ServerUrl, g as getServerUrl, r as resolveOperation } from './chunks/3E8iuIR5.js';
+import { OpenAPIV2, OpenAPIV3, OpenAPIV3_1, OpenAPI } from 'openapi-types';
 import { StringReplace, WriteableDeep, StringJoin, Substract } from '@unshared/types';
-import './chunks/CO11DuYE.js';
+import './chunks/BZ5qrH6f.js';
 import './HttpHeaders.js';
 import './HttpMethods.js';
 
+/**
+ * Check if the given document is an OpenAPI v2 specification.
+ *
+ * @param value The document to check.
+ * @returns `true` if the document is an OpenAPI v2 specification, `false` otherwise.
+ * @example isOpenAPIV2({ swagger: '2.0', info: { title: 'Test API', version: '1.0.0' } }) // => true
+ */
+declare function isOpenAPIV2(value: unknown): value is OpenAPIV2.Document;
+
+/**
+ * Check if the given document is an OpenAPI v3.0 specification.
+ *
+ * @param value The document to check.
+ * @returns `true` if the document is an OpenAPI v3.0 specification, `false` otherwise.
+ * @example isOpenAPIV3({ openapi: '3.0.0', info: { title: 'Test API', version: '1.0.0' } }) // => true
+ */
+declare function isOpenAPIV3(value: unknown): value is OpenAPIV3.Document;
+
+/**
+ * Check if the given document is an OpenAPI v3.1 specification.
+ *
+ * @param value The document to check.
+ * @returns `true` if the document is an OpenAPI v3.1 specification, `false` otherwise.
+ * @example isOpenAPIV3_1({ openapi: '3.1.0', info: { title: 'Test API', version: '1.0.0' } }) // => true
+ */
+declare function isOpenAPIV3_1(value: unknown): value is OpenAPIV3_1.Document;
+
 type OpenAPIReference = OpenAPIV2.ReferenceObject | OpenAPIV3.ReferenceObject | OpenAPIV3_1.ReferenceObject;
 /**
  * Check if a value is an {@linkcode OpenAPIReference}.
@@ -92,4 +119,18 @@ type OpenAPIResolved<T, D = T, N extends number = 8> = N extends 0 ? T : T exten
 declare function resolveDocument<T extends object>(value: Readonly<T>): OpenAPIResolved<T>;
 declare function resolveDocument<T extends object, D>(value: Readonly<T>, document: Readonly<D>): OpenAPIResolved<T, D>;
 
-export { type OpenAPIReference, type OpenAPIReferenceDecoded, type OpenAPIReferencePath, type OpenAPIReferenceResolved, type OpenAPIResolved, isReferenceObject, resolveDocument, resolveReference };
+interface TokenOptions {
+    tokenLocation?: 'cookie' | 'header' | 'query';
+    tokenProperty?: string;
+}
+/**
+ * Resolve the location of the apiKey token based on the OpenAPI specification.
+ *
+ * @param document The OpenAPI specification document.
+ * @param operation The OpenAPI operation object.
+ * @returns The location of the apiKey token ('query' | 'cookie' | 'header').
+ * @example resolveOperationTokenOptions(document, operation) // => { tokenLocation: 'header', tokenProperty: 'X-API-Key' }
+ */
+declare function resolveOperationTokenOptions(document: object, operation: OpenAPI.Operation): TokenOptions;
+
+export { type OpenAPIReference, type OpenAPIReferenceDecoded, type OpenAPIReferencePath, type OpenAPIReferenceResolved, type OpenAPIResolved, type TokenOptions, isOpenAPIV2, isOpenAPIV3, isOpenAPIV3_1, isReferenceObject, resolveDocument, resolveOperationTokenOptions, resolveReference };
diff --git a/dist/openapi.js b/dist/openapi.js
index c76b8122cc05c01f94ded749e15a9d2dc2e1d0aa..96534714dcccb2e9bfbbab148bd666b64c045ca5 100644
--- a/dist/openapi.js
+++ b/dist/openapi.js
@@ -1,4 +1,10 @@
-import { g, r } from "./chunks/Biic1J5b.js";
+import { g, i, r, a } from "./chunks/B_Gz6Yz8.js";
+function isOpenAPIV2(value) {
+  return typeof value == "object" && value !== null && "swagger" in value && value.swagger === "2.0";
+}
+function isOpenAPIV3_1(value) {
+  return typeof value == "object" && value !== null && "openapi" in value && value.openapi === "3.1.0";
+}
 function isReferenceObject(value) {
   return typeof value == "object" && value !== null && "$ref" in value && typeof value.$ref == "string";
 }
@@ -28,9 +34,13 @@ function resolveDocument(value, document = value) {
 }
 export {
   g as getServerUrl,
+  isOpenAPIV2,
+  i as isOpenAPIV3,
+  isOpenAPIV3_1,
   isReferenceObject,
   resolveDocument,
   r as resolveOperation,
+  a as resolveOperationTokenOptions,
   resolveReference
 };
 //# sourceMappingURL=openapi.js.map
diff --git a/dist/openapi.js.map b/dist/openapi.js.map
index 96a9a4f4a3c2ee23502fd8886c51e497e7f1451a..703ce326cea88b9f9f8e65b7f7ce7b6e565d477c 100644
--- a/dist/openapi.js.map
+++ b/dist/openapi.js.map
@@ -1 +1 @@
-{"version":3,"file":"openapi.js","sources":["../openapi/isReferenceObject.ts","../openapi/resolveReference.ts","../openapi/resolveDocument.ts"],"sourcesContent":["import type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'\n\nexport type OpenAPIReference =\n  | OpenAPIV2.ReferenceObject\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject\n\n/**\n * Check if a value is an {@linkcode OpenAPIReference}.\n *\n * @param value The value to check.\n * @returns `true` if the value is a reference object.\n * @example isReferenceObject({ $ref: '#/components/schemas/MySchema' }) // true\n */\nexport function isReferenceObject<T extends OpenAPIReference>(value: unknown): value is T {\n  return typeof value === 'object'\n    && value !== null\n    && '$ref' in value\n    && typeof value.$ref === 'string'\n}\n","import type { StringJoin, StringReplace, WriteableDeep } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport { isReferenceObject } from './isReferenceObject'\n\n/**\n * Decode an OpenAPI reference path by replacing the encoded characters with\n * their original values. This function will replace `~0` with `~` and `~1`\n * with `/`.\n *\n * @example DecodeReference<'#/foo~1bar~0baz'> // '#/foo/bar~baz'\n */\nexport type OpenAPIReferenceDecoded<T extends string> =\n  StringReplace<StringReplace<T, '~0', '~'>, '~1', '/'>\n\n/**\n * Extract the parts of a reference path as a tuple.\n *\n * @example OpenAPIV3ReferencePath<'#/paths/~1users~1{username}'> // ['paths', '/users/{username}']\n */\nexport type OpenAPIReferencePath<T extends string> =\n  T extends `#/${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n    : T extends `#/${infer P}` ? [P]\n      : T extends `${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n        : T extends `${infer P}` ? [P]\n          : []\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The result type.\n * @example Resolved<{ $ref: '#/info' }, { info: { title: string } }> // { title: string }\n */\nexport type OpenAPIReferenceResolved<\n  T extends OpenAPIReference,\n  D extends object,\n> =\n  D extends object\n    ? T extends { $ref: infer R extends string }\n\n      // --- Match last part of the reference.\n      ? OpenAPIReferencePath<R> extends [infer P extends string]\n        ? OpenAPIReferenceDecoded<P> extends keyof D\n          ? D[OpenAPIReferenceDecoded<P>] extends object\n            ? WriteableDeep<Omit<D[OpenAPIReferenceDecoded<P>], keyof T>>\n            : never\n          : never\n\n        // --- Match middle part of the reference.\n        : OpenAPIReferencePath<R> extends [infer P extends string, ...infer Rest extends string[]]\n          ? OpenAPIReferenceDecoded<P> extends keyof D\n            ? D[OpenAPIReferenceDecoded<P>] extends object\n              ? OpenAPIReferenceResolved<{ $ref: StringJoin<Rest, '/'> }, D[OpenAPIReferenceDecoded<P>]>\n              : never\n            : never\n          : never\n      : never\n    : never\n\n/**\n * Resolve an OpenAPI `ReferenceObject` to the component it references. If the\n * source is not a reference, the source will be returned.\n *\n * @private\n * @param reference The reference object to resolve.\n * @param document The OpenAPI document to resolve the reference from.\n * @returns The result component.\n * @example resolveReference({ $ref: '#/components/schemas/User' }, document)\n */\nexport function resolveReference<\n  T extends OpenAPIReference,\n  D extends object,\n>(reference: Readonly<T>, document: Readonly<D>): OpenAPIReferenceResolved<T, D> {\n\n  // --- Return the source if it is not a reference.\n  if (!isReferenceObject(reference))\n    throw new TypeError('Expected value to be an OpenAPI reference object.')\n\n  // --- Assert that the parameters are valid.\n  if (typeof document !== 'object' || document === null)\n    throw new TypeError('Expected OpenAPI specification to be an object.')\n\n  // --- Resolve the component with it's reference path.\n  const referenceParts = reference.$ref.replace(/^#\\//, '').split('/')\n  let result = document\n  for (const part of referenceParts) {\n    if (result === undefined) break\n    if (typeof result !== 'object' || result === null) break\n    const key = part.replaceAll('~1', '/').replaceAll('~0', '~')\n    // @ts-expect-error: assume the part is a key of the object.\n    result = result[key] as unknown\n  }\n\n  // --- Throw an error if the component could not be result.\n  if (result === undefined)\n    throw new Error(`Could not resolve OpenAPI component: ${reference.$ref}`)\n\n  // --- Return the result component.\n  return result as OpenAPIReferenceResolved<T, D>\n}\n","import type { ObjectLike, Substract } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport type { OpenAPIReferenceResolved } from './resolveReference'\nimport { isReferenceObject } from './isReferenceObject'\nimport { resolveReference as resolveReference } from './resolveReference'\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The resolved type.\n * @example\n * type Resolved = OpenAPIResolved<{\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' }\n *     }\n *   }\n * }>\n */\nexport type OpenAPIResolved<T, D = T, N extends number = 8> =\n  N extends 0 ? T\n    : T extends OpenAPIReference\n      ? D extends object ? OpenAPIResolved<OpenAPIReferenceResolved<T, D>, D, Substract<N, 1>> : never\n      : T extends object ? { -readonly [K in keyof T]: OpenAPIResolved<T[K], D, N> } : T\n\n/**\n * Recursively resolve all references in an OpenAPI specification. This function\n * will return a `Proxy` object that will resolve references on the fly.\n *\n * @param value The OpenAPI specification.\n * @returns The resolved OpenAPI specification.\n * @example\n * const resolved = resolveReferences({\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' },\n *     },\n *   },\n * })\n */\nexport function resolveDocument<T extends object>(value: Readonly<T>): OpenAPIResolved<T>\nexport function resolveDocument<T extends object, D>(value: Readonly<T>, document: Readonly<D>): OpenAPIResolved<T, D>\nexport function resolveDocument(value: Readonly<ObjectLike>, document = value): unknown {\n  return new Proxy(value, {\n    get(target, property: string) {\n      let value = target[property]\n\n      // --- Abort if no document is provided.\n      if (!document) return value\n\n      // --- Resolve the reference if it is a reference object.\n      if (isReferenceObject(value))\n        value = resolveReference(value, document)\n\n      // --- Recursively resolve references in objects.\n      if (typeof value === 'object' && value !== null)\n        return resolveDocument(value as ObjectLike, document)\n\n      // --- Return the value as is.\n      return value\n    },\n  })\n}\n"],"names":["value"],"mappings":";AAcO,SAAS,kBAA8C,OAA4B;AACjF,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,UAAU,SACV,OAAO,MAAM,QAAS;AAC7B;ACmDgB,SAAA,iBAGd,WAAwB,UAAuD;AAG3E,MAAA,CAAC,kBAAkB,SAAS;AACxB,UAAA,IAAI,UAAU,mDAAmD;AAGrE,MAAA,OAAO,YAAa,YAAY,aAAa;AACzC,UAAA,IAAI,UAAU,iDAAiD;AAGjE,QAAA,iBAAiB,UAAU,KAAK,QAAQ,QAAQ,EAAE,EAAE,MAAM,GAAG;AACnE,MAAI,SAAS;AACb,aAAW,QAAQ,gBAAgB;AAEjC,QADI,WAAW,UACX,OAAO,UAAW,YAAY,WAAW,KAAM;AAC7C,UAAA,MAAM,KAAK,WAAW,MAAM,GAAG,EAAE,WAAW,MAAM,GAAG;AAE3D,aAAS,OAAO,GAAG;AAAA,EAAA;AAIrB,MAAI,WAAW;AACb,UAAM,IAAI,MAAM,wCAAwC,UAAU,IAAI,EAAE;AAGnE,SAAA;AACT;ACtDgB,SAAA,gBAAgB,OAA6B,WAAW,OAAgB;AAC/E,SAAA,IAAI,MAAM,OAAO;AAAA,IACtB,IAAI,QAAQ,UAAkB;AACxBA,UAAAA,SAAQ,OAAO,QAAQ;AAG3B,aAAK,YAGD,kBAAkBA,MAAK,MACzBA,SAAQ,iBAAiBA,QAAO,QAAQ,IAGtC,OAAOA,UAAU,YAAYA,WAAU,OAClC,gBAAgBA,QAAqB,QAAQ,IAG/CA,UAXeA;AAAAA,IAAA;AAAA,EAYxB,CACD;AACH;"}
\ No newline at end of file
+{"version":3,"file":"openapi.js","sources":["../openapi/isOpenAPIV2.ts","../openapi/isOpenAPIV3_1.ts","../openapi/isReferenceObject.ts","../openapi/resolveReference.ts","../openapi/resolveDocument.ts"],"sourcesContent":["/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV2 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v2 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v2 specification, `false` otherwise.\n * @example isOpenAPIV2({ swagger: '2.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV2(value: unknown): value is OpenAPIV2.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'swagger' in value\n    && value.swagger === '2.0'\n}\n","/* eslint-disable unicorn/filename-case */\nimport type { OpenAPIV3_1 } from 'openapi-types'\n\n/**\n * Check if the given document is an OpenAPI v3.1 specification.\n *\n * @param value The document to check.\n * @returns `true` if the document is an OpenAPI v3.1 specification, `false` otherwise.\n * @example isOpenAPIV3_1({ openapi: '3.1.0', info: { title: 'Test API', version: '1.0.0' } }) // => true\n */\nexport function isOpenAPIV3_1(value: unknown): value is OpenAPIV3_1.Document {\n  return typeof value === 'object'\n    && value !== null\n    && 'openapi' in value\n    && value.openapi === '3.1.0'\n}\n","import type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'\n\nexport type OpenAPIReference =\n  | OpenAPIV2.ReferenceObject\n  | OpenAPIV3.ReferenceObject\n  | OpenAPIV3_1.ReferenceObject\n\n/**\n * Check if a value is an {@linkcode OpenAPIReference}.\n *\n * @param value The value to check.\n * @returns `true` if the value is a reference object.\n * @example isReferenceObject({ $ref: '#/components/schemas/MySchema' }) // true\n */\nexport function isReferenceObject<T extends OpenAPIReference>(value: unknown): value is T {\n  return typeof value === 'object'\n    && value !== null\n    && '$ref' in value\n    && typeof value.$ref === 'string'\n}\n","import type { StringJoin, StringReplace, WriteableDeep } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport { isReferenceObject } from './isReferenceObject'\n\n/**\n * Decode an OpenAPI reference path by replacing the encoded characters with\n * their original values. This function will replace `~0` with `~` and `~1`\n * with `/`.\n *\n * @example DecodeReference<'#/foo~1bar~0baz'> // '#/foo/bar~baz'\n */\nexport type OpenAPIReferenceDecoded<T extends string> =\n  StringReplace<StringReplace<T, '~0', '~'>, '~1', '/'>\n\n/**\n * Extract the parts of a reference path as a tuple.\n *\n * @example OpenAPIV3ReferencePath<'#/paths/~1users~1{username}'> // ['paths', '/users/{username}']\n */\nexport type OpenAPIReferencePath<T extends string> =\n  T extends `#/${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n    : T extends `#/${infer P}` ? [P]\n      : T extends `${infer P}/${infer Rest}` ? [P, ...OpenAPIReferencePath<Rest>]\n        : T extends `${infer P}` ? [P]\n          : []\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The result type.\n * @example Resolved<{ $ref: '#/info' }, { info: { title: string } }> // { title: string }\n */\nexport type OpenAPIReferenceResolved<\n  T extends OpenAPIReference,\n  D extends object,\n> =\n  D extends object\n    ? T extends { $ref: infer R extends string }\n\n      // --- Match last part of the reference.\n      ? OpenAPIReferencePath<R> extends [infer P extends string]\n        ? OpenAPIReferenceDecoded<P> extends keyof D\n          ? D[OpenAPIReferenceDecoded<P>] extends object\n            ? WriteableDeep<Omit<D[OpenAPIReferenceDecoded<P>], keyof T>>\n            : never\n          : never\n\n        // --- Match middle part of the reference.\n        : OpenAPIReferencePath<R> extends [infer P extends string, ...infer Rest extends string[]]\n          ? OpenAPIReferenceDecoded<P> extends keyof D\n            ? D[OpenAPIReferenceDecoded<P>] extends object\n              ? OpenAPIReferenceResolved<{ $ref: StringJoin<Rest, '/'> }, D[OpenAPIReferenceDecoded<P>]>\n              : never\n            : never\n          : never\n      : never\n    : never\n\n/**\n * Resolve an OpenAPI `ReferenceObject` to the component it references. If the\n * source is not a reference, the source will be returned.\n *\n * @private\n * @param reference The reference object to resolve.\n * @param document The OpenAPI document to resolve the reference from.\n * @returns The result component.\n * @example resolveReference({ $ref: '#/components/schemas/User' }, document)\n */\nexport function resolveReference<\n  T extends OpenAPIReference,\n  D extends object,\n>(reference: Readonly<T>, document: Readonly<D>): OpenAPIReferenceResolved<T, D> {\n\n  // --- Return the source if it is not a reference.\n  if (!isReferenceObject(reference))\n    throw new TypeError('Expected value to be an OpenAPI reference object.')\n\n  // --- Assert that the parameters are valid.\n  if (typeof document !== 'object' || document === null)\n    throw new TypeError('Expected OpenAPI specification to be an object.')\n\n  // --- Resolve the component with it's reference path.\n  const referenceParts = reference.$ref.replace(/^#\\//, '').split('/')\n  let result = document\n  for (const part of referenceParts) {\n    if (result === undefined) break\n    if (typeof result !== 'object' || result === null) break\n    const key = part.replaceAll('~1', '/').replaceAll('~0', '~')\n    // @ts-expect-error: assume the part is a key of the object.\n    result = result[key] as unknown\n  }\n\n  // --- Throw an error if the component could not be result.\n  if (result === undefined)\n    throw new Error(`Could not resolve OpenAPI component: ${reference.$ref}`)\n\n  // --- Return the result component.\n  return result as OpenAPIReferenceResolved<T, D>\n}\n","import type { ObjectLike, Substract } from '@unshared/types'\nimport type { OpenAPIReference } from './isReferenceObject'\nimport type { OpenAPIReferenceResolved } from './resolveReference'\nimport { isReferenceObject } from './isReferenceObject'\nimport { resolveReference as resolveReference } from './resolveReference'\n\n/**\n * Resolve a type to the type it references. If the source is not a reference,\n * the source will be returned.\n *\n * @template T The type to resolve.\n * @returns The resolved type.\n * @example\n * type Resolved = OpenAPIResolved<{\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' }\n *     }\n *   }\n * }>\n */\nexport type OpenAPIResolved<T, D = T, N extends number = 8> =\n  N extends 0 ? T\n    : T extends OpenAPIReference\n      ? D extends object ? OpenAPIResolved<OpenAPIReferenceResolved<T, D>, D, Substract<N, 1>> : never\n      : T extends object ? { -readonly [K in keyof T]: OpenAPIResolved<T[K], D, N> } : T\n\n/**\n * Recursively resolve all references in an OpenAPI specification. This function\n * will return a `Proxy` object that will resolve references on the fly.\n *\n * @param value The OpenAPI specification.\n * @returns The resolved OpenAPI specification.\n * @example\n * const resolved = resolveReferences({\n *   ...\n *   paths: {\n *     '/users': {\n *       get: { $ref: '#/components/routes/getUsers' },\n *     },\n *   },\n * })\n */\nexport function resolveDocument<T extends object>(value: Readonly<T>): OpenAPIResolved<T>\nexport function resolveDocument<T extends object, D>(value: Readonly<T>, document: Readonly<D>): OpenAPIResolved<T, D>\nexport function resolveDocument(value: Readonly<ObjectLike>, document = value): unknown {\n  return new Proxy(value, {\n    get(target, property: string) {\n      let value = target[property]\n\n      // --- Abort if no document is provided.\n      if (!document) return value\n\n      // --- Resolve the reference if it is a reference object.\n      if (isReferenceObject(value))\n        value = resolveReference(value, document)\n\n      // --- Recursively resolve references in objects.\n      if (typeof value === 'object' && value !== null)\n        return resolveDocument(value as ObjectLike, document)\n\n      // --- Return the value as is.\n      return value\n    },\n  })\n}\n"],"names":["value"],"mappings":";AAUO,SAAS,YAAY,OAA6C;AAChE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACLO,SAAS,cAAc,OAA+C;AACpE,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,aAAa,SACb,MAAM,YAAY;AACzB;ACDO,SAAS,kBAA8C,OAA4B;AACjF,SAAA,OAAO,SAAU,YACnB,UAAU,QACV,UAAU,SACV,OAAO,MAAM,QAAS;AAC7B;ACmDgB,SAAA,iBAGd,WAAwB,UAAuD;AAG3E,MAAA,CAAC,kBAAkB,SAAS;AACxB,UAAA,IAAI,UAAU,mDAAmD;AAGrE,MAAA,OAAO,YAAa,YAAY,aAAa;AACzC,UAAA,IAAI,UAAU,iDAAiD;AAGjE,QAAA,iBAAiB,UAAU,KAAK,QAAQ,QAAQ,EAAE,EAAE,MAAM,GAAG;AACnE,MAAI,SAAS;AACb,aAAW,QAAQ,gBAAgB;AAEjC,QADI,WAAW,UACX,OAAO,UAAW,YAAY,WAAW,KAAM;AAC7C,UAAA,MAAM,KAAK,WAAW,MAAM,GAAG,EAAE,WAAW,MAAM,GAAG;AAE3D,aAAS,OAAO,GAAG;AAAA,EAAA;AAIrB,MAAI,WAAW;AACb,UAAM,IAAI,MAAM,wCAAwC,UAAU,IAAI,EAAE;AAGnE,SAAA;AACT;ACtDgB,SAAA,gBAAgB,OAA6B,WAAW,OAAgB;AAC/E,SAAA,IAAI,MAAM,OAAO;AAAA,IACtB,IAAI,QAAQ,UAAkB;AACxBA,UAAAA,SAAQ,OAAO,QAAQ;AAG3B,aAAK,YAGD,kBAAkBA,MAAK,MACzBA,SAAQ,iBAAiBA,QAAO,QAAQ,IAGtC,OAAOA,UAAU,YAAYA,WAAU,OAClC,gBAAgBA,QAAqB,QAAQ,IAG/CA,UAXeA;AAAAA,IAAA;AAAA,EAYxB,CACD;AACH;"}
\ No newline at end of file
diff --git a/dist/utils.cjs b/dist/utils.cjs
index da9262653265587d39e18295331c62da8d4b4c12..5900f3a9bb0b12ead44403a98732d0dd5a929e9a 100644
--- a/dist/utils.cjs
+++ b/dist/utils.cjs
@@ -1,18 +1,30 @@
 "use strict";
-var handleResponse = require("./chunks/Cayg8606.cjs"), parseRequestQuery = require("./chunks/CYmaYL5B.cjs"), request = require("./chunks/Du_W5H6e.cjs");
+var request = require("./chunks/YA_gLiBm.cjs"), handleResponse = require("./chunks/B3X3mHFx.cjs"), parseRequestQuery = require("./chunks/BDxlAULu.cjs");
 require("@unshared/functions/awaitable");
-exports.fetch = handleResponse.fetch;
+function getCookie(headers, key) {
+  const cookie = handleResponse.getCookies(headers);
+  if (cookie)
+    return cookie[key];
+}
+exports.fetch = request.fetch;
+exports.request = request.request;
+exports.getCookies = handleResponse.getCookies;
+exports.getHeader = handleResponse.getHeader;
 exports.handleResponse = handleResponse.handleResponse;
 exports.handleResponseStreamJson = handleResponse.handleResponseStreamJson;
 exports.isFormDataLike = handleResponse.isFormDataLike;
 exports.isObjectLike = handleResponse.isObjectLike;
 exports.parseRequest = handleResponse.parseRequest;
+exports.parseRequestBasicAuth = handleResponse.parseRequestBasicAuth;
 exports.parseRequestBody = handleResponse.parseRequestBody;
 exports.parseRequestHeaders = handleResponse.parseRequestHeaders;
+exports.parseRequestToken = handleResponse.parseRequestToken;
 exports.parseRequestUrl = handleResponse.parseRequestUrl;
+exports.setCookie = handleResponse.setCookie;
+exports.setHeader = handleResponse.setHeader;
 exports.toFormData = handleResponse.toFormData;
 exports.parseRequestParameters = parseRequestQuery.parseRequestParameters;
 exports.parseRequestQuery = parseRequestQuery.parseRequestQuery;
 exports.toSearchParams = parseRequestQuery.toSearchParams;
-exports.request = request.request;
+exports.getCookie = getCookie;
 //# sourceMappingURL=utils.cjs.map
diff --git a/dist/utils.cjs.map b/dist/utils.cjs.map
index 74b87bd6fcf32c850542339d3afc1d6c81a771eb..a23a53815a9022b561f0a2d653e31f3b2c0f1350 100644
--- a/dist/utils.cjs.map
+++ b/dist/utils.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"utils.cjs","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"utils.cjs","sources":["../utils/getCookie.ts"],"sourcesContent":["import { getCookies } from './getCookies'\n\n/**\n * Get a cookie value from the `HeadersInit` object.\n *\n * @param headers The headers to get the cookie value from.\n * @param key The key of the cookie to get.\n * @returns The value of the cookie.\n * @example\n * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })\n * const value = getCookie(headers, 'key1')\n */\nexport function getCookie(headers: HeadersInit, key: string): string | undefined {\n  const cookie = getCookies(headers)\n  if (!cookie) return\n  return cookie[key]\n}\n"],"names":["getCookies"],"mappings":";;;AAYgB,SAAA,UAAU,SAAsB,KAAiC;AACzE,QAAA,SAASA,0BAAW,OAAO;AAC5B,MAAA;AACL,WAAO,OAAO,GAAG;AACnB;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/utils.d.ts b/dist/utils.d.ts
index 00fa9ff7bfea5be71a3b16d84da283239cbc6c16..25528d92a5724a73fb889b0ffca241a2e0f49250 100644
--- a/dist/utils.d.ts
+++ b/dist/utils.d.ts
@@ -1,5 +1,5 @@
-import { a as FetchOptions, R as RequestOptions, b as RequestContext } from './chunks/CO11DuYE.js';
-export { c as FetchHeaders, F as FetchMethod, d as SearchArrayFormat, S as SearchParamsObject, T as ToSearchParamsOptions, p as parseRequest, r as request, t as toSearchParams } from './chunks/CO11DuYE.js';
+import { a as FetchOptions, R as RequestOptions, b as RequestContext } from './chunks/BZ5qrH6f.js';
+export { c as FetchHeaders, F as FetchMethod, d as SearchArrayFormat, S as SearchParamsObject, T as ToSearchParamsOptions, p as parseRequest, r as request, t as toSearchParams } from './chunks/BZ5qrH6f.js';
 import { Awaitable } from '@unshared/functions/awaitable';
 import { ObjectLike } from '@unshared/types';
 import './HttpHeaders.js';
@@ -16,6 +16,42 @@ import './HttpMethods.js';
  */
 declare function fetch(route: string, options?: FetchOptions): Promise<Response>;
 
+/**
+ * Get a cookie value from the `HeadersInit` object.
+ *
+ * @param headers The headers to get the cookie value from.
+ * @param key The key of the cookie to get.
+ * @returns The value of the cookie.
+ * @example
+ * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })
+ * const value = getCookie(headers, 'key1')
+ */
+declare function getCookie(headers: HeadersInit, key: string): string | undefined;
+
+/**
+ * Extract the cookies from the `HeadersInit` object.
+ *
+ * @param headers The headers to extract the cookies from.
+ * @returns An array of cookies.
+ * @example
+ * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })
+ * const cookies = getCookies(headers) // { key1: 'value1', key2: 'value2' }
+ */
+declare function getCookies(headers: HeadersInit): Record<string, string>;
+
+/**
+ * Get a header value from the `HeadersInit` object.
+ *
+ * @param headers The headers to get the key-value pair from.
+ * @param key The key of the header to get.
+ * @returns The value of the header.
+ * @example
+ * const headers = new Headers({ 'Content-Type': 'application/json' })
+ * const contentType = getHeader(headers, 'Content-Type')
+ * console.log(contentType) // 'application/json'
+ */
+declare function getHeader(headers: HeadersInit, key: string): string | undefined;
+
 /**
  * Handle a request response. This function will parse the response based on the content type and
  * return the data. If an error occurs, the `onError` callback will be called and the function will
@@ -62,13 +98,29 @@ declare function isFormDataLike(value: unknown): value is FormDataLike;
  */
 declare function isObjectLike(value: unknown): value is ObjectLike;
 
+/**
+ * Parse the basic authentication headers based on the provided username and password.
+ *
+ * @param context The request context.
+ * @param options The request options.
+ * @example
+ *
+ * // Append the `Authorization` header to the request.
+ * const context = {}
+ * parseRequestBasicAuth(context, { username: 'user', password: 'pass' })
+ *
+ * // Will mutate the `init` object to include the headers.
+ * console.log(context) // => { init: { headers: { 'Authorization': 'Basic dXNlcjpwYXNz' } } }
+ */
+declare function parseRequestBasicAuth(context: Partial<RequestContext>, options: FetchOptions): void;
+
 /**
  * Parse the request body based on the provided data and options.
  *
  * @param context The request context.
  * @param options The request options.
  */
-declare function parseRequestBody(context: RequestContext, options: FetchOptions): void;
+declare function parseRequestBody(context: Partial<RequestContext>, options: FetchOptions): void;
 
 /**
  * Parse the request headers based on the provided data and options.
@@ -84,7 +136,7 @@ declare function parseRequestBody(context: RequestContext, options: FetchOptions
  * // Will mutate the `init` object to include the headers.
  * console.log(context) // => { init: { headers: { 'Content-Type': 'application/json' } } }
  */
-declare function parseRequestHeaders(context: RequestContext, options: FetchOptions): void;
+declare function parseRequestHeaders(context: Partial<RequestContext>, options: FetchOptions): void;
 
 /**
  * Parse the request parameters from the request data. This function will mutate the
@@ -104,7 +156,7 @@ declare function parseRequestHeaders(context: RequestContext, options: FetchOpti
  * parseRequestParameters(context, { parameters: { id: 1 } })
  * console.log(context.url.pathname) // 'https://api.example.com/users/1'
  */
-declare function parseRequestParameters(context: RequestContext, options: FetchOptions): void;
+declare function parseRequestParameters(context: Partial<RequestContext>, options: FetchOptions): void;
 
 /**
  * Parse the query parameters from the request data. This function will append
@@ -113,7 +165,32 @@ declare function parseRequestParameters(context: RequestContext, options: FetchO
  * @param context The request context to modify.
  * @param options The options to pass to the request.
  */
-declare function parseRequestQuery(context: RequestContext, options: FetchOptions): void;
+declare function parseRequestQuery(context: Partial<RequestContext>, options: FetchOptions): void;
+
+/**
+ * Parse the token and dynamically extend either the query, headers, or cookies.
+ *
+ * @param context The request context.
+ * @param options The request options.
+ * @example
+ * // Append the `token` to the query parameters.
+ * const context = { url: new URL('https://example.com') }
+ * parseRequestToken(context, { token: 'my-token', tokenLocation: 'query', tokenProperty: 'token' })
+ * console.log(context.url.searchParams.get('token')) // 'my-token'
+ *
+ * @example
+ * // Append the `token` to the headers.
+ * const context = { init: { headers: new Headers() } }
+ * parseRequestToken(context, { token: 'my-token', tokenLocation: 'header', tokenProperty: 'Authorization' })
+ * console.log(context.init.headers.get('Authorization')) // 'Bearer my-token'
+ *
+ * @example
+ * // Append the `token` to the cookies.
+ * const context = { init: { headers: new Headers() } }
+ * parseRequestToken(context, { token: 'my-token', tokenLocation: 'cookie', tokenProperty: 'token' })
+ * console.log(context.init.headers.get('Cookie')) // 'token=my-token'
+ */
+declare function parseRequestToken(context: Partial<RequestContext>, options: FetchOptions): void;
 
 /**
  * Parses the route name to extract the URL and method. It allows the url and method to be
@@ -124,7 +201,36 @@ declare function parseRequestQuery(context: RequestContext, options: FetchOption
  * @param options The options to pass to the request.
  * @example parseRequestUrl('GET /users', { baseUrl: 'https://api.example.com' }, context)
  */
-declare function parseRequestUrl(context: RequestContext, route: string, options: FetchOptions): void;
+declare function parseRequestUrl(context: Partial<RequestContext>, route: string, options: FetchOptions): void;
+
+/**
+ * Set a cookie in the `HeadersInit` object.
+ *
+ * @param headers The headers to set the cookie in.
+ * @param key The key of the cookie to set.
+ * @param value The value of the cookie to set.
+ * @example
+ * const headers = new Headers()
+ * const cookie = { key: 'key1', value: 'value1', path: '/', secure: true }
+ * setCookie(headers, cookie)
+ * console.log(headers.get('Cookie')) // 'key1=value1; Path=/; Secure'
+ */
+declare function setCookie(headers: HeadersInit, key: string, value: string): void;
+
+/**
+ * Set a header in the `HeadersInit` object whether it is a `Headers` instance, an
+ * array of key-value pairs, or an object. It is also case-insensitive, meaning that
+ * if a header with the same key but different case is found, it will be replaced.
+ *
+ * @param headers The headers to set the key-value pair in.
+ * @param key The key of the header to set.
+ * @param value The value of the header to set.
+ * @example
+ * const headers = new Headers()
+ * setHeader(headers, 'Content-Type', 'application/json')
+ * console.log(headers.get('Content-Type')) // 'application/json'
+ */
+declare function setHeader(headers: HeadersInit, key: string, value: number | string): void;
 
 /**
  * Casts an object that may contain `Blob`, `File`, or `FileList` values to a `FormData` object.
@@ -134,4 +240,4 @@ declare function parseRequestUrl(context: RequestContext, route: string, options
  */
 declare function toFormData(object: FormDataLike): FormData;
 
-export { FetchOptions, type FormDataLike, RequestContext, RequestOptions, fetch, handleResponse, handleResponseStreamJson, isFormDataLike, isObjectLike, parseRequestBody, parseRequestHeaders, parseRequestParameters, parseRequestQuery, parseRequestUrl, toFormData };
+export { FetchOptions, type FormDataLike, RequestContext, RequestOptions, fetch, getCookie, getCookies, getHeader, handleResponse, handleResponseStreamJson, isFormDataLike, isObjectLike, parseRequestBasicAuth, parseRequestBody, parseRequestHeaders, parseRequestParameters, parseRequestQuery, parseRequestToken, parseRequestUrl, setCookie, setHeader, toFormData };
diff --git a/dist/utils.js b/dist/utils.js
index d269f71fc28778d2413fd00f1e3a2d796a0f0d60..f0e5587c634c946c62d3231def8494b1bfdc02a8 100644
--- a/dist/utils.js
+++ b/dist/utils.js
@@ -1,20 +1,33 @@
-import { f, h, a, i, b, p, c, d, e, t } from "./chunks/BUeqbyph.js";
-import { p as p2, a as a2, t as t2 } from "./chunks/0ZzUT3m_.js";
-import { r } from "./chunks/DJJsADWD.js";
+import { f, r } from "./chunks/2o4clKrH.js";
+import { g as getCookies } from "./chunks/BwI3JmT5.js";
+import { a, h, b, i, c, p, d, e, f as f2, j, k, s, l, t } from "./chunks/BwI3JmT5.js";
+import { p as p2, a as a2, t as t2 } from "./chunks/B6pUErTM.js";
 import "@unshared/functions/awaitable";
+function getCookie(headers, key) {
+  const cookie = getCookies(headers);
+  if (cookie)
+    return cookie[key];
+}
 export {
   f as fetch,
+  getCookie,
+  getCookies,
+  a as getHeader,
   h as handleResponse,
-  a as handleResponseStreamJson,
+  b as handleResponseStreamJson,
   i as isFormDataLike,
-  b as isObjectLike,
+  c as isObjectLike,
   p as parseRequest,
-  c as parseRequestBody,
-  d as parseRequestHeaders,
+  d as parseRequestBasicAuth,
+  e as parseRequestBody,
+  f2 as parseRequestHeaders,
   p2 as parseRequestParameters,
   a2 as parseRequestQuery,
-  e as parseRequestUrl,
+  j as parseRequestToken,
+  k as parseRequestUrl,
   r as request,
+  s as setCookie,
+  l as setHeader,
   t as toFormData,
   t2 as toSearchParams
 };
diff --git a/dist/utils.js.map b/dist/utils.js.map
index 759667e9da72cbed8b19eba45226041e7360b6ac..6504f87923933af83f3f3bf3da5b230fe5966d1e 100644
--- a/dist/utils.js.map
+++ b/dist/utils.js.map
@@ -1 +1 @@
-{"version":3,"file":"utils.js","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;"}
\ No newline at end of file
+{"version":3,"file":"utils.js","sources":["../utils/getCookie.ts"],"sourcesContent":["import { getCookies } from './getCookies'\n\n/**\n * Get a cookie value from the `HeadersInit` object.\n *\n * @param headers The headers to get the cookie value from.\n * @param key The key of the cookie to get.\n * @returns The value of the cookie.\n * @example\n * const headers = new Headers({ Cookie: 'key1=value1; key2=value2' })\n * const value = getCookie(headers, 'key1')\n */\nexport function getCookie(headers: HeadersInit, key: string): string | undefined {\n  const cookie = getCookies(headers)\n  if (!cookie) return\n  return cookie[key]\n}\n"],"names":[],"mappings":";;;;;AAYgB,SAAA,UAAU,SAAsB,KAAiC;AACzE,QAAA,SAAS,WAAW,OAAO;AAC5B,MAAA;AACL,WAAO,OAAO,GAAG;AACnB;"}
\ No newline at end of file
diff --git a/dist/websocket.cjs b/dist/websocket.cjs
index 926103c02795f1b8e1543e2ff154b56ec6406650..02c2c4d0130cfe952a5e0ad5764951d83d436e9f 100644
--- a/dist/websocket.cjs
+++ b/dist/websocket.cjs
@@ -1,7 +1,7 @@
 "use strict";
-var connect = require("./chunks/BMbsYNBd.cjs");
+var connect = require("./chunks/BdFNzMcu.cjs");
 require("@unshared/functions");
-require("./chunks/CYmaYL5B.cjs");
+require("./chunks/BDxlAULu.cjs");
 exports.WebSocketChannel = connect.WebSocketChannel;
 exports.connect = connect.connect;
 exports.parseConnectOptions = connect.parseConnectOptions;
diff --git a/dist/websocket.js b/dist/websocket.js
index d3b6b0d0d7f01eb108cf31dce1f20f0f7e9d7dff..a3086b8238008411b59f07d5b9de95eb4c75db02 100644
--- a/dist/websocket.js
+++ b/dist/websocket.js
@@ -1,6 +1,6 @@
-import { W, c, p } from "./chunks/6IxvRpmY.js";
+import { W, c, p } from "./chunks/Bys4-xE2.js";
 import "@unshared/functions";
-import "./chunks/0ZzUT3m_.js";
+import "./chunks/B6pUErTM.js";
 export {
   W as WebSocketChannel,
   c as connect,
