diff --git a/dist/request.cjs.map b/dist/request.cjs.map
index 0bdf3194b40d1122f8b27e3c12192b707e24d080..bf97ccba9e5783a8801c1a896d8a41de2cd4181e 100644
--- a/dist/request.cjs.map
+++ b/dist/request.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"request.cjs","sources":["../request.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-imports */\nimport type { ApplicationOrModule, ErrorData } from '@unserved/server'\nimport { IsNever } from '@unshared/types'\nimport { handleResponse } from './handleResponse'\nimport { resolveRequestInit } from './resolveRequestInit'\nimport { InferInput, InferOutput, InferRouteName } from './types'\n\n/** Type-safe options to pass to the client request based on the route. */\nexport type RequestOptionsData<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> =\n  IsNever<T> extends true\n    ? Record<string, unknown>\n    : InferInput<T, P>\n\ntype RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  IsNever<T> extends true\n    ? (error: Error) => void\n    : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => void\n\ntype RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  InferOutput<T, P> extends AsyncIterable<infer U>\n    ? (data: U) => void\n    : (data: Exclude<InferOutput<T, P>, ErrorData>) => void\n\ninterface RequestOptionsHooks<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> {\n  onError?: RequestErrorCallback<T, P>\n  onData?: RequestDataCallback<T, P>\n  onSuccess?: () => void\n  onEnd?: () => void\n}\n\nexport interface RequestOptions<\n  T extends ApplicationOrModule = never,\n  P extends InferRouteName<T> = never,\n> extends\n  RequestInit,\n  RequestOptionsHooks<T, P> {\n\n  /**\n   * The data to pass to the request. This data will be used to fill the path\n   * parameters, query parameters, body, and form data of the request based on\n   * the route method.\n   */\n  data?: RequestOptionsData<T, P>\n\n  /**\n   * The base URL of the request. This URL will be used to resolve the path of\n   * the route.\n   */\n  baseUrl?: string\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param name The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request<T extends ApplicationOrModule, P extends InferRouteName<T> = InferRouteName<T>>(name: P, options?: RequestOptions<T, P>): Promise<InferOutput<T, P>>\nexport async function request(name: string, options: RequestOptions = {}): Promise<unknown> {\n  const { url, init } = resolveRequestInit(name, options)\n  const response = await fetch(url, init)\n  return await handleResponse(response, options)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { ModuleBase, createRoute, createError } = await import('@unserved/server')\n\n  describe('requestOptionsData', () => {\n    it('should infer the request data type', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute({\n            name: 'GET /test',\n            parameters: () => ({ foo: 'Hello' }),\n            query: () => ({ bar: 'Hello' }),\n            body: () => ({ baz: 'Hello' }),\n          }, () => {}),\n        }\n      }\n      type Result = RequestOptionsData<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<{ foo: string; bar: string; baz: string }>()\n    })\n\n    it('should infer the request data type without a module', () => {\n      type Result = RequestOptionsData\n      expectTypeOf<Result>().toEqualTypeOf<Record<string, unknown>>()\n    })\n  })\n\n  describe('requestErrorCallback', () => {\n    it('should infer the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n\n          getFoo: createRoute('GET /test', () => createError({\n            name: 'E_TEST',\n            message: 'Test error message',\n            statusCode: 400,\n            statusMessage: 'Bad Request',\n            data: { foo: 'bar' },\n          })),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => void>()\n    })\n\n    it('should only include the error type in the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => void>()\n    })\n  })\n\n  describe('requestDataCallback', () => {\n    it('should infer the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => 'Hello'),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: string) => void>()\n    })\n\n    it('should exclude the error type from the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: 'Hello') => void>()\n    })\n  })\n}\n"],"names":["resolveRequestInit","handleResponse"],"mappings":";;;;AAsEA,eAAsB,QAAQ,MAAc,UAA0B,IAAsB;AAC1F,QAAM,EAAE,KAAK,KAAK,IAAIA,mBAAmB,mBAAA,MAAM,OAAO,GAChD,WAAW,MAAM,MAAM,KAAK,IAAI;AAC/B,SAAA,MAAMC,eAAe,eAAA,UAAU,OAAO;AAC/C;;"}
\ No newline at end of file
+{"version":3,"file":"request.cjs","sources":["../request.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-imports */\nimport type { ApplicationOrModule, ErrorData } from '@unserved/server'\nimport { IsNever } from '@unshared/types'\nimport { handleResponse } from './handleResponse'\nimport { resolveRequestInit } from './resolveRequestInit'\nimport { InferInput, InferOutput, InferRouteName } from './types'\n\n/** Type-safe options to pass to the client request based on the route. */\nexport type RequestOptionsData<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> =\n  IsNever<T> extends true\n    ? Record<string, unknown>\n    : InferInput<T, P>\n\ntype RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  IsNever<T> extends true\n    ? (error: Error) => any\n    : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => any\n\ntype RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  InferOutput<T, P> extends AsyncIterable<infer U>\n    ? (data: U) => any\n    : (data: Exclude<InferOutput<T, P>, ErrorData>) => any\n\ninterface RequestOptionsHooks<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> {\n  onError?: RequestErrorCallback<T, P>\n  onData?: RequestDataCallback<T, P>\n  onSuccess?: () => any\n  onEnd?: () => any\n}\n\nexport interface RequestOptions<\n  T extends ApplicationOrModule = never,\n  P extends InferRouteName<T> = never,\n> extends\n  RequestInit,\n  RequestOptionsHooks<T, P> {\n\n  /**\n   * The data to pass to the request. This data will be used to fill the path\n   * parameters, query parameters, body, and form data of the request based on\n   * the route method.\n   */\n  data?: RequestOptionsData<T, P>\n\n  /**\n   * The base URL of the request. This URL will be used to resolve the path of\n   * the route.\n   */\n  baseUrl?: string\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param name The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request<T extends ApplicationOrModule, P extends InferRouteName<T> = InferRouteName<T>>(name: P, options?: RequestOptions<T, P>): Promise<InferOutput<T, P>>\nexport async function request(name: string, options: RequestOptions = {}): Promise<unknown> {\n  const { url, init } = resolveRequestInit(name, options)\n  const response = await fetch(url, init)\n  return await handleResponse(response, options)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { ModuleBase, createRoute, createError } = await import('@unserved/server')\n\n  describe('requestOptionsData', () => {\n    it('should infer the request data type', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute({\n            name: 'GET /test',\n            parameters: () => ({ foo: 'Hello' }),\n            query: () => ({ bar: 'Hello' }),\n            body: () => ({ baz: 'Hello' }),\n          }, () => {}),\n        }\n      }\n      type Result = RequestOptionsData<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<{ foo: string; bar: string; baz: string }>()\n    })\n\n    it('should infer the request data type without a module', () => {\n      type Result = RequestOptionsData\n      expectTypeOf<Result>().toEqualTypeOf<Record<string, unknown>>()\n    })\n  })\n\n  describe('requestErrorCallback', () => {\n    it('should infer the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n\n          getFoo: createRoute('GET /test', () => createError({\n            name: 'E_TEST',\n            message: 'Test error message',\n            statusCode: 400,\n            statusMessage: 'Bad Request',\n            data: { foo: 'bar' },\n          })),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => any>()\n    })\n\n    it('should only include the error type in the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => any>()\n    })\n  })\n\n  describe('requestDataCallback', () => {\n    it('should infer the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => 'Hello'),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: string) => any>()\n    })\n\n    it('should exclude the error type from the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: 'Hello') => any>()\n    })\n  })\n}\n"],"names":["resolveRequestInit","handleResponse"],"mappings":";;;;AAsEA,eAAsB,QAAQ,MAAc,UAA0B,IAAsB;AAC1F,QAAM,EAAE,KAAK,KAAK,IAAIA,mBAAmB,mBAAA,MAAM,OAAO,GAChD,WAAW,MAAM,MAAM,KAAK,IAAI;AAC/B,SAAA,MAAMC,eAAe,eAAA,UAAU,OAAO;AAC/C;;"}
\ No newline at end of file
diff --git a/dist/request.d.ts b/dist/request.d.ts
index a12a71b5899b867e210903e876494c725c4dc0b5..083ab75a1dd06584395064fa28df1662ad054180 100644
--- a/dist/request.d.ts
+++ b/dist/request.d.ts
@@ -4,13 +4,13 @@ import { InferRouteName, InferInput, InferOutput } from './types.js';
 
 /** Type-safe options to pass to the client request based on the route. */
 type RequestOptionsData<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> = IsNever<T> extends true ? Record<string, unknown> : InferInput<T, P>;
-type RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> = IsNever<T> extends true ? (error: Error) => void : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => void;
-type RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> = InferOutput<T, P> extends AsyncIterable<infer U> ? (data: U) => void : (data: Exclude<InferOutput<T, P>, ErrorData>) => void;
+type RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> = IsNever<T> extends true ? (error: Error) => any : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => any;
+type RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> = InferOutput<T, P> extends AsyncIterable<infer U> ? (data: U) => any : (data: Exclude<InferOutput<T, P>, ErrorData>) => any;
 interface RequestOptionsHooks<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> {
     onError?: RequestErrorCallback<T, P>;
     onData?: RequestDataCallback<T, P>;
-    onSuccess?: () => void;
-    onEnd?: () => void;
+    onSuccess?: () => any;
+    onEnd?: () => any;
 }
 interface RequestOptions<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> extends RequestInit, RequestOptionsHooks<T, P> {
     /**
diff --git a/dist/request.js.map b/dist/request.js.map
index 885070be5725babab696ba2928f974d1cb9de1c8..711d0e19b785d90f6b05776dca5cf1477fca8ed7 100644
--- a/dist/request.js.map
+++ b/dist/request.js.map
@@ -1 +1 @@
-{"version":3,"file":"request.js","sources":["../request.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-imports */\nimport type { ApplicationOrModule, ErrorData } from '@unserved/server'\nimport { IsNever } from '@unshared/types'\nimport { handleResponse } from './handleResponse'\nimport { resolveRequestInit } from './resolveRequestInit'\nimport { InferInput, InferOutput, InferRouteName } from './types'\n\n/** Type-safe options to pass to the client request based on the route. */\nexport type RequestOptionsData<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> =\n  IsNever<T> extends true\n    ? Record<string, unknown>\n    : InferInput<T, P>\n\ntype RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  IsNever<T> extends true\n    ? (error: Error) => void\n    : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => void\n\ntype RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  InferOutput<T, P> extends AsyncIterable<infer U>\n    ? (data: U) => void\n    : (data: Exclude<InferOutput<T, P>, ErrorData>) => void\n\ninterface RequestOptionsHooks<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> {\n  onError?: RequestErrorCallback<T, P>\n  onData?: RequestDataCallback<T, P>\n  onSuccess?: () => void\n  onEnd?: () => void\n}\n\nexport interface RequestOptions<\n  T extends ApplicationOrModule = never,\n  P extends InferRouteName<T> = never,\n> extends\n  RequestInit,\n  RequestOptionsHooks<T, P> {\n\n  /**\n   * The data to pass to the request. This data will be used to fill the path\n   * parameters, query parameters, body, and form data of the request based on\n   * the route method.\n   */\n  data?: RequestOptionsData<T, P>\n\n  /**\n   * The base URL of the request. This URL will be used to resolve the path of\n   * the route.\n   */\n  baseUrl?: string\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param name The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request<T extends ApplicationOrModule, P extends InferRouteName<T> = InferRouteName<T>>(name: P, options?: RequestOptions<T, P>): Promise<InferOutput<T, P>>\nexport async function request(name: string, options: RequestOptions = {}): Promise<unknown> {\n  const { url, init } = resolveRequestInit(name, options)\n  const response = await fetch(url, init)\n  return await handleResponse(response, options)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { ModuleBase, createRoute, createError } = await import('@unserved/server')\n\n  describe('requestOptionsData', () => {\n    it('should infer the request data type', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute({\n            name: 'GET /test',\n            parameters: () => ({ foo: 'Hello' }),\n            query: () => ({ bar: 'Hello' }),\n            body: () => ({ baz: 'Hello' }),\n          }, () => {}),\n        }\n      }\n      type Result = RequestOptionsData<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<{ foo: string; bar: string; baz: string }>()\n    })\n\n    it('should infer the request data type without a module', () => {\n      type Result = RequestOptionsData\n      expectTypeOf<Result>().toEqualTypeOf<Record<string, unknown>>()\n    })\n  })\n\n  describe('requestErrorCallback', () => {\n    it('should infer the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n\n          getFoo: createRoute('GET /test', () => createError({\n            name: 'E_TEST',\n            message: 'Test error message',\n            statusCode: 400,\n            statusMessage: 'Bad Request',\n            data: { foo: 'bar' },\n          })),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => void>()\n    })\n\n    it('should only include the error type in the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => void>()\n    })\n  })\n\n  describe('requestDataCallback', () => {\n    it('should infer the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => 'Hello'),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: string) => void>()\n    })\n\n    it('should exclude the error type from the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: 'Hello') => void>()\n    })\n  })\n}\n"],"names":[],"mappings":";;;;AAsEA,eAAsB,QAAQ,MAAc,UAA0B,IAAsB;AAC1F,QAAM,EAAE,KAAK,KAAK,IAAI,mBAAmB,MAAM,OAAO,GAChD,WAAW,MAAM,MAAM,KAAK,IAAI;AAC/B,SAAA,MAAM,eAAe,UAAU,OAAO;AAC/C;"}
\ No newline at end of file
+{"version":3,"file":"request.js","sources":["../request.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-imports */\nimport type { ApplicationOrModule, ErrorData } from '@unserved/server'\nimport { IsNever } from '@unshared/types'\nimport { handleResponse } from './handleResponse'\nimport { resolveRequestInit } from './resolveRequestInit'\nimport { InferInput, InferOutput, InferRouteName } from './types'\n\n/** Type-safe options to pass to the client request based on the route. */\nexport type RequestOptionsData<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> =\n  IsNever<T> extends true\n    ? Record<string, unknown>\n    : InferInput<T, P>\n\ntype RequestErrorCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  IsNever<T> extends true\n    ? (error: Error) => any\n    : (error: Error | Extract<InferOutput<T, P>, ErrorData>) => any\n\ntype RequestDataCallback<T extends ApplicationOrModule, P extends InferRouteName<T>> =\n  InferOutput<T, P> extends AsyncIterable<infer U>\n    ? (data: U) => any\n    : (data: Exclude<InferOutput<T, P>, ErrorData>) => any\n\ninterface RequestOptionsHooks<T extends ApplicationOrModule = never, P extends InferRouteName<T> = never> {\n  onError?: RequestErrorCallback<T, P>\n  onData?: RequestDataCallback<T, P>\n  onSuccess?: () => any\n  onEnd?: () => any\n}\n\nexport interface RequestOptions<\n  T extends ApplicationOrModule = never,\n  P extends InferRouteName<T> = never,\n> extends\n  RequestInit,\n  RequestOptionsHooks<T, P> {\n\n  /**\n   * The data to pass to the request. This data will be used to fill the path\n   * parameters, query parameters, body, and form data of the request based on\n   * the route method.\n   */\n  data?: RequestOptionsData<T, P>\n\n  /**\n   * The base URL of the request. This URL will be used to resolve the path of\n   * the route.\n   */\n  baseUrl?: string\n}\n\n/**\n * Fetch a route from the API and return the data. If the client was instantiated with an\n * application, the route name will be inferred from the application routes. Otherwise, you\n * can pass the route name as a string.\n *\n * @param name The name of the route to fetch.\n * @param options The options to pass to the request.\n * @returns The data from the API.\n * @example\n * // Declare the application type.\n * type App = Application<[ModuleProduct]>\n *\n * // Create a type-safe client for the application.\n * const request = createClient<App>()\n *\n * // Fetch the data from the API.\n * const data = request('GET /api/product/:id', { data: { id: '1' } })\n */\nexport async function request<T extends ApplicationOrModule, P extends InferRouteName<T> = InferRouteName<T>>(name: P, options?: RequestOptions<T, P>): Promise<InferOutput<T, P>>\nexport async function request(name: string, options: RequestOptions = {}): Promise<unknown> {\n  const { url, init } = resolveRequestInit(name, options)\n  const response = await fetch(url, init)\n  return await handleResponse(response, options)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { ModuleBase, createRoute, createError } = await import('@unserved/server')\n\n  describe('requestOptionsData', () => {\n    it('should infer the request data type', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute({\n            name: 'GET /test',\n            parameters: () => ({ foo: 'Hello' }),\n            query: () => ({ bar: 'Hello' }),\n            body: () => ({ baz: 'Hello' }),\n          }, () => {}),\n        }\n      }\n      type Result = RequestOptionsData<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<{ foo: string; bar: string; baz: string }>()\n    })\n\n    it('should infer the request data type without a module', () => {\n      type Result = RequestOptionsData\n      expectTypeOf<Result>().toEqualTypeOf<Record<string, unknown>>()\n    })\n  })\n\n  describe('requestErrorCallback', () => {\n    it('should infer the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n\n          getFoo: createRoute('GET /test', () => createError({\n            name: 'E_TEST',\n            message: 'Test error message',\n            statusCode: 400,\n            statusMessage: 'Bad Request',\n            data: { foo: 'bar' },\n          })),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => any>()\n    })\n\n    it('should only include the error type in the error callback', () => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n      type Result = RequestErrorCallback<typeof ModuleTest, 'GET /test'>\n      expectTypeOf<Result>().toEqualTypeOf<(error: { name: 'E_TEST'; message: string; foo: string } | Error) => any>()\n    })\n  })\n\n  describe('requestDataCallback', () => {\n    it('should infer the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => 'Hello'),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: string) => any>()\n    })\n\n    it('should exclude the error type from the data callback', () => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      class ModuleTest extends ModuleBase {\n        routes = {\n          getFoo: createRoute('GET /test', () => {\n            if (Math.random() > 0.5) return 'Hello'\n\n            return createError({\n              name: 'E_TEST',\n              message: 'Test error message',\n              statusCode: 400,\n              statusMessage: 'Bad Request',\n              data: { foo: 'bar' },\n            })\n          }),\n        }\n      }\n    type Result = RequestDataCallback<typeof ModuleTest, 'GET /test'>\n    expectTypeOf<Result>().toEqualTypeOf<(data: 'Hello') => any>()\n    })\n  })\n}\n"],"names":[],"mappings":";;;;AAsEA,eAAsB,QAAQ,MAAc,UAA0B,IAAsB;AAC1F,QAAM,EAAE,KAAK,KAAK,IAAI,mBAAmB,MAAM,OAAO,GAChD,WAAW,MAAM,MAAM,KAAK,IAAI;AAC/B,SAAA,MAAM,eAAe,UAAU,OAAO;AAC/C;"}
