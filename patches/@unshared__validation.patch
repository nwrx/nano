diff --git a/dist/assert.cjs b/dist/assert.cjs
index 29dd8237ad4feb1575e0d4f62efd3a3ff726babc..0124fe9beb9c51be4782cb2cf08b1606421f2ec9 100644
--- a/dist/assert.cjs
+++ b/dist/assert.cjs
@@ -1,5 +1,5 @@
 "use strict";
-var kindOf = require("@unshared/functions/kindOf"), ValidationError = require("./ValidationError.cjs"), toConstantCase = require("@unshared/string/toConstantCase");
+var kindOf = require("@unshared/functions/kindOf"), ValidationError = require("./ValidationError.cjs"), functions = require("@unshared/functions"), toConstantCase = require("@unshared/string/toConstantCase");
 function assertArray(value) {
   if (!Array.isArray(value))
     throw new ValidationError.ValidationError({
@@ -42,6 +42,13 @@ function assertFalsy(value) {
       message: `Expected value to be falsy but received: ${kindOf.kindOf(value)}`
     });
 }
+function assertFunction(value) {
+  if (typeof value != "function")
+    throw new ValidationError.ValidationError({
+      name: "E_NOT_FUNCTION",
+      message: `Expected value to be a function but received: ${functions.kindOf(value)}`
+    });
+}
 function assertInstance(value, ctor) {
   if (!(value instanceof ctor))
     throw new ValidationError.ValidationError({
@@ -292,6 +299,7 @@ exports.assertArrayNotEmpty = assertArrayNotEmpty;
 exports.assertBoolean = assertBoolean;
 exports.assertFalse = assertFalse;
 exports.assertFalsy = assertFalsy;
+exports.assertFunction = assertFunction;
 exports.assertInstance = assertInstance;
 exports.assertNil = assertNil;
 exports.assertNotNil = assertNotNil;
diff --git a/dist/assert.cjs.map b/dist/assert.cjs.map
index 3413556b6cf4066a1f82d2c2d1791f1208518cd1..82243ca5e881e0428550780770073d768f516b17 100644
--- a/dist/assert.cjs.map
+++ b/dist/assert.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"assert.cjs","sources":["../assert/assertArray.ts","../assert/assertArrayEmpty.ts","../assert/assertArrayNotEmpty.ts","../assert/assertBoolean.ts","../assert/assertFalse.ts","../assert/assertFalsy.ts","../assert/assertInstance.ts","../assert/assertNil.ts","../assert/assertNotNil.ts","../assert/assertNotNull.ts","../assert/assertNotUndefined.ts","../assert/assertNull.ts","../assert/assertNumber.ts","../assert/assertNumberBetween.ts","../assert/assertNumberBetweenStrict.ts","../assert/assertNumberInteger.ts","../assert/assertNumberEven.ts","../assert/assertNumberNegative.ts","../assert/assertNumberNegativeStrict.ts","../assert/assertNumberOdd.ts","../assert/assertNumberPositive.ts","../assert/assertNumberPositiveStrict.ts","../assert/assertObject.ts","../assert/assertString.ts","../assert/assertStringNotEmpty.ts","../assert/assertStringConstantCase.ts","../assert/assertStringEmail.ts","../assert/assertStringEmpty.ts","../assert/assertStringEndingWith.ts","../assert/assertStringEnum.ts","../assert/assertStringEquals.ts","../assert/assertStringMatching.ts","../assert/assertStringNumber.ts","../assert/assertStringStartingWith.ts","../assert/assertStringUuid.ts","../assert/assertTrue.ts","../assert/assertUndefined.ts","../assert/createAssertInstance.ts","../assert/createAssertNumberBetween.ts","../assert/createAssertNumberBetweenStrict.ts","../assert/createAssertStringEndingWith.ts","../assert/createAssertStringEnum.ts","../assert/createAssertStringEquals.ts","../assert/createAssertStringStartingWith.ts"],"sourcesContent":["import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an array.\n *\n * @param value The value to assert as an array.\n * @throws `ValidationError` if the value is not an array.\n * @example assertArray(['Hello, World!']) // void\n */\nexport function assertArray<T>(value: unknown): asserts value is T[] {\n  if (Array.isArray(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_ARRAY',\n    message: `Expected value to be an array but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an array', () => {\n    const result = assertArray([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArray({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertArray(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertArray(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n  })\n\n  test('should predicate an array', () => {\n    const value = [] as unknown\n    assertArray(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate an array of string if a generic is provided', () => {\n    const value = [] as unknown\n    assertArray<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is an empty array.\n *\n * @param value The value to assert as an empty array.\n * @throws `ValidationError` if the value is not an empty array.\n * @example assertArrayEmpty([]) // void\n */\nexport function assertArrayEmpty(value: unknown): asserts value is [] {\n  assertArray(value)\n  if (value.length === 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_NOT_EMPTY',\n    message: `Expected value to be an empty array but actually received an array with ${value.length} items`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should pass if value is an empty array', () => {\n    const result = assertArrayEmpty([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an empty array', () => {\n    const shouldThrow = () => assertArrayEmpty([1])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty array but actually received an array with 1 items')\n  })\n\n  test('should predicate an empty array', () => {\n    const value = [] as unknown\n    assertArrayEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is a non-empty array.\n *\n * @param value The value to assert as a non-empty array.\n * @throws `ValidationError` if the value is not a non-empty array.\n * @example assertArrayNotEmpty(['Hello, World!']) // void\n */\nexport function assertArrayNotEmpty<T>(value: unknown): asserts value is T[] {\n  assertArray(value)\n  if (value.length > 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_EMPTY',\n    message: 'Expected value to be a non-empty array but received an empty array.',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty array', () => {\n    const result = assertArrayNotEmpty([1])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty array', () => {\n    const shouldThrow = () => assertArrayNotEmpty([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty array but received an empty array.')\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayNotEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should predicate a non-empty array', () => {\n    const value = [1] as unknown\n    assertArrayNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate a non-empty array of string if a generic is provided', () => {\n    const value = ['Hello, World!'] as unknown\n    assertArrayNotEmpty<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n// is boolean\n/**\n * Assert that a value is a boolean.\n *\n * @param value The value to assert as a boolean.\n * @throws `ValidationError` if the value is not a boolean.\n * @example assertBoolean(true) // void\n */\nexport function assertBoolean(value: unknown): asserts value is boolean {\n  if (typeof value === 'boolean') return\n  throw new ValidationError({\n    name: 'E_NOT_BOOLEAN',\n    message: `Expected value to be a boolean but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean', () => {\n    const result = assertBoolean(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertBoolean(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertBoolean(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertBoolean(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean', () => {\n    const value = true as unknown\n    assertBoolean(value)\n    expectTypeOf(value).toEqualTypeOf<boolean>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `false`.\n *\n * @param value The value to assert as a boolean equal to `false`.\n * @throws `ValidationError` if the value is not a boolean equal to `false`.\n * @example assertFalse(false) // void\n */\nexport function assertFalse(value: unknown): asserts value is false {\n  assertBoolean(value)\n  if (value === false) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_FALSE',\n    message: `Expected value to be a boolean equal to false but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalse(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to false', () => {\n    const shouldThrow = () => assertFalse(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to false but received: true')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertFalse(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFalse(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFalse(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to false', () => {\n    const value = false as unknown\n    assertFalse(value)\n    expectTypeOf(value).toEqualTypeOf<false>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is falsy. Meaning it is either `false`, `0`, `''`, `null` or `undefined`.\n *\n * @param value The value to assert as falsy.\n * @throws `ValidationError` if the value is not falsy.\n * @example assertFalsy(false) // void\n */\nexport function assertFalsy(value: unknown): asserts value is '' | 0 | false | null | undefined {\n  if (value) {\n    throw new ValidationError({\n      name: 'E_NOT_FALSY',\n      message: `Expected value to be falsy but received: ${kindOf(value)}`,\n    })\n  }\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalsy(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is 0', () => {\n    const result = assertFalsy(0)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is an empty string', () => {\n    const result = assertFalsy('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertFalsy(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertFalsy(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-zero number', () => {\n    const shouldThrow = () => assertFalsy(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: number')\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertFalsy('hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: string')\n  })\n\n  test('should throw if value is true', () => {\n    const shouldThrow = () => assertFalsy(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: boolean')\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertFalsy({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: object')\n  })\n\n  test('should throw if value is an array', () => {\n    const shouldThrow = () => assertFalsy([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: Array')\n  })\n\n  test('should predicate a falsy value', () => {\n    const value = false as unknown\n    assertFalsy(value)\n    expectTypeOf(value).toEqualTypeOf<'' | 0 | false | null | undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an instance of the given class.\n *\n * @param value The value to assert as an instance of the given class.\n * @param ctor The class to assert the value is an instance of.\n * @throws `ValidationError` if the value is not an instance of the given class.\n * @example assertInstance(new Date(), Date) // void\n */\nexport function assertInstance<T extends object>(value: unknown, ctor: Constructor<T>): asserts value is T {\n  if (value instanceof ctor) return\n  throw new ValidationError({\n    name: 'E_NOT_INSTANCE_OF',\n    message: `Expected value to be an instance of ${ctor.name} but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an instance of the given class', () => {\n    const result = assertInstance(new Date(), Date)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an instance of the given class', () => {\n    const shouldThrow = () => assertInstance([], Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertInstance(undefined, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertInstance(null, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: null')\n  })\n\n  test('should predicate an instance of the given class', () => {\n    const value = new Date() as unknown\n    assertInstance(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n\n  test('should predicate an instance of the given class if a generic is provided', () => {\n    const value = new Date() as unknown\n    assertInstance<Date>(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null` or `undefined`.\n *\n * @param value The value to assert as `null` or `undefined`.\n * @throws `ValidationError` if the value is neither `null` nor `undefined`.\n * @example assertNil(null) // void\n */\nexport function assertNil(value: unknown): asserts value is null | undefined {\n  if (value === null || value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_NIL',\n    message: `Expected value to be null or undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNil(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNil(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNil({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null or undefined but received: object')\n  })\n\n  test('should predicate a null or undefined union', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNil(value)\n    expectTypeOf(value).toEqualTypeOf<null | undefined>()\n  })\n}\n","import type { NotNil } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null` or `undefined`.\n *\n * @param value The value to assert as not `null` or `undefined`.\n * @throws `ValidationError` if the value is `null` or `undefined`.\n * @example assertNotNil(1) // void\n */\nexport function assertNotNil<T>(value: T): asserts value is NotNil<T> {\n  if (value !== null && value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_NIL',\n    message: 'Expected value not to be null or undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null or undefined', () => {\n    const result = assertNotNil(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNil(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotNil(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNil(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import type { NotNull } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null`.\n *\n * @param value The value to assert as not `null`.\n * @throws `ValidationError` if the value is `null`.\n * @example assertNotNull(1) // void\n */\nexport function assertNotNull<T>(value: T): asserts value is NotNull<T> {\n  if (value !== null) return\n  throw new ValidationError({\n    name: 'E_IS_NULL',\n    message: 'Expected value not to be null',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null', () => {\n    const result = assertNotNull(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNotNull(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNull(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNull(value)\n    expectTypeOf(value).toEqualTypeOf<number | undefined>()\n  })\n}\n","import type { NotUndefined } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `undefined`.\n *\n * @param value The value to assert as not `undefined`.\n * @throws `ValidationError` if the value is `undefined`.\n * @example assertNotUndefined(1) // void\n */\nexport function assertNotUndefined<T>(value: T): asserts value is NotUndefined<T> {\n  if (value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_UNDEFINED',\n    message: 'Expected value not to be undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not undefined', () => {\n    const result = assertNotUndefined(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNotUndefined(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotUndefined(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<null | number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null`.\n *\n * @param value The value to assert as `null`.\n * @throws `ValidationError` if the value is not `null`.\n * @example assertNull(null) // void\n */\nexport function assertNull(value: unknown): asserts value is null {\n  if (value === null) return\n  throw new ValidationError({\n    name: 'E_NOT_NULL',\n    message: `Expected value to be null but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNull(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNull({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNull(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: undefined')\n  })\n\n  test('should predicate a null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNull(value)\n    expectTypeOf(value).toEqualTypeOf<null>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a number.\n *\n * @param value The value to assert as a number.\n * @throws `ValidationError` if the value is not a number.\n * @example assertNumber(1) // void\n */\nexport function assertNumber(value: unknown): asserts value is number {\n  if (typeof value === 'number') return\n  throw new ValidationError({\n    name: 'E_NOT_NUMBER',\n    message: `Expected value to be a number but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number', () => {\n    const result = assertNumber(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumber('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number', () => {\n    const value = 1 as unknown\n    assertNumber(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number between or equal a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The minimum value that the number can be.\n * @param max The maximum value that the number can be.\n */\nexport function assertNumberBetween(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value >= min && value <= max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetween(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to min', () => {\n    const result = assertNumberBetween(1, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to max', () => {\n    const result = assertNumberBetween(10, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetween(0, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 0')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetween(11, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 11')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetween('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetween(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetween(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetween(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly between a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @throws `ValidationError` if the value is not strictly between the minimum and maximum value.\n * @example assertNumberBetweenStrict(5, 1, 10) // void\n */\nexport function assertNumberBetweenStrict(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value > min && value < max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN_STRICT',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetweenStrict(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is equal to min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is equal to max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetweenStrict('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetweenStrict(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetweenStrict(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is an integer number.\n *\n * @param value The value to assert as an integer number.\n * @throws `ValidationError` if the value is not an integer number.\n * @example assertNumberInteger(1) // void\n */\nexport function assertNumberInteger(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (!Number.isSafeInteger(value)) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_INTEGER',\n      message: `Expected value to be an integer number but received decimal value: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an integer number', () => {\n    const result = assertNumberInteger(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberInteger('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is not an integer number', () => {\n    const shouldThrow = () => assertNumberInteger(1.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 1.1')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberInteger(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberInteger(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an integer number', () => {\n    const value = 1 as unknown\n    assertNumberInteger(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an even number.\n *\n * @param value The value to assert as an even number.\n * @throws `ValidationError` if the value is not an even number.\n * @example assertNumberEven(2) // true\n */\nexport function assertNumberEven(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 1) !== 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_EVEN',\n      message: `Expected value to be an even number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an even number', () => {\n    const result = assertNumberEven(2)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an odd number', () => {\n    const shouldThrow = () => assertNumberEven(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an even number but received: 1')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberEven(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberEven('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberEven(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberEven(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an even number', () => {\n    const value = 2 as unknown\n    assertNumberEven(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number less than or equal to `0`.\n *\n * @param value The value to assert as a number less than or equal to `0`.\n * @throws `ValidationError` if the value is not a number less than or equal to `0`.\n * @example assertNumberNegative(-1) // void\n */\nexport function assertNumberNegative(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value <= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE',\n    message: `Expected value to be a number less than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than or equal to 0', () => {\n    const result = assertNumberNegative(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than or equal to 0', () => {\n    const shouldThrow = () => assertNumberNegative(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number less than or equal to 0 but received: 1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegative('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegative(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegative(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than or equal to 0', () => {\n    const value = -1 as unknown\n    assertNumberNegative(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number less than `0`.\n *\n * @param value The value to assert as a number less than `0`.\n * @throws `ValidationError` if the value is not a number less than `0`.\n * @example assertNumberNegativeStrict(-1) // void\n */\nexport function assertNumberNegativeStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value < 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE_STRICT',\n    message: `Expected value to be a number strictly less than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than 0', () => {\n    const result = assertNumberNegativeStrict(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than 0', () => {\n    const shouldThrow = () => assertNumberNegativeStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly less than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegativeStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegativeStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegativeStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than 0', () => {\n    const value = -1 as unknown\n    assertNumberNegativeStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an odd number.\n *\n * @param value The value to assert as an odd number.\n * @throws `ValidationError` if the value is not an odd number.\n * @example assertNumberOdd(1) // true\n */\nexport function assertNumberOdd(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 0x1) === 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_ODD',\n      message: `Expected value to be an odd number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an odd number', () => {\n    const result = assertNumberOdd(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an even number', () => {\n    const shouldThrow = () => assertNumberOdd(2)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an odd number but received: 2')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberOdd(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberOdd('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberOdd(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberOdd(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an odd number', () => {\n    const value = 1 as unknown\n    assertNumberOdd(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number greater than or equal to `0`.\n *\n * @param value The value to assert as a number greater than or equal to `0`.\n * @throws `ValidationError` if the value is not a number greater than or equal to `0`.\n * @example assertNumberPositive(1) // void\n */\nexport function assertNumberPositive(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value >= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE',\n    message: `Expected value to be a number greater than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than or equal to 0', () => {\n    const result = assertNumberPositive(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than or equal to 0', () => {\n    const shouldThrow = () => assertNumberPositive(-1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number greater than or equal to 0 but received: -1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositive('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositive(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositive(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than or equal to 0', () => {\n    const value = 1 as unknown\n    assertNumberPositive(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number greater than `0`.\n *\n * @param value The value to assert as a number greater than `0`.\n * @throws `ValidationError` if the value is not a number greater than `0`.\n * @example assertNumberPositiveStrict(1) // void\n */\nexport function assertNumberPositiveStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value > 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE_STRICT',\n    message: `Expected value to be a number strictly greater than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than 0', () => {\n    const result = assertNumberPositiveStrict(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than 0', () => {\n    const shouldThrow = () => assertNumberPositiveStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly greater than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositiveStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositiveStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositiveStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than 0', () => {\n    const value = 1 as unknown\n    assertNumberPositiveStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an object.\n *\n * @param value The value to assert as an object.\n * @throws `ValidationError` if the value is not an object.\n * @example assertObject({}) // void\n */\nexport function assertObject<T extends object>(value: unknown): asserts value is T {\n  if (kindOf(value) === 'object') return\n  throw new ValidationError({\n    name: 'E_NOT_OBJECT',\n    message: `Expected value to be an object but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an object', () => {\n    const result = assertObject({})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an object', () => {\n    const shouldThrow = () => assertObject([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertObject(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertObject(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: null')\n  })\n\n  test('should predicate an object', () => {\n    const value = {} as unknown\n    assertObject(value)\n    expectTypeOf(value).toEqualTypeOf<object>()\n  })\n\n  test('should predicate an object of Record<string, unknown> if a generic is provided', () => {\n    const value = {} as unknown\n    assertObject<Record<string, unknown>>(value)\n    expectTypeOf(value).toEqualTypeOf<Record<string, unknown>>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a string.\n *\n * @param value The value to assert as a string.\n * @throws `ValidationError` if the value is not a string.\n * @example assertString('Hello, World!') // void\n */\nexport function assertString(value: unknown): asserts value is string {\n  if (typeof value === 'string') return\n  throw new ValidationError({\n    name: 'E_NOT_STRING',\n    message: `Expected value to be a string but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string', () => {\n    const result = assertString('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertString(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertString(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertString(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string', () => {\n    const value = 'Hello, World!' as unknown\n    assertString(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is not empty. An empty string\n * is a string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as a non-empty string.\n * @throws `ValidationError` if the value is not a non-empty string.\n * @example assertStringNotEmpty('Hello, World!') // void\n */\nexport function assertStringNotEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length > 0) return\n  throw new ValidationError({\n    name: 'E_STRING_EMPTY',\n    message: 'Expected value to be a non-empty string but received an empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty string', () => {\n    const result = assertStringNotEmpty('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty string', () => {\n    const shouldThrow = () => assertStringNotEmpty('')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is a string with only whitespace characters', () => {\n    const shouldThrow = () => assertStringNotEmpty(' \\n\\t ')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringNotEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNotEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNotEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a non-empty string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { toConstantCase } from '@unshared/string/toConstantCase'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\nimport { assertStringNotEmpty } from './assertStringNotEmpty'\n\n/**\n * Assert that a value is a string and that it matches in constant case pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as in constant case.\n * @throws `ValidationError` if the value is not in constant case.\n * @example assertStringConstantCase('john.doe@acme.com') // void\n */\nexport function assertStringConstantCase(value: unknown): asserts value is string {\n  assertString(value)\n  assertStringNotEmpty(value)\n  if (value === toConstantCase(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_CONSTANT_CASE',\n    message: `Expected value to be a string in constant case but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is in constant case', () => {\n    const result = assertStringConstantCase('FOO_BAR')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not in constant case', () => {\n    const shouldThrow = () => assertStringConstantCase('foo.bar')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string in constant case but received: foo.bar')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringConstantCase(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringConstantCase(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringConstantCase(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate in constant case', () => {\n    const value = 'FOO_BAR' as unknown\n    assertStringConstantCase(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression that matches an email address. */\nexport const EXP_EMAIL = /^[\\w!#$%&'*+./=?^`{|}~-]+@[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?(?:\\.[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?)*$/i\n\n/** A string that must contain an `@` character. */\nexport type Email = `${string}@${string}`\n\n/**\n * Assert that a value is a string and that it matches an email pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as an email.\n * @throws `ValidationError` if the value is not an email.\n * @example assertStringEmail('john.doe@acme.com') // void\n */\nexport function assertStringEmail(value: unknown): asserts value is Email {\n  assertString(value)\n  if (EXP_EMAIL.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMAIL',\n    message: `Expected value to be an email but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an email', () => {\n    const result = assertStringEmail('john.doe@acme.com')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an email', () => {\n    const shouldThrow = () => assertStringEmail('john.doe@')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an email but received: john.doe@')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmail(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmail(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmail(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an email', () => {\n    const value = 'john.doe@acme.com' as unknown\n    assertStringEmail(value)\n    expectTypeOf(value).toEqualTypeOf<`${string}@${string}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is empty. An empty string is a\n * string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as an empty string.\n * @throws `ValidationError` if the value is not an empty string.\n * @example assertStringEmpty('') // void\n */\nexport function assertStringEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length === 0) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMPTY',\n    message: 'Expected value to be an empty string but received a non-empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an empty string', () => {\n    const result = assertStringEmpty('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is a string with only whitespace characters', () => {\n    const result = assertStringEmpty(' \\n\\t ')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertStringEmpty('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty string but received a non-empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an empty string', () => {\n    const value = '' as unknown\n    assertStringEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that ends with the given string.\n *\n * @param value The value to assert as a string ending with the given string.\n * @param end The string to match the end of the value against.\n * @throws `ValidationError` if the value is not a string or does not end with the given string.\n * @example assertStringEndingWith('Hello, World!', 'World!') // void\n */\n\nexport function assertStringEndingWith<T extends string>(value: unknown, end: T): asserts value is `${string}${T}` {\n  assertString(value)\n  if (value.endsWith(end)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ENDING_WITH',\n    message: `Expected value to be a string ending with \"${end}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = assertStringEndingWith('Hello, World!', 'World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEndingWith(1, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not end with the given string', () => {\n    const shouldThrow = () => assertStringEndingWith('Hello, World!', 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string ending with \"Hello\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEndingWith(undefined, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEndingWith(null, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEndingWith(value, 'World!')\n    expectTypeOf(value).toEqualTypeOf<`${string}World!`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string is one of the values in an array.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param values The values to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!']) // void\n */\nexport function assertStringEnum<T extends string>(value: unknown, values: T[]): asserts value is T {\n  assertString(value)\n  if (values.includes(value as T)) return\n  const messageValues = values.map(x => `'${x}'`).join(', ')\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ONE_OF_VALUES',\n    message: `Expected value to be one of the following values: ${messageValues} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string is one of the values in an array', () => {\n    const result = assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!'])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEnum(1, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is not one of the values in an array', () => {\n    const shouldThrow = () => assertStringEnum('Hello, World!', ['Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be one of the following values: \\'Hello, Universe!\\' but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEnum(undefined, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEnum(null, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEnum(value, ['Hello, World!', 'Hello, Universe!'])\n    expectTypeOf(value).toEqualTypeOf< 'Hello, Universe!' | 'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that strictly equals a given string.\n *\n * @param value The value to assert as a string equal to the given string.\n * @param expected The string to compare the value against.\n * @throws `ValidationError` if the value is not a string or does not equal the expected string.\n * @example assertStringEqual('Hello, World!', 'Hello, World!') // void\n */\nexport function assertStringEquals<T extends string>(value: unknown, expected: T): asserts value is T {\n  assertString(value)\n  if (value === expected) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EQUAL',\n    message: `Expected value to be a string equal to ${expected} but received: ${value}`,\n  })\n}\n\n/* v8 ignore next */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = assertStringEquals('Hello, World!', 'Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEquals(1, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not equal the expected string', () => {\n    const shouldThrow = () => assertStringEquals('Hello, World!', 'Hello, World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string equal to Hello, World but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEquals(undefined, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEquals(null, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string equal to the expected string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEquals(value, 'Hello, World!')\n    expectTypeOf(value).toEqualTypeOf<'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that matches a regular expression.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param exp The regular expression to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringMatching('Hello, World!', /Hello, \\w+!/) // void\n */\nexport function assertStringMatching(value: unknown, exp: RegExp): asserts value is string {\n  assertString(value)\n  if (exp.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_MATCHING_REGULAR_EXPRESSION',\n    message: `Expected value to be a string matching the regular expression but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string matching a regular expression', () => {\n    const result = assertStringMatching('Hello, World!', /Hello, \\w+!/)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringMatching(1, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not match the regular expression', () => {\n    const shouldThrow = () => assertStringMatching('Hello, World!', /Hello, \\d+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n\n    const shouldThrow = () => assertStringMatching(undefined, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringMatching(null, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringMatching(value, /Hello, \\w+!/)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n// assertStringNumber.ts\n/** Regular expression that matches a string representation of a number. */\nconst EXP_NUMBER = /^[+-]?\\d+(?:\\.\\d+)?$/\n\n/**\n * Assert that a value is a string and can be converted to a number.\n *\n * @param value The value to assert as a string number.\n * @throws `ValidationError` if the value is not a string number.\n * @example assertStringNumber('5') // void\n */\nexport function assertStringNumber(value: unknown): asserts value is `${number}` {\n  assertString(value)\n  if (EXP_NUMBER.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_STRING_NUMBER',\n    message: `Expected value to be a string representation of a number but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string number', () => {\n    const result = assertStringNumber('5')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string number', () => {\n    const shouldThrow = () => assertStringNumber('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string representation of a number but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string number', () => {\n    const value = '5' as unknown\n    assertStringNumber(value)\n    expectTypeOf(value).toEqualTypeOf<`${number}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that starts the given string.\n *\n * @param value The value to assert as a string starting with the given string.\n * @param start The string to match the start of the value against.\n * @throws `ValidationError` if the value is not a string or does not start with the given string.\n */\nexport function assertStringStartingWith<T extends string>(value: unknown, start: T): asserts value is `${T}${string}` {\n  assertString(value)\n  if (value.startsWith(start)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_STARTING_WITH',\n    message: `Expected value to be a string starting with \"${start}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = assertStringStartingWith('Hello, World!', 'Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringStartingWith(1, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not start with the given string', () => {\n    const shouldThrow = () => assertStringStartingWith('Hello, World!', 'World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string starting with \"World\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringStartingWith(undefined, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringStartingWith(null, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringStartingWith(value, 'Hello')\n    expectTypeOf(value).toEqualTypeOf<`Hello${string}`>()\n  })\n}\n","import type { UUID } from 'node:crypto'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression for a UUID. */\nexport const EXP_UUID = /^(?:[\\da-f]{8}-[\\da-f]{4}-[1-5][\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i\n\n/**\n * Assert that a value is a UUID as specified by [RFC 4122](https://www.ietf.org/rfc/rfc4122.txt).\n *\n * @param value The value to assert as a UUID.\n * @throws `ValidationError` if the value is not a UUID.\n * @example assertStringUuid('00000000-0000-0000-0000-000000000000') // void\n */\nexport function assertStringUuid(value: unknown): asserts value is UUID {\n  assertString(value)\n  if (EXP_UUID.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_UUID',\n    message: `Expected value to be a UUID but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a UUID', () => {\n    const result = assertStringUuid('00000000-0000-0000-0000-000000000000')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a UUID', () => {\n    const shouldThrow = () => assertStringUuid('not-a-uuid')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a UUID but received: not-a-uuid')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringUuid(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringUuid(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringUuid(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a UUID', () => {\n    const value = '00000000-0000-0000-0000-000000000000' as unknown\n    assertStringUuid(value)\n    expectTypeOf(value).toEqualTypeOf<UUID>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `true`.\n *\n * @param value The value to assert as a boolean equal to `true`.\n * @throws `ValidationError` if the value is not a boolean equal to `true`.\n * @example assertTrue(true) // void\n */\nexport function assertTrue(value: unknown): asserts value is true {\n  assertBoolean(value)\n  if (value === true) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_TRUE',\n    message: `Expected value to be a boolean equal to true but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to true', () => {\n    const result = assertTrue(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to true', () => {\n    const shouldThrow = () => assertTrue(false)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to true but received: false')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertTrue(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertTrue(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertTrue(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to true', () => {\n    const value = true as unknown\n    assertTrue(value)\n    expectTypeOf(value).toEqualTypeOf<true>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `undefined`.\n *\n * @param value The value to assert as `undefined`.\n * @throws `ValidationError` if the value is not `undefined`.\n * @example assertUndefined(undefined) // void\n */\nexport function assertUndefined(value: unknown): asserts value is undefined {\n  if (value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_UNDEFINED',\n    message: `Expected value to be undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertUndefined(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not undefined', () => {\n    const shouldThrow = () => assertUndefined(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: number')\n  })\n\n  test('should throw if value is not undefined', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertUndefined(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: null')\n  })\n\n  test('should predicate an undefined', () => {\n    const value = undefined as unknown\n    assertUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { assertInstance } from './assertInstance'\n\n/**\n * Create an assertion function that asserts a value is an instance of the given class.\n *\n * @param ctor The class to assert the value is an instance of.\n * @returns An assertion function that asserts a value is an instance of the given class.\n * @example const assertDate = createAssertInstance(Date) // (value: unknown) => asserts value is Date\n */\nexport function createAssertInstance<T extends object>(ctor: Constructor<T>) {\n  return (value: unknown): asserts value is T => assertInstance(value, ctor)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertInstance(Date)(new Date())\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertInstance(Date)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is Date>()\n  })\n}\n","import { assertNumberBetween } from './assertNumberBetween'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetween(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetween(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetween(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetween(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetween(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertNumberBetweenStrict } from './assertNumberBetweenStrict'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetweenStrict(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetweenStrict(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetweenStrict(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertStringEndingWith } from './assertStringEndingWith'\n\n/**\n * Create a function to assert that a value is a string ending with the given string.\n *\n * @param end The string to match the end of the value against.\n * @returns A function that asserts that a value is a string ending with the given string.\n * @example const isWorld = assertStringEndingWith('World') // (value: unknown) => asserts value is `${string}World`\n */\nexport function createAssertStringEndingWith<T extends string>(end: T) {\n  return (value: unknown): asserts value is `${string}${T}` => assertStringEndingWith(value, end)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `${string}World`>()\n  })\n}\n","import { assertStringEnum } from './assertStringEnum'\n\n/**\n * Create a predicate function that asserts that a value is a string that is one of the values in an array.\n *\n * @param values The values to match the value against.\n * @returns A predicate function that asserts that a value is a string that is one of the values in an array.\n * @example const isHello = createAssertStringEnum(['Hello', 'World']) // (value: unknown) => asserts value is 'Hello' | 'World'\n */\nexport function createAssertStringEnum<T extends string>(values: T[]) {\n  return (value: unknown): asserts value is T => assertStringEnum(value, values)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string in the array', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])('Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string union', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello' | 'World'>()\n  })\n}\n","import { assertStringEquals } from './assertStringEquals'\n\n/**\n * Create a parse function that can be used to assert a string is striclty equal to a given value.\n *\n * @param expected The value to assert the string is equal to.\n * @returns A parser function that can be used to assert a string is striclty equal to a given value.\n * @example const parse = createAssertStringEqual('foo') // (value: unknown) => value is 'foo'\n */\nexport function createAssertStringEquals<T extends string>(expected: T) {\n  return (value: unknown): asserts value is T => assertStringEquals(value, expected)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = createAssertStringEquals('Hello, World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string literal', () => {\n    const result = createAssertStringEquals('Hello, World!')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello, World!'>()\n  })\n}\n","import { assertStringStartingWith } from './assertStringStartingWith'\n\n/**\n * Create a function to assert that a value is a string starting with the given string.\n *\n * @param start The string to match the start of the value against.\n * @returns A function that asserts that a value is a string starting with the given string.\n * @example const isHello = assertStringStartingWith('Hello') // (value: unknown) => asserts value is `Hello${string}`\n */\nexport function createAssertStringStartingWith<T extends string>(start: T) {\n  return (value: unknown): asserts value is `${T}${string}` => assertStringStartingWith(value, start)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `Hello${string}`>()\n  })\n}\n"],"names":["ValidationError","kindOf","toConstantCase"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"assert.cjs","sources":["../assert/assertArray.ts","../assert/assertArrayEmpty.ts","../assert/assertArrayNotEmpty.ts","../assert/assertBoolean.ts","../assert/assertFalse.ts","../assert/assertFalsy.ts","../assert/assertFunction.ts","../assert/assertInstance.ts","../assert/assertNil.ts","../assert/assertNotNil.ts","../assert/assertNotNull.ts","../assert/assertNotUndefined.ts","../assert/assertNull.ts","../assert/assertNumber.ts","../assert/assertNumberBetween.ts","../assert/assertNumberBetweenStrict.ts","../assert/assertNumberInteger.ts","../assert/assertNumberEven.ts","../assert/assertNumberNegative.ts","../assert/assertNumberNegativeStrict.ts","../assert/assertNumberOdd.ts","../assert/assertNumberPositive.ts","../assert/assertNumberPositiveStrict.ts","../assert/assertObject.ts","../assert/assertString.ts","../assert/assertStringNotEmpty.ts","../assert/assertStringConstantCase.ts","../assert/assertStringEmail.ts","../assert/assertStringEmpty.ts","../assert/assertStringEndingWith.ts","../assert/assertStringEnum.ts","../assert/assertStringEquals.ts","../assert/assertStringMatching.ts","../assert/assertStringNumber.ts","../assert/assertStringStartingWith.ts","../assert/assertStringUuid.ts","../assert/assertTrue.ts","../assert/assertUndefined.ts","../assert/createAssertInstance.ts","../assert/createAssertNumberBetween.ts","../assert/createAssertNumberBetweenStrict.ts","../assert/createAssertStringEndingWith.ts","../assert/createAssertStringEnum.ts","../assert/createAssertStringEquals.ts","../assert/createAssertStringStartingWith.ts"],"sourcesContent":["import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an array.\n *\n * @param value The value to assert as an array.\n * @throws `ValidationError` if the value is not an array.\n * @example assertArray(['Hello, World!']) // void\n */\nexport function assertArray<T>(value: unknown): asserts value is T[] {\n  if (Array.isArray(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_ARRAY',\n    message: `Expected value to be an array but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an array', () => {\n    const result = assertArray([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArray({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertArray(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertArray(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n  })\n\n  test('should predicate an array', () => {\n    const value = [] as unknown\n    assertArray(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate an array of string if a generic is provided', () => {\n    const value = [] as unknown\n    assertArray<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is an empty array.\n *\n * @param value The value to assert as an empty array.\n * @throws `ValidationError` if the value is not an empty array.\n * @example assertArrayEmpty([]) // void\n */\nexport function assertArrayEmpty(value: unknown): asserts value is [] {\n  assertArray(value)\n  if (value.length === 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_NOT_EMPTY',\n    message: `Expected value to be an empty array but actually received an array with ${value.length} items`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should pass if value is an empty array', () => {\n    const result = assertArrayEmpty([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an empty array', () => {\n    const shouldThrow = () => assertArrayEmpty([1])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty array but actually received an array with 1 items')\n  })\n\n  test('should predicate an empty array', () => {\n    const value = [] as unknown\n    assertArrayEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is a non-empty array.\n *\n * @param value The value to assert as a non-empty array.\n * @throws `ValidationError` if the value is not a non-empty array.\n * @example assertArrayNotEmpty(['Hello, World!']) // void\n */\nexport function assertArrayNotEmpty<T>(value: unknown): asserts value is T[] {\n  assertArray(value)\n  if (value.length > 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_EMPTY',\n    message: 'Expected value to be a non-empty array but received an empty array.',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty array', () => {\n    const result = assertArrayNotEmpty([1])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty array', () => {\n    const shouldThrow = () => assertArrayNotEmpty([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty array but received an empty array.')\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayNotEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should predicate a non-empty array', () => {\n    const value = [1] as unknown\n    assertArrayNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate a non-empty array of string if a generic is provided', () => {\n    const value = ['Hello, World!'] as unknown\n    assertArrayNotEmpty<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a boolean.\n *\n * @param value The value to assert as a boolean.\n * @throws `ValidationError` if the value is not a boolean.\n * @example assertBoolean(true) // void\n */\nexport function assertBoolean(value: unknown): asserts value is boolean {\n  if (typeof value === 'boolean') return\n  throw new ValidationError({\n    name: 'E_NOT_BOOLEAN',\n    message: `Expected value to be a boolean but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean', () => {\n    const result = assertBoolean(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertBoolean(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertBoolean(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertBoolean(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean', () => {\n    const value = true as unknown\n    assertBoolean(value)\n    expectTypeOf(value).toEqualTypeOf<boolean>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `false`.\n *\n * @param value The value to assert as a boolean equal to `false`.\n * @throws `ValidationError` if the value is not a boolean equal to `false`.\n * @example assertFalse(false) // void\n */\nexport function assertFalse(value: unknown): asserts value is false {\n  assertBoolean(value)\n  if (value === false) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_FALSE',\n    message: `Expected value to be a boolean equal to false but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalse(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to false', () => {\n    const shouldThrow = () => assertFalse(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to false but received: true')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertFalse(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFalse(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFalse(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to false', () => {\n    const value = false as unknown\n    assertFalse(value)\n    expectTypeOf(value).toEqualTypeOf<false>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is falsy. Meaning it is either `false`, `0`, `''`, `null` or `undefined`.\n *\n * @param value The value to assert as falsy.\n * @throws `ValidationError` if the value is not falsy.\n * @example assertFalsy(false) // void\n */\nexport function assertFalsy(value: unknown): asserts value is '' | 0 | false | null | undefined {\n  if (value) {\n    throw new ValidationError({\n      name: 'E_NOT_FALSY',\n      message: `Expected value to be falsy but received: ${kindOf(value)}`,\n    })\n  }\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalsy(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is 0', () => {\n    const result = assertFalsy(0)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is an empty string', () => {\n    const result = assertFalsy('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertFalsy(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertFalsy(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-zero number', () => {\n    const shouldThrow = () => assertFalsy(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: number')\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertFalsy('hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: string')\n  })\n\n  test('should throw if value is true', () => {\n    const shouldThrow = () => assertFalsy(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: boolean')\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertFalsy({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: object')\n  })\n\n  test('should throw if value is an array', () => {\n    const shouldThrow = () => assertFalsy([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: Array')\n  })\n\n  test('should predicate a falsy value', () => {\n    const value = false as unknown\n    assertFalsy(value)\n    expectTypeOf(value).toEqualTypeOf<'' | 0 | false | null | undefined>()\n  })\n}\n","import type { Function } from '@unshared/types'\nimport { kindOf } from '@unshared/functions'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a function.\n *\n * @param value The value to assert as a function.\n * @throws `ValidationError` if the value is not a function.\n * @example assertFunction(() => {}) // void\n */\nexport function assertFunction<T extends Function>(value: unknown): asserts value is T {\n  if (typeof value === 'function') return\n  throw new ValidationError({\n    name: 'E_NOT_FUNCTION',\n    message: `Expected value to be a function but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a function', () => {\n    const result = assertFunction(() => {})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a function', () => {\n    const shouldThrow = () => assertFunction(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFunction(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFunction(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: null')\n  })\n\n  test('should predicate a function', () => {\n    const value = (() => {}) as unknown\n    assertFunction(value)\n    expectTypeOf(value).toEqualTypeOf<(...args: any[]) => any>()\n  })\n\n  test('should predicate the given function type', () => {\n    const value = (() => {}) as unknown\n    assertFunction<() => void>(value)\n    expectTypeOf(value).toEqualTypeOf<() => void>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an instance of the given class.\n *\n * @param value The value to assert as an instance of the given class.\n * @param ctor The class to assert the value is an instance of.\n * @throws `ValidationError` if the value is not an instance of the given class.\n * @example assertInstance(new Date(), Date) // void\n */\nexport function assertInstance<T extends object>(value: unknown, ctor: Constructor<T>): asserts value is T {\n  if (value instanceof ctor) return\n  throw new ValidationError({\n    name: 'E_NOT_INSTANCE_OF',\n    message: `Expected value to be an instance of ${ctor.name} but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an instance of the given class', () => {\n    const result = assertInstance(new Date(), Date)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an instance of the given class', () => {\n    const shouldThrow = () => assertInstance([], Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertInstance(undefined, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertInstance(null, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: null')\n  })\n\n  test('should predicate an instance of the given class', () => {\n    const value = new Date() as unknown\n    assertInstance(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n\n  test('should predicate an instance of the given class if a generic is provided', () => {\n    const value = new Date() as unknown\n    assertInstance<Date>(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null` or `undefined`.\n *\n * @param value The value to assert as `null` or `undefined`.\n * @throws `ValidationError` if the value is neither `null` nor `undefined`.\n * @example assertNil(null) // void\n */\nexport function assertNil(value: unknown): asserts value is null | undefined {\n  if (value === null || value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_NIL',\n    message: `Expected value to be null or undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNil(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNil(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNil({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null or undefined but received: object')\n  })\n\n  test('should predicate a null or undefined union', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNil(value)\n    expectTypeOf(value).toEqualTypeOf<null | undefined>()\n  })\n}\n","import type { NotNil } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null` or `undefined`.\n *\n * @param value The value to assert as not `null` or `undefined`.\n * @throws `ValidationError` if the value is `null` or `undefined`.\n * @example assertNotNil(1) // void\n */\nexport function assertNotNil<T>(value: T): asserts value is NotNil<T> {\n  if (value !== null && value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_NIL',\n    message: 'Expected value not to be null or undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null or undefined', () => {\n    const result = assertNotNil(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNil(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotNil(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNil(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import type { NotNull } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null`.\n *\n * @param value The value to assert as not `null`.\n * @throws `ValidationError` if the value is `null`.\n * @example assertNotNull(1) // void\n */\nexport function assertNotNull<T>(value: T): asserts value is NotNull<T> {\n  if (value !== null) return\n  throw new ValidationError({\n    name: 'E_IS_NULL',\n    message: 'Expected value not to be null',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null', () => {\n    const result = assertNotNull(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNotNull(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNull(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNull(value)\n    expectTypeOf(value).toEqualTypeOf<number | undefined>()\n  })\n}\n","import type { NotUndefined } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `undefined`.\n *\n * @param value The value to assert as not `undefined`.\n * @throws `ValidationError` if the value is `undefined`.\n * @example assertNotUndefined(1) // void\n */\nexport function assertNotUndefined<T>(value: T): asserts value is NotUndefined<T> {\n  if (value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_UNDEFINED',\n    message: 'Expected value not to be undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not undefined', () => {\n    const result = assertNotUndefined(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNotUndefined(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotUndefined(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<null | number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null`.\n *\n * @param value The value to assert as `null`.\n * @throws `ValidationError` if the value is not `null`.\n * @example assertNull(null) // void\n */\nexport function assertNull(value: unknown): asserts value is null {\n  if (value === null) return\n  throw new ValidationError({\n    name: 'E_NOT_NULL',\n    message: `Expected value to be null but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNull(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNull({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNull(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: undefined')\n  })\n\n  test('should predicate a null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNull(value)\n    expectTypeOf(value).toEqualTypeOf<null>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a number.\n *\n * @param value The value to assert as a number.\n * @throws `ValidationError` if the value is not a number.\n * @example assertNumber(1) // void\n */\nexport function assertNumber(value: unknown): asserts value is number {\n  if (typeof value === 'number') return\n  throw new ValidationError({\n    name: 'E_NOT_NUMBER',\n    message: `Expected value to be a number but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number', () => {\n    const result = assertNumber(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumber('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number', () => {\n    const value = 1 as unknown\n    assertNumber(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number between or equal a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The minimum value that the number can be.\n * @param max The maximum value that the number can be.\n */\nexport function assertNumberBetween(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value >= min && value <= max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetween(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to min', () => {\n    const result = assertNumberBetween(1, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to max', () => {\n    const result = assertNumberBetween(10, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetween(0, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 0')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetween(11, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 11')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetween('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetween(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetween(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetween(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly between a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @throws `ValidationError` if the value is not strictly between the minimum and maximum value.\n * @example assertNumberBetweenStrict(5, 1, 10) // void\n */\nexport function assertNumberBetweenStrict(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value > min && value < max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN_STRICT',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetweenStrict(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is equal to min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is equal to max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetweenStrict('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetweenStrict(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetweenStrict(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is an integer number.\n *\n * @param value The value to assert as an integer number.\n * @throws `ValidationError` if the value is not an integer number.\n * @example assertNumberInteger(1) // void\n */\nexport function assertNumberInteger(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (!Number.isSafeInteger(value)) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_INTEGER',\n      message: `Expected value to be an integer number but received decimal value: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an integer number', () => {\n    const result = assertNumberInteger(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberInteger('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is not an integer number', () => {\n    const shouldThrow = () => assertNumberInteger(1.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 1.1')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberInteger(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberInteger(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an integer number', () => {\n    const value = 1 as unknown\n    assertNumberInteger(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an even number.\n *\n * @param value The value to assert as an even number.\n * @throws `ValidationError` if the value is not an even number.\n * @example assertNumberEven(2) // true\n */\nexport function assertNumberEven(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 1) !== 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_EVEN',\n      message: `Expected value to be an even number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an even number', () => {\n    const result = assertNumberEven(2)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an odd number', () => {\n    const shouldThrow = () => assertNumberEven(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an even number but received: 1')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberEven(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberEven('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberEven(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberEven(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an even number', () => {\n    const value = 2 as unknown\n    assertNumberEven(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number less than or equal to `0`.\n *\n * @param value The value to assert as a number less than or equal to `0`.\n * @throws `ValidationError` if the value is not a number less than or equal to `0`.\n * @example assertNumberNegative(-1) // void\n */\nexport function assertNumberNegative(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value <= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE',\n    message: `Expected value to be a number less than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than or equal to 0', () => {\n    const result = assertNumberNegative(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than or equal to 0', () => {\n    const shouldThrow = () => assertNumberNegative(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number less than or equal to 0 but received: 1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegative('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegative(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegative(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than or equal to 0', () => {\n    const value = -1 as unknown\n    assertNumberNegative(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number less than `0`.\n *\n * @param value The value to assert as a number less than `0`.\n * @throws `ValidationError` if the value is not a number less than `0`.\n * @example assertNumberNegativeStrict(-1) // void\n */\nexport function assertNumberNegativeStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value < 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE_STRICT',\n    message: `Expected value to be a number strictly less than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than 0', () => {\n    const result = assertNumberNegativeStrict(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than 0', () => {\n    const shouldThrow = () => assertNumberNegativeStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly less than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegativeStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegativeStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegativeStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than 0', () => {\n    const value = -1 as unknown\n    assertNumberNegativeStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an odd number.\n *\n * @param value The value to assert as an odd number.\n * @throws `ValidationError` if the value is not an odd number.\n * @example assertNumberOdd(1) // true\n */\nexport function assertNumberOdd(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 0x1) === 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_ODD',\n      message: `Expected value to be an odd number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an odd number', () => {\n    const result = assertNumberOdd(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an even number', () => {\n    const shouldThrow = () => assertNumberOdd(2)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an odd number but received: 2')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberOdd(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberOdd('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberOdd(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberOdd(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an odd number', () => {\n    const value = 1 as unknown\n    assertNumberOdd(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number greater than or equal to `0`.\n *\n * @param value The value to assert as a number greater than or equal to `0`.\n * @throws `ValidationError` if the value is not a number greater than or equal to `0`.\n * @example assertNumberPositive(1) // void\n */\nexport function assertNumberPositive(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value >= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE',\n    message: `Expected value to be a number greater than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than or equal to 0', () => {\n    const result = assertNumberPositive(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than or equal to 0', () => {\n    const shouldThrow = () => assertNumberPositive(-1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number greater than or equal to 0 but received: -1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositive('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositive(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositive(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than or equal to 0', () => {\n    const value = 1 as unknown\n    assertNumberPositive(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number greater than `0`.\n *\n * @param value The value to assert as a number greater than `0`.\n * @throws `ValidationError` if the value is not a number greater than `0`.\n * @example assertNumberPositiveStrict(1) // void\n */\nexport function assertNumberPositiveStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value > 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE_STRICT',\n    message: `Expected value to be a number strictly greater than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than 0', () => {\n    const result = assertNumberPositiveStrict(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than 0', () => {\n    const shouldThrow = () => assertNumberPositiveStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly greater than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositiveStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositiveStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositiveStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than 0', () => {\n    const value = 1 as unknown\n    assertNumberPositiveStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an object.\n *\n * @param value The value to assert as an object.\n * @throws `ValidationError` if the value is not an object.\n * @example assertObject({}) // void\n */\nexport function assertObject<T extends object>(value: unknown): asserts value is T {\n  if (kindOf(value) === 'object') return\n  throw new ValidationError({\n    name: 'E_NOT_OBJECT',\n    message: `Expected value to be an object but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an object', () => {\n    const result = assertObject({})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an object', () => {\n    const shouldThrow = () => assertObject([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertObject(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertObject(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: null')\n  })\n\n  test('should predicate an object', () => {\n    const value = {} as unknown\n    assertObject(value)\n    expectTypeOf(value).toEqualTypeOf<object>()\n  })\n\n  test('should predicate an object of Record<string, unknown> if a generic is provided', () => {\n    const value = {} as unknown\n    assertObject<Record<string, unknown>>(value)\n    expectTypeOf(value).toEqualTypeOf<Record<string, unknown>>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a string.\n *\n * @param value The value to assert as a string.\n * @throws `ValidationError` if the value is not a string.\n * @example assertString('Hello, World!') // void\n */\nexport function assertString(value: unknown): asserts value is string {\n  if (typeof value === 'string') return\n  throw new ValidationError({\n    name: 'E_NOT_STRING',\n    message: `Expected value to be a string but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string', () => {\n    const result = assertString('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertString(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertString(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertString(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string', () => {\n    const value = 'Hello, World!' as unknown\n    assertString(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is not empty. An empty string\n * is a string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as a non-empty string.\n * @throws `ValidationError` if the value is not a non-empty string.\n * @example assertStringNotEmpty('Hello, World!') // void\n */\nexport function assertStringNotEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length > 0) return\n  throw new ValidationError({\n    name: 'E_STRING_EMPTY',\n    message: 'Expected value to be a non-empty string but received an empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty string', () => {\n    const result = assertStringNotEmpty('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty string', () => {\n    const shouldThrow = () => assertStringNotEmpty('')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is a string with only whitespace characters', () => {\n    const shouldThrow = () => assertStringNotEmpty(' \\n\\t ')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringNotEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNotEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNotEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a non-empty string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { toConstantCase } from '@unshared/string/toConstantCase'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\nimport { assertStringNotEmpty } from './assertStringNotEmpty'\n\n/**\n * Assert that a value is a string and that it matches in constant case pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as in constant case.\n * @throws `ValidationError` if the value is not in constant case.\n * @example assertStringConstantCase('john.doe@acme.com') // void\n */\nexport function assertStringConstantCase(value: unknown): asserts value is string {\n  assertString(value)\n  assertStringNotEmpty(value)\n  if (value === toConstantCase(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_CONSTANT_CASE',\n    message: `Expected value to be a string in constant case but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is in constant case', () => {\n    const result = assertStringConstantCase('FOO_BAR')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not in constant case', () => {\n    const shouldThrow = () => assertStringConstantCase('foo.bar')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string in constant case but received: foo.bar')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringConstantCase(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringConstantCase(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringConstantCase(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate in constant case', () => {\n    const value = 'FOO_BAR' as unknown\n    assertStringConstantCase(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression that matches an email address. */\nexport const EXP_EMAIL = /^[\\w!#$%&'*+./=?^`{|}~-]+@[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?(?:\\.[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?)*$/i\n\n/** A string that must contain an `@` character. */\nexport type Email = `${string}@${string}`\n\n/**\n * Assert that a value is a string and that it matches an email pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as an email.\n * @throws `ValidationError` if the value is not an email.\n * @example assertStringEmail('john.doe@acme.com') // void\n */\nexport function assertStringEmail(value: unknown): asserts value is Email {\n  assertString(value)\n  if (EXP_EMAIL.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMAIL',\n    message: `Expected value to be an email but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an email', () => {\n    const result = assertStringEmail('john.doe@acme.com')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an email', () => {\n    const shouldThrow = () => assertStringEmail('john.doe@')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an email but received: john.doe@')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmail(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmail(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmail(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an email', () => {\n    const value = 'john.doe@acme.com' as unknown\n    assertStringEmail(value)\n    expectTypeOf(value).toEqualTypeOf<`${string}@${string}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is empty. An empty string is a\n * string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as an empty string.\n * @throws `ValidationError` if the value is not an empty string.\n * @example assertStringEmpty('') // void\n */\nexport function assertStringEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length === 0) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMPTY',\n    message: 'Expected value to be an empty string but received a non-empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an empty string', () => {\n    const result = assertStringEmpty('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is a string with only whitespace characters', () => {\n    const result = assertStringEmpty(' \\n\\t ')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertStringEmpty('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty string but received a non-empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an empty string', () => {\n    const value = '' as unknown\n    assertStringEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that ends with the given string.\n *\n * @param value The value to assert as a string ending with the given string.\n * @param end The string to match the end of the value against.\n * @throws `ValidationError` if the value is not a string or does not end with the given string.\n * @example assertStringEndingWith('Hello, World!', 'World!') // void\n */\n\nexport function assertStringEndingWith<T extends string>(value: unknown, end: T): asserts value is `${string}${T}` {\n  assertString(value)\n  if (value.endsWith(end)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ENDING_WITH',\n    message: `Expected value to be a string ending with \"${end}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = assertStringEndingWith('Hello, World!', 'World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEndingWith(1, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not end with the given string', () => {\n    const shouldThrow = () => assertStringEndingWith('Hello, World!', 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string ending with \"Hello\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEndingWith(undefined, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEndingWith(null, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEndingWith(value, 'World!')\n    expectTypeOf(value).toEqualTypeOf<`${string}World!`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string is one of the values in an array.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param values The values to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!']) // void\n */\nexport function assertStringEnum<T extends string>(value: unknown, values: T[]): asserts value is T {\n  assertString(value)\n  if (values.includes(value as T)) return\n  const messageValues = values.map(x => `'${x}'`).join(', ')\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ONE_OF_VALUES',\n    message: `Expected value to be one of the following values: ${messageValues} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string is one of the values in an array', () => {\n    const result = assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!'])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEnum(1, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is not one of the values in an array', () => {\n    const shouldThrow = () => assertStringEnum('Hello, World!', ['Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be one of the following values: \\'Hello, Universe!\\' but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEnum(undefined, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEnum(null, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEnum(value, ['Hello, World!', 'Hello, Universe!'])\n    expectTypeOf(value).toEqualTypeOf< 'Hello, Universe!' | 'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that strictly equals a given string.\n *\n * @param value The value to assert as a string equal to the given string.\n * @param expected The string to compare the value against.\n * @throws `ValidationError` if the value is not a string or does not equal the expected string.\n * @example assertStringEqual('Hello, World!', 'Hello, World!') // void\n */\nexport function assertStringEquals<T extends string>(value: unknown, expected: T): asserts value is T {\n  assertString(value)\n  if (value === expected) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EQUAL',\n    message: `Expected value to be a string equal to ${expected} but received: ${value}`,\n  })\n}\n\n/* v8 ignore next */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = assertStringEquals('Hello, World!', 'Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEquals(1, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not equal the expected string', () => {\n    const shouldThrow = () => assertStringEquals('Hello, World!', 'Hello, World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string equal to Hello, World but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEquals(undefined, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEquals(null, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string equal to the expected string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEquals(value, 'Hello, World!')\n    expectTypeOf(value).toEqualTypeOf<'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that matches a regular expression.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param exp The regular expression to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringMatching('Hello, World!', /Hello, \\w+!/) // void\n */\nexport function assertStringMatching(value: unknown, exp: RegExp): asserts value is string {\n  assertString(value)\n  if (exp.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_MATCHING_REGULAR_EXPRESSION',\n    message: `Expected value to be a string matching the regular expression but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string matching a regular expression', () => {\n    const result = assertStringMatching('Hello, World!', /Hello, \\w+!/)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringMatching(1, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not match the regular expression', () => {\n    const shouldThrow = () => assertStringMatching('Hello, World!', /Hello, \\d+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n\n    const shouldThrow = () => assertStringMatching(undefined, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringMatching(null, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringMatching(value, /Hello, \\w+!/)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n// assertStringNumber.ts\n/** Regular expression that matches a string representation of a number. */\nconst EXP_NUMBER = /^[+-]?\\d+(?:\\.\\d+)?$/\n\n/**\n * Assert that a value is a string and can be converted to a number.\n *\n * @param value The value to assert as a string number.\n * @throws `ValidationError` if the value is not a string number.\n * @example assertStringNumber('5') // void\n */\nexport function assertStringNumber(value: unknown): asserts value is `${number}` {\n  assertString(value)\n  if (EXP_NUMBER.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_STRING_NUMBER',\n    message: `Expected value to be a string representation of a number but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string number', () => {\n    const result = assertStringNumber('5')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string number', () => {\n    const shouldThrow = () => assertStringNumber('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string representation of a number but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string number', () => {\n    const value = '5' as unknown\n    assertStringNumber(value)\n    expectTypeOf(value).toEqualTypeOf<`${number}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that starts the given string.\n *\n * @param value The value to assert as a string starting with the given string.\n * @param start The string to match the start of the value against.\n * @throws `ValidationError` if the value is not a string or does not start with the given string.\n */\nexport function assertStringStartingWith<T extends string>(value: unknown, start: T): asserts value is `${T}${string}` {\n  assertString(value)\n  if (value.startsWith(start)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_STARTING_WITH',\n    message: `Expected value to be a string starting with \"${start}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = assertStringStartingWith('Hello, World!', 'Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringStartingWith(1, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not start with the given string', () => {\n    const shouldThrow = () => assertStringStartingWith('Hello, World!', 'World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string starting with \"World\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringStartingWith(undefined, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringStartingWith(null, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringStartingWith(value, 'Hello')\n    expectTypeOf(value).toEqualTypeOf<`Hello${string}`>()\n  })\n}\n","import type { UUID } from 'node:crypto'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression for a UUID. */\nexport const EXP_UUID = /^(?:[\\da-f]{8}-[\\da-f]{4}-[1-5][\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i\n\n/**\n * Assert that a value is a UUID as specified by [RFC 4122](https://www.ietf.org/rfc/rfc4122.txt).\n *\n * @param value The value to assert as a UUID.\n * @throws `ValidationError` if the value is not a UUID.\n * @example assertStringUuid('00000000-0000-0000-0000-000000000000') // void\n */\nexport function assertStringUuid(value: unknown): asserts value is UUID {\n  assertString(value)\n  if (EXP_UUID.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_UUID',\n    message: `Expected value to be a UUID but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a UUID', () => {\n    const result = assertStringUuid('00000000-0000-0000-0000-000000000000')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a UUID', () => {\n    const shouldThrow = () => assertStringUuid('not-a-uuid')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a UUID but received: not-a-uuid')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringUuid(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringUuid(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringUuid(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a UUID', () => {\n    const value = '00000000-0000-0000-0000-000000000000' as unknown\n    assertStringUuid(value)\n    expectTypeOf(value).toEqualTypeOf<UUID>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `true`.\n *\n * @param value The value to assert as a boolean equal to `true`.\n * @throws `ValidationError` if the value is not a boolean equal to `true`.\n * @example assertTrue(true) // void\n */\nexport function assertTrue(value: unknown): asserts value is true {\n  assertBoolean(value)\n  if (value === true) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_TRUE',\n    message: `Expected value to be a boolean equal to true but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to true', () => {\n    const result = assertTrue(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to true', () => {\n    const shouldThrow = () => assertTrue(false)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to true but received: false')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertTrue(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertTrue(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertTrue(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to true', () => {\n    const value = true as unknown\n    assertTrue(value)\n    expectTypeOf(value).toEqualTypeOf<true>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `undefined`.\n *\n * @param value The value to assert as `undefined`.\n * @throws `ValidationError` if the value is not `undefined`.\n * @example assertUndefined(undefined) // void\n */\nexport function assertUndefined(value: unknown): asserts value is undefined {\n  if (value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_UNDEFINED',\n    message: `Expected value to be undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertUndefined(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not undefined', () => {\n    const shouldThrow = () => assertUndefined(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: number')\n  })\n\n  test('should throw if value is not undefined', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertUndefined(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: null')\n  })\n\n  test('should predicate an undefined', () => {\n    const value = undefined as unknown\n    assertUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { assertInstance } from './assertInstance'\n\n/**\n * Create an assertion function that asserts a value is an instance of the given class.\n *\n * @param ctor The class to assert the value is an instance of.\n * @returns An assertion function that asserts a value is an instance of the given class.\n * @example const assertDate = createAssertInstance(Date) // (value: unknown) => asserts value is Date\n */\nexport function createAssertInstance<T extends object>(ctor: Constructor<T>) {\n  return (value: unknown): asserts value is T => assertInstance(value, ctor)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertInstance(Date)(new Date())\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertInstance(Date)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is Date>()\n  })\n}\n","import { assertNumberBetween } from './assertNumberBetween'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetween(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetween(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetween(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetween(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetween(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertNumberBetweenStrict } from './assertNumberBetweenStrict'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetweenStrict(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetweenStrict(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetweenStrict(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertStringEndingWith } from './assertStringEndingWith'\n\n/**\n * Create a function to assert that a value is a string ending with the given string.\n *\n * @param end The string to match the end of the value against.\n * @returns A function that asserts that a value is a string ending with the given string.\n * @example const isWorld = assertStringEndingWith('World') // (value: unknown) => asserts value is `${string}World`\n */\nexport function createAssertStringEndingWith<T extends string>(end: T) {\n  return (value: unknown): asserts value is `${string}${T}` => assertStringEndingWith(value, end)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `${string}World`>()\n  })\n}\n","import { assertStringEnum } from './assertStringEnum'\n\n/**\n * Create a predicate function that asserts that a value is a string that is one of the values in an array.\n *\n * @param values The values to match the value against.\n * @returns A predicate function that asserts that a value is a string that is one of the values in an array.\n * @example const isHello = createAssertStringEnum(['Hello', 'World']) // (value: unknown) => asserts value is 'Hello' | 'World'\n */\nexport function createAssertStringEnum<T extends string>(values: T[]) {\n  return (value: unknown): asserts value is T => assertStringEnum(value, values)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string in the array', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])('Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string union', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello' | 'World'>()\n  })\n}\n","import { assertStringEquals } from './assertStringEquals'\n\n/**\n * Create a parse function that can be used to assert a string is striclty equal to a given value.\n *\n * @param expected The value to assert the string is equal to.\n * @returns A parser function that can be used to assert a string is striclty equal to a given value.\n * @example const parse = createAssertStringEqual('foo') // (value: unknown) => value is 'foo'\n */\nexport function createAssertStringEquals<T extends string>(expected: T) {\n  return (value: unknown): asserts value is T => assertStringEquals(value, expected)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = createAssertStringEquals('Hello, World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string literal', () => {\n    const result = createAssertStringEquals('Hello, World!')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello, World!'>()\n  })\n}\n","import { assertStringStartingWith } from './assertStringStartingWith'\n\n/**\n * Create a function to assert that a value is a string starting with the given string.\n *\n * @param start The string to match the start of the value against.\n * @returns A function that asserts that a value is a string starting with the given string.\n * @example const isHello = assertStringStartingWith('Hello') // (value: unknown) => asserts value is `Hello${string}`\n */\nexport function createAssertStringStartingWith<T extends string>(start: T) {\n  return (value: unknown): asserts value is `${T}${string}` => assertStringStartingWith(value, start)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `Hello${string}`>()\n  })\n}\n"],"names":["ValidationError","kindOf","toConstantCase"],"mappings":";;AAUO,SAAS,YAAe,OAAsC;AAC/D,MAAA,CAAA,MAAM,QAAQ,KAAK;AACvB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+CAA+CC,cAAO,KAAK,CAAC;AAAA,IAAA,CACtE;AACH;ACNO,SAAS,iBAAiB,OAAqC;AAEpE,MADA,YAAY,KAAK,GACb,MAAM,WAAW;AACrB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,2EAA2E,MAAM,MAAM;AAAA,IAAA,CACjG;AACH;ACPO,SAAS,oBAAuB,OAAsC;AAE3E,MADA,YAAY,KAAK,GACb,EAAA,MAAM,SAAS;AACnB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACPO,SAAS,cAAc,OAA0C;AACtE,MAAI,OAAO,SAAU;AACrB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,gDAAgDC,cAAO,KAAK,CAAC;AAAA,IAAA,CACvE;AACH;ACNO,SAAS,YAAY,OAAwC;AAClE,MAAA,cAAc,KAAK,GACf,UAAU;AACd,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+DAA+D,KAAK;AAAA,IAAA,CAC9E;AACH;ACPO,SAAS,YAAY,OAAoE;AAC1F,MAAA;AACF,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,4CAA4CC,cAAO,KAAK,CAAC;AAAA,IAAA,CACnE;AAEL;ACNO,SAAS,eAAmC,OAAoC;AACrF,MAAI,OAAO,SAAU;AACrB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,iDAAiDC,iBAAO,KAAK,CAAC;AAAA,IAAA,CACxE;AACH;ACLgB,SAAA,eAAiC,OAAgB,MAA0C;AACzG,MAAI,EAAiB,iBAAA;AACrB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,uCAAuC,KAAK,IAAI,kBAAkBC,OAAA,OAAO,KAAK,CAAC;AAAA,IAAA,CACzF;AACH;ACRO,SAAS,UAAU,OAAmD;AAC3E,MAAI,SAAU;AACd,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,wDAAwDC,cAAO,KAAK,CAAC;AAAA,IAAA,CAC/E;AACH;ACNO,SAAS,aAAgB,OAAsC;AACpE,MAAI,SAAU;AACd,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACNO,SAAS,cAAiB,OAAuC;AACtE,MAAI,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACNO,SAAS,mBAAsB,OAA4C;AAChF,MAAI,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACNO,SAAS,WAAW,OAAuC;AAChE,MAAI,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,2CAA2CC,cAAO,KAAK,CAAC;AAAA,IAAA,CAClE;AACH;ACNO,SAAS,aAAa,OAAyC;AACpE,MAAI,OAAO,SAAU;AACrB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+CAA+CC,cAAO,KAAK,CAAC;AAAA,IAAA,CACtE;AACH;ACNgB,SAAA,oBAAoB,OAAgB,KAAa,KAAsC;AAErG,MADA,aAAa,KAAK,GACd,EAAA,SAAS,OAAO,SAAS;AAC7B,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,yCAAyC,GAAG,QAAQ,GAAG,kBAAkB,KAAK;AAAA,IAAA,CACxF;AACH;ACLgB,SAAA,0BAA0B,OAAgB,KAAa,KAAsC;AAE3G,MADA,aAAa,KAAK,GACd,EAAA,QAAQ,OAAO,QAAQ;AAC3B,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,yCAAyC,GAAG,QAAQ,GAAG,kBAAkB,KAAK;AAAA,IAAA,CACxF;AACH;ACTO,SAAS,oBAAoB,OAAyC;AAE3E,MADA,aAAa,KAAK,GACd,CAAC,OAAO,cAAc,KAAK;AAC7B,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,sEAAsE,KAAK;AAAA,IAAA,CACrF;AAEL;ACPO,SAAS,iBAAiB,OAAyC;AAGxE,MAFA,aAAa,KAAK,GAClB,oBAAoB,KAAK,GACpB,QAAQ;AACX,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,qDAAqD,KAAK;AAAA,IAAA,CACpE;AAEL;ACVO,SAAS,qBAAqB,OAAyC;AAC5E,MAAA,aAAa,KAAK,GACd,EAAS,SAAA;AACb,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,uEAAuE,KAAK;AAAA,IAAA,CACtF;AACH;ACPO,SAAS,2BAA2B,OAAyC;AAClF,MAAA,aAAa,KAAK,GACd,EAAQ,QAAA;AACZ,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,oEAAoE,KAAK;AAAA,IAAA,CACnF;AACH;ACNO,SAAS,gBAAgB,OAAyC;AAGvE,MAFA,aAAa,KAAK,GAClB,oBAAoB,KAAK,GACpB,EAAQ,QAAA;AACX,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,oDAAoD,KAAK;AAAA,IAAA,CACnE;AAEL;ACVO,SAAS,qBAAqB,OAAyC;AAC5E,MAAA,aAAa,KAAK,GACd,EAAS,SAAA;AACb,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,0EAA0E,KAAK;AAAA,IAAA,CACzF;AACH;ACPO,SAAS,2BAA2B,OAAyC;AAClF,MAAA,aAAa,KAAK,GACd,EAAQ,QAAA;AACZ,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,uEAAuE,KAAK;AAAA,IAAA,CACtF;AACH;ACPO,SAAS,aAA+B,OAAoC;AAC7E,MAAAC,OAAA,OAAO,KAAK,MAAM;AACtB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,gDAAgDC,cAAO,KAAK,CAAC;AAAA,IAAA,CACvE;AACH;ACNO,SAAS,aAAa,OAAyC;AACpE,MAAI,OAAO,SAAU;AACrB,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+CAA+CC,cAAO,KAAK,CAAC;AAAA,IAAA,CACtE;AACH;ACLO,SAAS,qBAAqB,OAAyC;AAE5E,MADA,aAAa,KAAK,GACd,EAAM,MAAA,OAAO,SAAS;AAC1B,UAAM,IAAID,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACLO,SAAS,yBAAyB,OAAyC;AAChF,MAAA,aAAa,KAAK,GAClB,qBAAqB,KAAK,GACtB,UAAUE,8BAAe,KAAK;AAClC,UAAM,IAAIF,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,gEAAgE,KAAK;AAAA,IAAA,CAC/E;AACH;ACjBO,MAAM,YAAY;AAalB,SAAS,kBAAkB,OAAwC;AAExE,MADA,aAAa,KAAK,GACd,CAAA,UAAU,KAAK,KAAK;AACxB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+CAA+C,KAAK;AAAA,IAAA,CAC9D;AACH;ACbO,SAAS,kBAAkB,OAAyC;AAEzE,MADA,aAAa,KAAK,GACd,MAAM,KAAA,EAAO,WAAW;AAC5B,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,IAAA,CACV;AACH;ACNgB,SAAA,uBAAyC,OAAgB,KAA0C;AAEjH,MADA,aAAa,KAAK,GACd,CAAA,MAAM,SAAS,GAAG;AACtB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,8CAA8C,GAAG,mBAAmB,KAAK;AAAA,IAAA,CACnF;AACH;ACRgB,SAAA,iBAAmC,OAAgB,QAAiC;AAElG,MADA,aAAa,KAAK,GACd,OAAO,SAAS,KAAU,EAAG;AAC3B,QAAA,gBAAgB,OAAO,IAAI,CAAA,MAAK,IAAI,CAAC,GAAG,EAAE,KAAK,IAAI;AACzD,QAAM,IAAIA,gBAAAA,gBAAgB;AAAA,IACxB,MAAM;AAAA,IACN,SAAS,qDAAqD,aAAa,kBAAkB,KAAK;AAAA,EAAA,CACnG;AACH;ACRgB,SAAA,mBAAqC,OAAgB,UAAiC;AACpG,MAAA,aAAa,KAAK,GACd,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,0CAA0C,QAAQ,kBAAkB,KAAK;AAAA,IAAA,CACnF;AACH;ACPgB,SAAA,qBAAqB,OAAgB,KAAsC;AAEzF,MADA,aAAa,KAAK,GACd,CAAA,IAAI,KAAK,KAAK;AAClB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,+EAA+E,KAAK;AAAA,IAAA,CAC9F;AACH;ACbA,MAAM,aAAa;AASZ,SAAS,mBAAmB,OAA8C;AAE/E,MADA,aAAa,KAAK,GACd,CAAA,WAAW,KAAK,KAAK;AACzB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,0EAA0E,KAAK;AAAA,IAAA,CACzF;AACH;ACXgB,SAAA,yBAA2C,OAAgB,OAA4C;AAErH,MADA,aAAa,KAAK,GACd,CAAA,MAAM,WAAW,KAAK;AAC1B,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,gDAAgD,KAAK,mBAAmB,KAAK;AAAA,IAAA,CACvF;AACH;ACZO,MAAM,WAAW;AASjB,SAAS,iBAAiB,OAAuC;AAEtE,MADA,aAAa,KAAK,GACd,CAAA,SAAS,KAAK,KAAK;AACvB,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,6CAA6C,KAAK;AAAA,IAAA,CAC5D;AACH;ACXO,SAAS,WAAW,OAAuC;AAChE,MAAA,cAAc,KAAK,GACf,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,8DAA8D,KAAK;AAAA,IAAA,CAC7E;AACH;ACPO,SAAS,gBAAgB,OAA4C;AAC1E,MAAI,UAAU;AACd,UAAM,IAAIA,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS,gDAAgDC,cAAO,KAAK,CAAC;AAAA,IAAA,CACvE;AACH;ACNO,SAAS,qBAAuC,MAAsB;AAC3E,SAAO,CAAC,UAAuC,eAAe,OAAO,IAAI;AAC3E;ACFgB,SAAA,0BAA0B,KAAa,KAAa;AAClE,SAAO,CAAC,UAA4C,oBAAoB,OAAO,KAAK,GAAG;AACzF;ACFgB,SAAA,gCAAgC,KAAa,KAAa;AACxE,SAAO,CAAC,UAA4C,0BAA0B,OAAO,KAAK,GAAG;AAC/F;ACHO,SAAS,6BAA+C,KAAQ;AACrE,SAAO,CAAC,UAAqD,uBAAuB,OAAO,GAAG;AAChG;ACFO,SAAS,uBAAyC,QAAa;AACpE,SAAO,CAAC,UAAuC,iBAAiB,OAAO,MAAM;AAC/E;ACFO,SAAS,yBAA2C,UAAa;AACtE,SAAO,CAAC,UAAuC,mBAAmB,OAAO,QAAQ;AACnF;ACFO,SAAS,+BAAiD,OAAU;AACzE,SAAO,CAAC,UAAqD,yBAAyB,OAAO,KAAK;AACpG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/assert.d.ts b/dist/assert.d.ts
index 450d83320eb3e892f5b93bb146a8344bebe8718b..d434e6221bbc80d608580258f13c813ba90a16fc 100644
--- a/dist/assert.d.ts
+++ b/dist/assert.d.ts
@@ -1,4 +1,4 @@
-import { A as Any } from './chunks/Da897S_y.js';
+import { A as Any, F as Function } from './chunks/Da897S_y.js';
 import { UUID } from 'node:crypto';
 
 /**
@@ -107,6 +107,15 @@ type NotNull<U = unknown> = U extends null ? never : U;
  */
 type NotUndefined<U = Any> = U extends undefined ? never : U;
 
+/**
+ * Assert that a value is a function.
+ *
+ * @param value The value to assert as a function.
+ * @throws `ValidationError` if the value is not a function.
+ * @example assertFunction(() => {}) // void
+ */
+declare function assertFunction<T extends Function>(value: unknown): asserts value is T;
+
 /**
  * Assert that a value is an instance of the given class.
  *
@@ -468,4 +477,4 @@ declare function createAssertStringEquals<T extends string>(expected: T): (value
  */
 declare function createAssertStringStartingWith<T extends string>(start: T): (value: unknown) => asserts value is `${T}${string}`;
 
-export { EXP_EMAIL, EXP_UUID, type Email, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith };
+export { EXP_EMAIL, EXP_UUID, type Email, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertFunction, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith };
diff --git a/dist/assert.js b/dist/assert.js
index 4aa18e82f762e0a7c6e21a88457aa37e03fbcd4b..ec137f909ce8a1f11180e46c1ffc8556b76a6e61 100644
--- a/dist/assert.js
+++ b/dist/assert.js
@@ -1,5 +1,6 @@
 import { kindOf } from "@unshared/functions/kindOf";
 import { ValidationError } from "./ValidationError.js";
+import { kindOf as kindOf$1 } from "@unshared/functions";
 import { toConstantCase } from "@unshared/string/toConstantCase";
 function assertArray(value) {
   if (!Array.isArray(value))
@@ -43,6 +44,13 @@ function assertFalsy(value) {
       message: `Expected value to be falsy but received: ${kindOf(value)}`
     });
 }
+function assertFunction(value) {
+  if (typeof value != "function")
+    throw new ValidationError({
+      name: "E_NOT_FUNCTION",
+      message: `Expected value to be a function but received: ${kindOf$1(value)}`
+    });
+}
 function assertInstance(value, ctor) {
   if (!(value instanceof ctor))
     throw new ValidationError({
@@ -294,6 +302,7 @@ export {
   assertBoolean,
   assertFalse,
   assertFalsy,
+  assertFunction,
   assertInstance,
   assertNil,
   assertNotNil,
diff --git a/dist/assert.js.map b/dist/assert.js.map
index 12f4c6339f6a6178163fc8dd589e1282feb404c8..d1d1e2afcb94e582bfa31f434ee98ba3970a7a5f 100644
--- a/dist/assert.js.map
+++ b/dist/assert.js.map
@@ -1 +1 @@
-{"version":3,"file":"assert.js","sources":["../assert/assertArray.ts","../assert/assertArrayEmpty.ts","../assert/assertArrayNotEmpty.ts","../assert/assertBoolean.ts","../assert/assertFalse.ts","../assert/assertFalsy.ts","../assert/assertInstance.ts","../assert/assertNil.ts","../assert/assertNotNil.ts","../assert/assertNotNull.ts","../assert/assertNotUndefined.ts","../assert/assertNull.ts","../assert/assertNumber.ts","../assert/assertNumberBetween.ts","../assert/assertNumberBetweenStrict.ts","../assert/assertNumberInteger.ts","../assert/assertNumberEven.ts","../assert/assertNumberNegative.ts","../assert/assertNumberNegativeStrict.ts","../assert/assertNumberOdd.ts","../assert/assertNumberPositive.ts","../assert/assertNumberPositiveStrict.ts","../assert/assertObject.ts","../assert/assertString.ts","../assert/assertStringNotEmpty.ts","../assert/assertStringConstantCase.ts","../assert/assertStringEmail.ts","../assert/assertStringEmpty.ts","../assert/assertStringEndingWith.ts","../assert/assertStringEnum.ts","../assert/assertStringEquals.ts","../assert/assertStringMatching.ts","../assert/assertStringNumber.ts","../assert/assertStringStartingWith.ts","../assert/assertStringUuid.ts","../assert/assertTrue.ts","../assert/assertUndefined.ts","../assert/createAssertInstance.ts","../assert/createAssertNumberBetween.ts","../assert/createAssertNumberBetweenStrict.ts","../assert/createAssertStringEndingWith.ts","../assert/createAssertStringEnum.ts","../assert/createAssertStringEquals.ts","../assert/createAssertStringStartingWith.ts"],"sourcesContent":["import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an array.\n *\n * @param value The value to assert as an array.\n * @throws `ValidationError` if the value is not an array.\n * @example assertArray(['Hello, World!']) // void\n */\nexport function assertArray<T>(value: unknown): asserts value is T[] {\n  if (Array.isArray(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_ARRAY',\n    message: `Expected value to be an array but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an array', () => {\n    const result = assertArray([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArray({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertArray(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertArray(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n  })\n\n  test('should predicate an array', () => {\n    const value = [] as unknown\n    assertArray(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate an array of string if a generic is provided', () => {\n    const value = [] as unknown\n    assertArray<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is an empty array.\n *\n * @param value The value to assert as an empty array.\n * @throws `ValidationError` if the value is not an empty array.\n * @example assertArrayEmpty([]) // void\n */\nexport function assertArrayEmpty(value: unknown): asserts value is [] {\n  assertArray(value)\n  if (value.length === 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_NOT_EMPTY',\n    message: `Expected value to be an empty array but actually received an array with ${value.length} items`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should pass if value is an empty array', () => {\n    const result = assertArrayEmpty([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an empty array', () => {\n    const shouldThrow = () => assertArrayEmpty([1])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty array but actually received an array with 1 items')\n  })\n\n  test('should predicate an empty array', () => {\n    const value = [] as unknown\n    assertArrayEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is a non-empty array.\n *\n * @param value The value to assert as a non-empty array.\n * @throws `ValidationError` if the value is not a non-empty array.\n * @example assertArrayNotEmpty(['Hello, World!']) // void\n */\nexport function assertArrayNotEmpty<T>(value: unknown): asserts value is T[] {\n  assertArray(value)\n  if (value.length > 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_EMPTY',\n    message: 'Expected value to be a non-empty array but received an empty array.',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty array', () => {\n    const result = assertArrayNotEmpty([1])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty array', () => {\n    const shouldThrow = () => assertArrayNotEmpty([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty array but received an empty array.')\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayNotEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should predicate a non-empty array', () => {\n    const value = [1] as unknown\n    assertArrayNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate a non-empty array of string if a generic is provided', () => {\n    const value = ['Hello, World!'] as unknown\n    assertArrayNotEmpty<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n// is boolean\n/**\n * Assert that a value is a boolean.\n *\n * @param value The value to assert as a boolean.\n * @throws `ValidationError` if the value is not a boolean.\n * @example assertBoolean(true) // void\n */\nexport function assertBoolean(value: unknown): asserts value is boolean {\n  if (typeof value === 'boolean') return\n  throw new ValidationError({\n    name: 'E_NOT_BOOLEAN',\n    message: `Expected value to be a boolean but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean', () => {\n    const result = assertBoolean(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertBoolean(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertBoolean(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertBoolean(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean', () => {\n    const value = true as unknown\n    assertBoolean(value)\n    expectTypeOf(value).toEqualTypeOf<boolean>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `false`.\n *\n * @param value The value to assert as a boolean equal to `false`.\n * @throws `ValidationError` if the value is not a boolean equal to `false`.\n * @example assertFalse(false) // void\n */\nexport function assertFalse(value: unknown): asserts value is false {\n  assertBoolean(value)\n  if (value === false) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_FALSE',\n    message: `Expected value to be a boolean equal to false but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalse(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to false', () => {\n    const shouldThrow = () => assertFalse(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to false but received: true')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertFalse(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFalse(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFalse(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to false', () => {\n    const value = false as unknown\n    assertFalse(value)\n    expectTypeOf(value).toEqualTypeOf<false>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is falsy. Meaning it is either `false`, `0`, `''`, `null` or `undefined`.\n *\n * @param value The value to assert as falsy.\n * @throws `ValidationError` if the value is not falsy.\n * @example assertFalsy(false) // void\n */\nexport function assertFalsy(value: unknown): asserts value is '' | 0 | false | null | undefined {\n  if (value) {\n    throw new ValidationError({\n      name: 'E_NOT_FALSY',\n      message: `Expected value to be falsy but received: ${kindOf(value)}`,\n    })\n  }\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalsy(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is 0', () => {\n    const result = assertFalsy(0)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is an empty string', () => {\n    const result = assertFalsy('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertFalsy(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertFalsy(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-zero number', () => {\n    const shouldThrow = () => assertFalsy(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: number')\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertFalsy('hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: string')\n  })\n\n  test('should throw if value is true', () => {\n    const shouldThrow = () => assertFalsy(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: boolean')\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertFalsy({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: object')\n  })\n\n  test('should throw if value is an array', () => {\n    const shouldThrow = () => assertFalsy([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: Array')\n  })\n\n  test('should predicate a falsy value', () => {\n    const value = false as unknown\n    assertFalsy(value)\n    expectTypeOf(value).toEqualTypeOf<'' | 0 | false | null | undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an instance of the given class.\n *\n * @param value The value to assert as an instance of the given class.\n * @param ctor The class to assert the value is an instance of.\n * @throws `ValidationError` if the value is not an instance of the given class.\n * @example assertInstance(new Date(), Date) // void\n */\nexport function assertInstance<T extends object>(value: unknown, ctor: Constructor<T>): asserts value is T {\n  if (value instanceof ctor) return\n  throw new ValidationError({\n    name: 'E_NOT_INSTANCE_OF',\n    message: `Expected value to be an instance of ${ctor.name} but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an instance of the given class', () => {\n    const result = assertInstance(new Date(), Date)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an instance of the given class', () => {\n    const shouldThrow = () => assertInstance([], Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertInstance(undefined, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertInstance(null, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: null')\n  })\n\n  test('should predicate an instance of the given class', () => {\n    const value = new Date() as unknown\n    assertInstance(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n\n  test('should predicate an instance of the given class if a generic is provided', () => {\n    const value = new Date() as unknown\n    assertInstance<Date>(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null` or `undefined`.\n *\n * @param value The value to assert as `null` or `undefined`.\n * @throws `ValidationError` if the value is neither `null` nor `undefined`.\n * @example assertNil(null) // void\n */\nexport function assertNil(value: unknown): asserts value is null | undefined {\n  if (value === null || value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_NIL',\n    message: `Expected value to be null or undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNil(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNil(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNil({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null or undefined but received: object')\n  })\n\n  test('should predicate a null or undefined union', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNil(value)\n    expectTypeOf(value).toEqualTypeOf<null | undefined>()\n  })\n}\n","import type { NotNil } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null` or `undefined`.\n *\n * @param value The value to assert as not `null` or `undefined`.\n * @throws `ValidationError` if the value is `null` or `undefined`.\n * @example assertNotNil(1) // void\n */\nexport function assertNotNil<T>(value: T): asserts value is NotNil<T> {\n  if (value !== null && value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_NIL',\n    message: 'Expected value not to be null or undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null or undefined', () => {\n    const result = assertNotNil(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNil(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotNil(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNil(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import type { NotNull } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null`.\n *\n * @param value The value to assert as not `null`.\n * @throws `ValidationError` if the value is `null`.\n * @example assertNotNull(1) // void\n */\nexport function assertNotNull<T>(value: T): asserts value is NotNull<T> {\n  if (value !== null) return\n  throw new ValidationError({\n    name: 'E_IS_NULL',\n    message: 'Expected value not to be null',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null', () => {\n    const result = assertNotNull(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNotNull(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNull(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNull(value)\n    expectTypeOf(value).toEqualTypeOf<number | undefined>()\n  })\n}\n","import type { NotUndefined } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `undefined`.\n *\n * @param value The value to assert as not `undefined`.\n * @throws `ValidationError` if the value is `undefined`.\n * @example assertNotUndefined(1) // void\n */\nexport function assertNotUndefined<T>(value: T): asserts value is NotUndefined<T> {\n  if (value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_UNDEFINED',\n    message: 'Expected value not to be undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not undefined', () => {\n    const result = assertNotUndefined(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNotUndefined(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotUndefined(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<null | number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null`.\n *\n * @param value The value to assert as `null`.\n * @throws `ValidationError` if the value is not `null`.\n * @example assertNull(null) // void\n */\nexport function assertNull(value: unknown): asserts value is null {\n  if (value === null) return\n  throw new ValidationError({\n    name: 'E_NOT_NULL',\n    message: `Expected value to be null but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNull(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNull({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNull(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: undefined')\n  })\n\n  test('should predicate a null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNull(value)\n    expectTypeOf(value).toEqualTypeOf<null>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a number.\n *\n * @param value The value to assert as a number.\n * @throws `ValidationError` if the value is not a number.\n * @example assertNumber(1) // void\n */\nexport function assertNumber(value: unknown): asserts value is number {\n  if (typeof value === 'number') return\n  throw new ValidationError({\n    name: 'E_NOT_NUMBER',\n    message: `Expected value to be a number but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number', () => {\n    const result = assertNumber(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumber('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number', () => {\n    const value = 1 as unknown\n    assertNumber(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number between or equal a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The minimum value that the number can be.\n * @param max The maximum value that the number can be.\n */\nexport function assertNumberBetween(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value >= min && value <= max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetween(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to min', () => {\n    const result = assertNumberBetween(1, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to max', () => {\n    const result = assertNumberBetween(10, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetween(0, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 0')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetween(11, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 11')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetween('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetween(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetween(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetween(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly between a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @throws `ValidationError` if the value is not strictly between the minimum and maximum value.\n * @example assertNumberBetweenStrict(5, 1, 10) // void\n */\nexport function assertNumberBetweenStrict(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value > min && value < max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN_STRICT',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetweenStrict(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is equal to min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is equal to max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetweenStrict('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetweenStrict(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetweenStrict(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is an integer number.\n *\n * @param value The value to assert as an integer number.\n * @throws `ValidationError` if the value is not an integer number.\n * @example assertNumberInteger(1) // void\n */\nexport function assertNumberInteger(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (!Number.isSafeInteger(value)) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_INTEGER',\n      message: `Expected value to be an integer number but received decimal value: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an integer number', () => {\n    const result = assertNumberInteger(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberInteger('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is not an integer number', () => {\n    const shouldThrow = () => assertNumberInteger(1.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 1.1')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberInteger(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberInteger(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an integer number', () => {\n    const value = 1 as unknown\n    assertNumberInteger(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an even number.\n *\n * @param value The value to assert as an even number.\n * @throws `ValidationError` if the value is not an even number.\n * @example assertNumberEven(2) // true\n */\nexport function assertNumberEven(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 1) !== 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_EVEN',\n      message: `Expected value to be an even number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an even number', () => {\n    const result = assertNumberEven(2)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an odd number', () => {\n    const shouldThrow = () => assertNumberEven(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an even number but received: 1')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberEven(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberEven('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberEven(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberEven(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an even number', () => {\n    const value = 2 as unknown\n    assertNumberEven(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number less than or equal to `0`.\n *\n * @param value The value to assert as a number less than or equal to `0`.\n * @throws `ValidationError` if the value is not a number less than or equal to `0`.\n * @example assertNumberNegative(-1) // void\n */\nexport function assertNumberNegative(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value <= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE',\n    message: `Expected value to be a number less than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than or equal to 0', () => {\n    const result = assertNumberNegative(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than or equal to 0', () => {\n    const shouldThrow = () => assertNumberNegative(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number less than or equal to 0 but received: 1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegative('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegative(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegative(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than or equal to 0', () => {\n    const value = -1 as unknown\n    assertNumberNegative(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number less than `0`.\n *\n * @param value The value to assert as a number less than `0`.\n * @throws `ValidationError` if the value is not a number less than `0`.\n * @example assertNumberNegativeStrict(-1) // void\n */\nexport function assertNumberNegativeStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value < 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE_STRICT',\n    message: `Expected value to be a number strictly less than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than 0', () => {\n    const result = assertNumberNegativeStrict(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than 0', () => {\n    const shouldThrow = () => assertNumberNegativeStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly less than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegativeStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegativeStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegativeStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than 0', () => {\n    const value = -1 as unknown\n    assertNumberNegativeStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an odd number.\n *\n * @param value The value to assert as an odd number.\n * @throws `ValidationError` if the value is not an odd number.\n * @example assertNumberOdd(1) // true\n */\nexport function assertNumberOdd(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 0x1) === 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_ODD',\n      message: `Expected value to be an odd number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an odd number', () => {\n    const result = assertNumberOdd(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an even number', () => {\n    const shouldThrow = () => assertNumberOdd(2)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an odd number but received: 2')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberOdd(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberOdd('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberOdd(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberOdd(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an odd number', () => {\n    const value = 1 as unknown\n    assertNumberOdd(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number greater than or equal to `0`.\n *\n * @param value The value to assert as a number greater than or equal to `0`.\n * @throws `ValidationError` if the value is not a number greater than or equal to `0`.\n * @example assertNumberPositive(1) // void\n */\nexport function assertNumberPositive(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value >= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE',\n    message: `Expected value to be a number greater than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than or equal to 0', () => {\n    const result = assertNumberPositive(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than or equal to 0', () => {\n    const shouldThrow = () => assertNumberPositive(-1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number greater than or equal to 0 but received: -1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositive('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositive(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositive(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than or equal to 0', () => {\n    const value = 1 as unknown\n    assertNumberPositive(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number greater than `0`.\n *\n * @param value The value to assert as a number greater than `0`.\n * @throws `ValidationError` if the value is not a number greater than `0`.\n * @example assertNumberPositiveStrict(1) // void\n */\nexport function assertNumberPositiveStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value > 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE_STRICT',\n    message: `Expected value to be a number strictly greater than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than 0', () => {\n    const result = assertNumberPositiveStrict(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than 0', () => {\n    const shouldThrow = () => assertNumberPositiveStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly greater than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositiveStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositiveStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositiveStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than 0', () => {\n    const value = 1 as unknown\n    assertNumberPositiveStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an object.\n *\n * @param value The value to assert as an object.\n * @throws `ValidationError` if the value is not an object.\n * @example assertObject({}) // void\n */\nexport function assertObject<T extends object>(value: unknown): asserts value is T {\n  if (kindOf(value) === 'object') return\n  throw new ValidationError({\n    name: 'E_NOT_OBJECT',\n    message: `Expected value to be an object but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an object', () => {\n    const result = assertObject({})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an object', () => {\n    const shouldThrow = () => assertObject([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertObject(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertObject(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: null')\n  })\n\n  test('should predicate an object', () => {\n    const value = {} as unknown\n    assertObject(value)\n    expectTypeOf(value).toEqualTypeOf<object>()\n  })\n\n  test('should predicate an object of Record<string, unknown> if a generic is provided', () => {\n    const value = {} as unknown\n    assertObject<Record<string, unknown>>(value)\n    expectTypeOf(value).toEqualTypeOf<Record<string, unknown>>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a string.\n *\n * @param value The value to assert as a string.\n * @throws `ValidationError` if the value is not a string.\n * @example assertString('Hello, World!') // void\n */\nexport function assertString(value: unknown): asserts value is string {\n  if (typeof value === 'string') return\n  throw new ValidationError({\n    name: 'E_NOT_STRING',\n    message: `Expected value to be a string but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string', () => {\n    const result = assertString('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertString(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertString(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertString(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string', () => {\n    const value = 'Hello, World!' as unknown\n    assertString(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is not empty. An empty string\n * is a string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as a non-empty string.\n * @throws `ValidationError` if the value is not a non-empty string.\n * @example assertStringNotEmpty('Hello, World!') // void\n */\nexport function assertStringNotEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length > 0) return\n  throw new ValidationError({\n    name: 'E_STRING_EMPTY',\n    message: 'Expected value to be a non-empty string but received an empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty string', () => {\n    const result = assertStringNotEmpty('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty string', () => {\n    const shouldThrow = () => assertStringNotEmpty('')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is a string with only whitespace characters', () => {\n    const shouldThrow = () => assertStringNotEmpty(' \\n\\t ')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringNotEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNotEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNotEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a non-empty string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { toConstantCase } from '@unshared/string/toConstantCase'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\nimport { assertStringNotEmpty } from './assertStringNotEmpty'\n\n/**\n * Assert that a value is a string and that it matches in constant case pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as in constant case.\n * @throws `ValidationError` if the value is not in constant case.\n * @example assertStringConstantCase('john.doe@acme.com') // void\n */\nexport function assertStringConstantCase(value: unknown): asserts value is string {\n  assertString(value)\n  assertStringNotEmpty(value)\n  if (value === toConstantCase(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_CONSTANT_CASE',\n    message: `Expected value to be a string in constant case but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is in constant case', () => {\n    const result = assertStringConstantCase('FOO_BAR')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not in constant case', () => {\n    const shouldThrow = () => assertStringConstantCase('foo.bar')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string in constant case but received: foo.bar')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringConstantCase(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringConstantCase(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringConstantCase(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate in constant case', () => {\n    const value = 'FOO_BAR' as unknown\n    assertStringConstantCase(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression that matches an email address. */\nexport const EXP_EMAIL = /^[\\w!#$%&'*+./=?^`{|}~-]+@[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?(?:\\.[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?)*$/i\n\n/** A string that must contain an `@` character. */\nexport type Email = `${string}@${string}`\n\n/**\n * Assert that a value is a string and that it matches an email pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as an email.\n * @throws `ValidationError` if the value is not an email.\n * @example assertStringEmail('john.doe@acme.com') // void\n */\nexport function assertStringEmail(value: unknown): asserts value is Email {\n  assertString(value)\n  if (EXP_EMAIL.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMAIL',\n    message: `Expected value to be an email but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an email', () => {\n    const result = assertStringEmail('john.doe@acme.com')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an email', () => {\n    const shouldThrow = () => assertStringEmail('john.doe@')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an email but received: john.doe@')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmail(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmail(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmail(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an email', () => {\n    const value = 'john.doe@acme.com' as unknown\n    assertStringEmail(value)\n    expectTypeOf(value).toEqualTypeOf<`${string}@${string}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is empty. An empty string is a\n * string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as an empty string.\n * @throws `ValidationError` if the value is not an empty string.\n * @example assertStringEmpty('') // void\n */\nexport function assertStringEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length === 0) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMPTY',\n    message: 'Expected value to be an empty string but received a non-empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an empty string', () => {\n    const result = assertStringEmpty('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is a string with only whitespace characters', () => {\n    const result = assertStringEmpty(' \\n\\t ')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertStringEmpty('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty string but received a non-empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an empty string', () => {\n    const value = '' as unknown\n    assertStringEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that ends with the given string.\n *\n * @param value The value to assert as a string ending with the given string.\n * @param end The string to match the end of the value against.\n * @throws `ValidationError` if the value is not a string or does not end with the given string.\n * @example assertStringEndingWith('Hello, World!', 'World!') // void\n */\n\nexport function assertStringEndingWith<T extends string>(value: unknown, end: T): asserts value is `${string}${T}` {\n  assertString(value)\n  if (value.endsWith(end)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ENDING_WITH',\n    message: `Expected value to be a string ending with \"${end}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = assertStringEndingWith('Hello, World!', 'World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEndingWith(1, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not end with the given string', () => {\n    const shouldThrow = () => assertStringEndingWith('Hello, World!', 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string ending with \"Hello\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEndingWith(undefined, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEndingWith(null, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEndingWith(value, 'World!')\n    expectTypeOf(value).toEqualTypeOf<`${string}World!`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string is one of the values in an array.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param values The values to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!']) // void\n */\nexport function assertStringEnum<T extends string>(value: unknown, values: T[]): asserts value is T {\n  assertString(value)\n  if (values.includes(value as T)) return\n  const messageValues = values.map(x => `'${x}'`).join(', ')\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ONE_OF_VALUES',\n    message: `Expected value to be one of the following values: ${messageValues} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string is one of the values in an array', () => {\n    const result = assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!'])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEnum(1, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is not one of the values in an array', () => {\n    const shouldThrow = () => assertStringEnum('Hello, World!', ['Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be one of the following values: \\'Hello, Universe!\\' but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEnum(undefined, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEnum(null, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEnum(value, ['Hello, World!', 'Hello, Universe!'])\n    expectTypeOf(value).toEqualTypeOf< 'Hello, Universe!' | 'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that strictly equals a given string.\n *\n * @param value The value to assert as a string equal to the given string.\n * @param expected The string to compare the value against.\n * @throws `ValidationError` if the value is not a string or does not equal the expected string.\n * @example assertStringEqual('Hello, World!', 'Hello, World!') // void\n */\nexport function assertStringEquals<T extends string>(value: unknown, expected: T): asserts value is T {\n  assertString(value)\n  if (value === expected) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EQUAL',\n    message: `Expected value to be a string equal to ${expected} but received: ${value}`,\n  })\n}\n\n/* v8 ignore next */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = assertStringEquals('Hello, World!', 'Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEquals(1, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not equal the expected string', () => {\n    const shouldThrow = () => assertStringEquals('Hello, World!', 'Hello, World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string equal to Hello, World but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEquals(undefined, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEquals(null, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string equal to the expected string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEquals(value, 'Hello, World!')\n    expectTypeOf(value).toEqualTypeOf<'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that matches a regular expression.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param exp The regular expression to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringMatching('Hello, World!', /Hello, \\w+!/) // void\n */\nexport function assertStringMatching(value: unknown, exp: RegExp): asserts value is string {\n  assertString(value)\n  if (exp.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_MATCHING_REGULAR_EXPRESSION',\n    message: `Expected value to be a string matching the regular expression but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string matching a regular expression', () => {\n    const result = assertStringMatching('Hello, World!', /Hello, \\w+!/)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringMatching(1, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not match the regular expression', () => {\n    const shouldThrow = () => assertStringMatching('Hello, World!', /Hello, \\d+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n\n    const shouldThrow = () => assertStringMatching(undefined, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringMatching(null, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringMatching(value, /Hello, \\w+!/)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n// assertStringNumber.ts\n/** Regular expression that matches a string representation of a number. */\nconst EXP_NUMBER = /^[+-]?\\d+(?:\\.\\d+)?$/\n\n/**\n * Assert that a value is a string and can be converted to a number.\n *\n * @param value The value to assert as a string number.\n * @throws `ValidationError` if the value is not a string number.\n * @example assertStringNumber('5') // void\n */\nexport function assertStringNumber(value: unknown): asserts value is `${number}` {\n  assertString(value)\n  if (EXP_NUMBER.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_STRING_NUMBER',\n    message: `Expected value to be a string representation of a number but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string number', () => {\n    const result = assertStringNumber('5')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string number', () => {\n    const shouldThrow = () => assertStringNumber('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string representation of a number but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string number', () => {\n    const value = '5' as unknown\n    assertStringNumber(value)\n    expectTypeOf(value).toEqualTypeOf<`${number}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that starts the given string.\n *\n * @param value The value to assert as a string starting with the given string.\n * @param start The string to match the start of the value against.\n * @throws `ValidationError` if the value is not a string or does not start with the given string.\n */\nexport function assertStringStartingWith<T extends string>(value: unknown, start: T): asserts value is `${T}${string}` {\n  assertString(value)\n  if (value.startsWith(start)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_STARTING_WITH',\n    message: `Expected value to be a string starting with \"${start}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = assertStringStartingWith('Hello, World!', 'Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringStartingWith(1, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not start with the given string', () => {\n    const shouldThrow = () => assertStringStartingWith('Hello, World!', 'World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string starting with \"World\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringStartingWith(undefined, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringStartingWith(null, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringStartingWith(value, 'Hello')\n    expectTypeOf(value).toEqualTypeOf<`Hello${string}`>()\n  })\n}\n","import type { UUID } from 'node:crypto'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression for a UUID. */\nexport const EXP_UUID = /^(?:[\\da-f]{8}-[\\da-f]{4}-[1-5][\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i\n\n/**\n * Assert that a value is a UUID as specified by [RFC 4122](https://www.ietf.org/rfc/rfc4122.txt).\n *\n * @param value The value to assert as a UUID.\n * @throws `ValidationError` if the value is not a UUID.\n * @example assertStringUuid('00000000-0000-0000-0000-000000000000') // void\n */\nexport function assertStringUuid(value: unknown): asserts value is UUID {\n  assertString(value)\n  if (EXP_UUID.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_UUID',\n    message: `Expected value to be a UUID but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a UUID', () => {\n    const result = assertStringUuid('00000000-0000-0000-0000-000000000000')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a UUID', () => {\n    const shouldThrow = () => assertStringUuid('not-a-uuid')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a UUID but received: not-a-uuid')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringUuid(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringUuid(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringUuid(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a UUID', () => {\n    const value = '00000000-0000-0000-0000-000000000000' as unknown\n    assertStringUuid(value)\n    expectTypeOf(value).toEqualTypeOf<UUID>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `true`.\n *\n * @param value The value to assert as a boolean equal to `true`.\n * @throws `ValidationError` if the value is not a boolean equal to `true`.\n * @example assertTrue(true) // void\n */\nexport function assertTrue(value: unknown): asserts value is true {\n  assertBoolean(value)\n  if (value === true) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_TRUE',\n    message: `Expected value to be a boolean equal to true but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to true', () => {\n    const result = assertTrue(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to true', () => {\n    const shouldThrow = () => assertTrue(false)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to true but received: false')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertTrue(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertTrue(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertTrue(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to true', () => {\n    const value = true as unknown\n    assertTrue(value)\n    expectTypeOf(value).toEqualTypeOf<true>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `undefined`.\n *\n * @param value The value to assert as `undefined`.\n * @throws `ValidationError` if the value is not `undefined`.\n * @example assertUndefined(undefined) // void\n */\nexport function assertUndefined(value: unknown): asserts value is undefined {\n  if (value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_UNDEFINED',\n    message: `Expected value to be undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertUndefined(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not undefined', () => {\n    const shouldThrow = () => assertUndefined(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: number')\n  })\n\n  test('should throw if value is not undefined', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertUndefined(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: null')\n  })\n\n  test('should predicate an undefined', () => {\n    const value = undefined as unknown\n    assertUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { assertInstance } from './assertInstance'\n\n/**\n * Create an assertion function that asserts a value is an instance of the given class.\n *\n * @param ctor The class to assert the value is an instance of.\n * @returns An assertion function that asserts a value is an instance of the given class.\n * @example const assertDate = createAssertInstance(Date) // (value: unknown) => asserts value is Date\n */\nexport function createAssertInstance<T extends object>(ctor: Constructor<T>) {\n  return (value: unknown): asserts value is T => assertInstance(value, ctor)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertInstance(Date)(new Date())\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertInstance(Date)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is Date>()\n  })\n}\n","import { assertNumberBetween } from './assertNumberBetween'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetween(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetween(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetween(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetween(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetween(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertNumberBetweenStrict } from './assertNumberBetweenStrict'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetweenStrict(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetweenStrict(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetweenStrict(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertStringEndingWith } from './assertStringEndingWith'\n\n/**\n * Create a function to assert that a value is a string ending with the given string.\n *\n * @param end The string to match the end of the value against.\n * @returns A function that asserts that a value is a string ending with the given string.\n * @example const isWorld = assertStringEndingWith('World') // (value: unknown) => asserts value is `${string}World`\n */\nexport function createAssertStringEndingWith<T extends string>(end: T) {\n  return (value: unknown): asserts value is `${string}${T}` => assertStringEndingWith(value, end)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `${string}World`>()\n  })\n}\n","import { assertStringEnum } from './assertStringEnum'\n\n/**\n * Create a predicate function that asserts that a value is a string that is one of the values in an array.\n *\n * @param values The values to match the value against.\n * @returns A predicate function that asserts that a value is a string that is one of the values in an array.\n * @example const isHello = createAssertStringEnum(['Hello', 'World']) // (value: unknown) => asserts value is 'Hello' | 'World'\n */\nexport function createAssertStringEnum<T extends string>(values: T[]) {\n  return (value: unknown): asserts value is T => assertStringEnum(value, values)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string in the array', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])('Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string union', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello' | 'World'>()\n  })\n}\n","import { assertStringEquals } from './assertStringEquals'\n\n/**\n * Create a parse function that can be used to assert a string is striclty equal to a given value.\n *\n * @param expected The value to assert the string is equal to.\n * @returns A parser function that can be used to assert a string is striclty equal to a given value.\n * @example const parse = createAssertStringEqual('foo') // (value: unknown) => value is 'foo'\n */\nexport function createAssertStringEquals<T extends string>(expected: T) {\n  return (value: unknown): asserts value is T => assertStringEquals(value, expected)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = createAssertStringEquals('Hello, World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string literal', () => {\n    const result = createAssertStringEquals('Hello, World!')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello, World!'>()\n  })\n}\n","import { assertStringStartingWith } from './assertStringStartingWith'\n\n/**\n * Create a function to assert that a value is a string starting with the given string.\n *\n * @param start The string to match the start of the value against.\n * @returns A function that asserts that a value is a string starting with the given string.\n * @example const isHello = assertStringStartingWith('Hello') // (value: unknown) => asserts value is `Hello${string}`\n */\nexport function createAssertStringStartingWith<T extends string>(start: T) {\n  return (value: unknown): asserts value is `${T}${string}` => assertStringStartingWith(value, start)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `Hello${string}`>()\n  })\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"assert.js","sources":["../assert/assertArray.ts","../assert/assertArrayEmpty.ts","../assert/assertArrayNotEmpty.ts","../assert/assertBoolean.ts","../assert/assertFalse.ts","../assert/assertFalsy.ts","../assert/assertFunction.ts","../assert/assertInstance.ts","../assert/assertNil.ts","../assert/assertNotNil.ts","../assert/assertNotNull.ts","../assert/assertNotUndefined.ts","../assert/assertNull.ts","../assert/assertNumber.ts","../assert/assertNumberBetween.ts","../assert/assertNumberBetweenStrict.ts","../assert/assertNumberInteger.ts","../assert/assertNumberEven.ts","../assert/assertNumberNegative.ts","../assert/assertNumberNegativeStrict.ts","../assert/assertNumberOdd.ts","../assert/assertNumberPositive.ts","../assert/assertNumberPositiveStrict.ts","../assert/assertObject.ts","../assert/assertString.ts","../assert/assertStringNotEmpty.ts","../assert/assertStringConstantCase.ts","../assert/assertStringEmail.ts","../assert/assertStringEmpty.ts","../assert/assertStringEndingWith.ts","../assert/assertStringEnum.ts","../assert/assertStringEquals.ts","../assert/assertStringMatching.ts","../assert/assertStringNumber.ts","../assert/assertStringStartingWith.ts","../assert/assertStringUuid.ts","../assert/assertTrue.ts","../assert/assertUndefined.ts","../assert/createAssertInstance.ts","../assert/createAssertNumberBetween.ts","../assert/createAssertNumberBetweenStrict.ts","../assert/createAssertStringEndingWith.ts","../assert/createAssertStringEnum.ts","../assert/createAssertStringEquals.ts","../assert/createAssertStringStartingWith.ts"],"sourcesContent":["import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an array.\n *\n * @param value The value to assert as an array.\n * @throws `ValidationError` if the value is not an array.\n * @example assertArray(['Hello, World!']) // void\n */\nexport function assertArray<T>(value: unknown): asserts value is T[] {\n  if (Array.isArray(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_ARRAY',\n    message: `Expected value to be an array but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an array', () => {\n    const result = assertArray([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArray({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertArray(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertArray(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n  })\n\n  test('should predicate an array', () => {\n    const value = [] as unknown\n    assertArray(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate an array of string if a generic is provided', () => {\n    const value = [] as unknown\n    assertArray<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is an empty array.\n *\n * @param value The value to assert as an empty array.\n * @throws `ValidationError` if the value is not an empty array.\n * @example assertArrayEmpty([]) // void\n */\nexport function assertArrayEmpty(value: unknown): asserts value is [] {\n  assertArray(value)\n  if (value.length === 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_NOT_EMPTY',\n    message: `Expected value to be an empty array but actually received an array with ${value.length} items`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should pass if value is an empty array', () => {\n    const result = assertArrayEmpty([])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an empty array', () => {\n    const shouldThrow = () => assertArrayEmpty([1])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty array but actually received an array with 1 items')\n  })\n\n  test('should predicate an empty array', () => {\n    const value = [] as unknown\n    assertArrayEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<[]>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertArray } from './assertArray'\n\n/**\n * Assert that a value is a non-empty array.\n *\n * @param value The value to assert as a non-empty array.\n * @throws `ValidationError` if the value is not a non-empty array.\n * @example assertArrayNotEmpty(['Hello, World!']) // void\n */\nexport function assertArrayNotEmpty<T>(value: unknown): asserts value is T[] {\n  assertArray(value)\n  if (value.length > 0) return\n  throw new ValidationError({\n    name: 'E_ARRAY_EMPTY',\n    message: 'Expected value to be a non-empty array but received an empty array.',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty array', () => {\n    const result = assertArrayNotEmpty([1])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty array', () => {\n    const shouldThrow = () => assertArrayNotEmpty([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty array but received an empty array.')\n  })\n\n  test('should throw if value is not an array', () => {\n    const shouldThrow = () => assertArrayNotEmpty({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n  })\n\n  test('should predicate a non-empty array', () => {\n    const value = [1] as unknown\n    assertArrayNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<unknown[]>()\n  })\n\n  test('should predicate a non-empty array of string if a generic is provided', () => {\n    const value = ['Hello, World!'] as unknown\n    assertArrayNotEmpty<string>(value)\n    expectTypeOf(value).toEqualTypeOf<string[]>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a boolean.\n *\n * @param value The value to assert as a boolean.\n * @throws `ValidationError` if the value is not a boolean.\n * @example assertBoolean(true) // void\n */\nexport function assertBoolean(value: unknown): asserts value is boolean {\n  if (typeof value === 'boolean') return\n  throw new ValidationError({\n    name: 'E_NOT_BOOLEAN',\n    message: `Expected value to be a boolean but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean', () => {\n    const result = assertBoolean(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertBoolean(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertBoolean(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertBoolean(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean', () => {\n    const value = true as unknown\n    assertBoolean(value)\n    expectTypeOf(value).toEqualTypeOf<boolean>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `false`.\n *\n * @param value The value to assert as a boolean equal to `false`.\n * @throws `ValidationError` if the value is not a boolean equal to `false`.\n * @example assertFalse(false) // void\n */\nexport function assertFalse(value: unknown): asserts value is false {\n  assertBoolean(value)\n  if (value === false) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_FALSE',\n    message: `Expected value to be a boolean equal to false but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalse(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to false', () => {\n    const shouldThrow = () => assertFalse(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to false but received: true')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertFalse(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFalse(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFalse(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to false', () => {\n    const value = false as unknown\n    assertFalse(value)\n    expectTypeOf(value).toEqualTypeOf<false>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is falsy. Meaning it is either `false`, `0`, `''`, `null` or `undefined`.\n *\n * @param value The value to assert as falsy.\n * @throws `ValidationError` if the value is not falsy.\n * @example assertFalsy(false) // void\n */\nexport function assertFalsy(value: unknown): asserts value is '' | 0 | false | null | undefined {\n  if (value) {\n    throw new ValidationError({\n      name: 'E_NOT_FALSY',\n      message: `Expected value to be falsy but received: ${kindOf(value)}`,\n    })\n  }\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to false', () => {\n    const result = assertFalsy(false)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is 0', () => {\n    const result = assertFalsy(0)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is an empty string', () => {\n    const result = assertFalsy('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertFalsy(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertFalsy(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-zero number', () => {\n    const shouldThrow = () => assertFalsy(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: number')\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertFalsy('hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: string')\n  })\n\n  test('should throw if value is true', () => {\n    const shouldThrow = () => assertFalsy(true)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: boolean')\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertFalsy({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: object')\n  })\n\n  test('should throw if value is an array', () => {\n    const shouldThrow = () => assertFalsy([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be falsy but received: Array')\n  })\n\n  test('should predicate a falsy value', () => {\n    const value = false as unknown\n    assertFalsy(value)\n    expectTypeOf(value).toEqualTypeOf<'' | 0 | false | null | undefined>()\n  })\n}\n","import type { Function } from '@unshared/types'\nimport { kindOf } from '@unshared/functions'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a function.\n *\n * @param value The value to assert as a function.\n * @throws `ValidationError` if the value is not a function.\n * @example assertFunction(() => {}) // void\n */\nexport function assertFunction<T extends Function>(value: unknown): asserts value is T {\n  if (typeof value === 'function') return\n  throw new ValidationError({\n    name: 'E_NOT_FUNCTION',\n    message: `Expected value to be a function but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a function', () => {\n    const result = assertFunction(() => {})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a function', () => {\n    const shouldThrow = () => assertFunction(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertFunction(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertFunction(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a function but received: null')\n  })\n\n  test('should predicate a function', () => {\n    const value = (() => {}) as unknown\n    assertFunction(value)\n    expectTypeOf(value).toEqualTypeOf<(...args: any[]) => any>()\n  })\n\n  test('should predicate the given function type', () => {\n    const value = (() => {}) as unknown\n    assertFunction<() => void>(value)\n    expectTypeOf(value).toEqualTypeOf<() => void>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an instance of the given class.\n *\n * @param value The value to assert as an instance of the given class.\n * @param ctor The class to assert the value is an instance of.\n * @throws `ValidationError` if the value is not an instance of the given class.\n * @example assertInstance(new Date(), Date) // void\n */\nexport function assertInstance<T extends object>(value: unknown, ctor: Constructor<T>): asserts value is T {\n  if (value instanceof ctor) return\n  throw new ValidationError({\n    name: 'E_NOT_INSTANCE_OF',\n    message: `Expected value to be an instance of ${ctor.name} but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an instance of the given class', () => {\n    const result = assertInstance(new Date(), Date)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an instance of the given class', () => {\n    const shouldThrow = () => assertInstance([], Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertInstance(undefined, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertInstance(null, Date)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an instance of Date but received: null')\n  })\n\n  test('should predicate an instance of the given class', () => {\n    const value = new Date() as unknown\n    assertInstance(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n\n  test('should predicate an instance of the given class if a generic is provided', () => {\n    const value = new Date() as unknown\n    assertInstance<Date>(value, Date)\n    expectTypeOf(value).toEqualTypeOf<Date>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null` or `undefined`.\n *\n * @param value The value to assert as `null` or `undefined`.\n * @throws `ValidationError` if the value is neither `null` nor `undefined`.\n * @example assertNil(null) // void\n */\nexport function assertNil(value: unknown): asserts value is null | undefined {\n  if (value === null || value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_NIL',\n    message: `Expected value to be null or undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNil(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNil(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNil({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null or undefined but received: object')\n  })\n\n  test('should predicate a null or undefined union', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNil(value)\n    expectTypeOf(value).toEqualTypeOf<null | undefined>()\n  })\n}\n","import type { NotNil } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null` or `undefined`.\n *\n * @param value The value to assert as not `null` or `undefined`.\n * @throws `ValidationError` if the value is `null` or `undefined`.\n * @example assertNotNil(1) // void\n */\nexport function assertNotNil<T>(value: T): asserts value is NotNil<T> {\n  if (value !== null && value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_NIL',\n    message: 'Expected value not to be null or undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null or undefined', () => {\n    const result = assertNotNil(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNil(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotNil(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null or undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNil(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import type { NotNull } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `null`.\n *\n * @param value The value to assert as not `null`.\n * @throws `ValidationError` if the value is `null`.\n * @example assertNotNull(1) // void\n */\nexport function assertNotNull<T>(value: T): asserts value is NotNull<T> {\n  if (value !== null) return\n  throw new ValidationError({\n    name: 'E_IS_NULL',\n    message: 'Expected value not to be null',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not null', () => {\n    const result = assertNotNull(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertNotNull(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNotNull(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be null')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotNull(value)\n    expectTypeOf(value).toEqualTypeOf<number | undefined>()\n  })\n}\n","import type { NotUndefined } from '@unshared/types'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is not `undefined`.\n *\n * @param value The value to assert as not `undefined`.\n * @throws `ValidationError` if the value is `undefined`.\n * @example assertNotUndefined(1) // void\n */\nexport function assertNotUndefined<T>(value: T): asserts value is NotUndefined<T> {\n  if (value !== undefined) return\n  throw new ValidationError({\n    name: 'E_IS_UNDEFINED',\n    message: 'Expected value not to be undefined',\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is not undefined', () => {\n    const result = assertNotUndefined(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if the value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNotUndefined(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNotUndefined(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value not to be undefined')\n  })\n\n  test('should predicate the type of a null or undefined value', () => {\n    const value = 1 as null | number | undefined\n    assertNotUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<null | number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `null`.\n *\n * @param value The value to assert as `null`.\n * @throws `ValidationError` if the value is not `null`.\n * @example assertNull(null) // void\n */\nexport function assertNull(value: unknown): asserts value is null {\n  if (value === null) return\n  throw new ValidationError({\n    name: 'E_NOT_NULL',\n    message: `Expected value to be null but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const result = assertNull(null)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an object', () => {\n    const shouldThrow = () => assertNull({})\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: object')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNull(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be null but received: undefined')\n  })\n\n  test('should predicate a null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const value = null as unknown\n    assertNull(value)\n    expectTypeOf(value).toEqualTypeOf<null>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a number.\n *\n * @param value The value to assert as a number.\n * @throws `ValidationError` if the value is not a number.\n * @example assertNumber(1) // void\n */\nexport function assertNumber(value: unknown): asserts value is number {\n  if (typeof value === 'number') return\n  throw new ValidationError({\n    name: 'E_NOT_NUMBER',\n    message: `Expected value to be a number but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number', () => {\n    const result = assertNumber(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumber('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number', () => {\n    const value = 1 as unknown\n    assertNumber(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number between or equal a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The minimum value that the number can be.\n * @param max The maximum value that the number can be.\n */\nexport function assertNumberBetween(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value >= min && value <= max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetween(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to min', () => {\n    const result = assertNumberBetween(1, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is equal to max', () => {\n    const result = assertNumberBetween(10, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetween(0, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 0')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetween(11, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 11')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetween('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetween(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetween(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetween(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly between a minimum and maximum value.\n *\n * @param value The value to assert as a number.\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @throws `ValidationError` if the value is not strictly between the minimum and maximum value.\n * @example assertNumberBetweenStrict(5, 1, 10) // void\n */\nexport function assertNumberBetweenStrict(value: unknown, min: number, max: number): asserts value is number {\n  assertNumber(value)\n  if (value > min && value < max) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_BETWEEN_STRICT',\n    message: `Expected value to be a number between ${min} and ${max} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = assertNumberBetweenStrict(5, 1, 10)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is less than min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is greater than max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is equal to min', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(1, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 1')\n  })\n\n  test('should throw if value is equal to max', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(10, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number between 1 and 10 but received: 10')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberBetweenStrict('5' as unknown, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertNumberBetweenStrict(undefined, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberBetweenStrict(null, 1, 10)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number between min and max', () => {\n    const value = 5 as unknown\n    assertNumberBetweenStrict(value, 1, 10)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is an integer number.\n *\n * @param value The value to assert as an integer number.\n * @throws `ValidationError` if the value is not an integer number.\n * @example assertNumberInteger(1) // void\n */\nexport function assertNumberInteger(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (!Number.isSafeInteger(value)) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_INTEGER',\n      message: `Expected value to be an integer number but received decimal value: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an integer number', () => {\n    const result = assertNumberInteger(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberInteger('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is not an integer number', () => {\n    const shouldThrow = () => assertNumberInteger(1.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 1.1')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberInteger(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberInteger(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an integer number', () => {\n    const value = 1 as unknown\n    assertNumberInteger(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an even number.\n *\n * @param value The value to assert as an even number.\n * @throws `ValidationError` if the value is not an even number.\n * @example assertNumberEven(2) // true\n */\nexport function assertNumberEven(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 1) !== 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_EVEN',\n      message: `Expected value to be an even number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an even number', () => {\n    const result = assertNumberEven(2)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an odd number', () => {\n    const shouldThrow = () => assertNumberEven(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an even number but received: 1')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberEven(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberEven('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberEven(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberEven(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an even number', () => {\n    const value = 2 as unknown\n    assertNumberEven(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number less than or equal to `0`.\n *\n * @param value The value to assert as a number less than or equal to `0`.\n * @throws `ValidationError` if the value is not a number less than or equal to `0`.\n * @example assertNumberNegative(-1) // void\n */\nexport function assertNumberNegative(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value <= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE',\n    message: `Expected value to be a number less than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than or equal to 0', () => {\n    const result = assertNumberNegative(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than or equal to 0', () => {\n    const shouldThrow = () => assertNumberNegative(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number less than or equal to 0 but received: 1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegative('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegative(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegative(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than or equal to 0', () => {\n    const value = -1 as unknown\n    assertNumberNegative(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number less than `0`.\n *\n * @param value The value to assert as a number less than `0`.\n * @throws `ValidationError` if the value is not a number less than `0`.\n * @example assertNumberNegativeStrict(-1) // void\n */\nexport function assertNumberNegativeStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value < 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_NEGATIVE_STRICT',\n    message: `Expected value to be a number strictly less than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number less than 0', () => {\n    const result = assertNumberNegativeStrict(-1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number less than 0', () => {\n    const shouldThrow = () => assertNumberNegativeStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly less than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberNegativeStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberNegativeStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberNegativeStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number less than 0', () => {\n    const value = -1 as unknown\n    assertNumberNegativeStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\nimport { assertNumberInteger } from './assertNumberInteger'\n\n/**\n * Obligatory meme function to assert if a value is an odd number.\n *\n * @param value The value to assert as an odd number.\n * @throws `ValidationError` if the value is not an odd number.\n * @example assertNumberOdd(1) // true\n */\nexport function assertNumberOdd(value: unknown): asserts value is number {\n  assertNumber(value)\n  assertNumberInteger(value)\n  if ((value & 0x1) === 0) {\n    throw new ValidationError({\n      name: 'E_NUMBER_NOT_ODD',\n      message: `Expected value to be an odd number but received: ${value}`,\n    })\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an odd number', () => {\n    const result = assertNumberOdd(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an even number', () => {\n    const shouldThrow = () => assertNumberOdd(2)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an odd number but received: 2')\n  })\n\n  test('should throw if value is a decimal number', () => {\n    const shouldThrow = () => assertNumberOdd(2.1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an integer number but received decimal value: 2.1')\n  })\n\n  test('should throw if value is a string', () => {\n    const shouldThrow = () => assertNumberOdd('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberOdd(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberOdd(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate an odd number', () => {\n    const value = 1 as unknown\n    assertNumberOdd(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is a number greater than or equal to `0`.\n *\n * @param value The value to assert as a number greater than or equal to `0`.\n * @throws `ValidationError` if the value is not a number greater than or equal to `0`.\n * @example assertNumberPositive(1) // void\n */\nexport function assertNumberPositive(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value >= 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE',\n    message: `Expected value to be a number greater than or equal to 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than or equal to 0', () => {\n    const result = assertNumberPositive(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than or equal to 0', () => {\n    const shouldThrow = () => assertNumberPositive(-1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number greater than or equal to 0 but received: -1')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositive('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositive(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositive(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than or equal to 0', () => {\n    const value = 1 as unknown\n    assertNumberPositive(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertNumber } from './assertNumber'\n\n/**\n * Assert that a value is strictly a number greater than `0`.\n *\n * @param value The value to assert as a number greater than `0`.\n * @throws `ValidationError` if the value is not a number greater than `0`.\n * @example assertNumberPositiveStrict(1) // void\n */\nexport function assertNumberPositiveStrict(value: unknown): asserts value is number {\n  assertNumber(value)\n  if (value > 0) return\n  throw new ValidationError({\n    name: 'E_NUMBER_NOT_POSITIVE_STRICT',\n    message: `Expected value to be a number strictly greater than 0 but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number greater than 0', () => {\n    const result = assertNumberPositiveStrict(1)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a number greater than 0', () => {\n    const shouldThrow = () => assertNumberPositiveStrict(0)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number strictly greater than 0 but received: 0')\n  })\n\n  test('should throw if value is not a number', () => {\n    const shouldThrow = () => assertNumberPositiveStrict('1')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: string')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertNumberPositiveStrict(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertNumberPositiveStrict(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a number but received: null')\n  })\n\n  test('should predicate a number greater than 0', () => {\n    const value = 1 as unknown\n    assertNumberPositiveStrict(value)\n    expectTypeOf(value).toEqualTypeOf<number>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is an object.\n *\n * @param value The value to assert as an object.\n * @throws `ValidationError` if the value is not an object.\n * @example assertObject({}) // void\n */\nexport function assertObject<T extends object>(value: unknown): asserts value is T {\n  if (kindOf(value) === 'object') return\n  throw new ValidationError({\n    name: 'E_NOT_OBJECT',\n    message: `Expected value to be an object but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is an object', () => {\n    const result = assertObject({})\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an object', () => {\n    const shouldThrow = () => assertObject([])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: Array')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertObject(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertObject(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an object but received: null')\n  })\n\n  test('should predicate an object', () => {\n    const value = {} as unknown\n    assertObject(value)\n    expectTypeOf(value).toEqualTypeOf<object>()\n  })\n\n  test('should predicate an object of Record<string, unknown> if a generic is provided', () => {\n    const value = {} as unknown\n    assertObject<Record<string, unknown>>(value)\n    expectTypeOf(value).toEqualTypeOf<Record<string, unknown>>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is a string.\n *\n * @param value The value to assert as a string.\n * @throws `ValidationError` if the value is not a string.\n * @example assertString('Hello, World!') // void\n */\nexport function assertString(value: unknown): asserts value is string {\n  if (typeof value === 'string') return\n  throw new ValidationError({\n    name: 'E_NOT_STRING',\n    message: `Expected value to be a string but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string', () => {\n    const result = assertString('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertString(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertString(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertString(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string', () => {\n    const value = 'Hello, World!' as unknown\n    assertString(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is not empty. An empty string\n * is a string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as a non-empty string.\n * @throws `ValidationError` if the value is not a non-empty string.\n * @example assertStringNotEmpty('Hello, World!') // void\n */\nexport function assertStringNotEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length > 0) return\n  throw new ValidationError({\n    name: 'E_STRING_EMPTY',\n    message: 'Expected value to be a non-empty string but received an empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is a non-empty string', () => {\n    const result = assertStringNotEmpty('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is an empty string', () => {\n    const shouldThrow = () => assertStringNotEmpty('')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is a string with only whitespace characters', () => {\n    const shouldThrow = () => assertStringNotEmpty(' \\n\\t ')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a non-empty string but received an empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringNotEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNotEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNotEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a non-empty string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringNotEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { toConstantCase } from '@unshared/string/toConstantCase'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\nimport { assertStringNotEmpty } from './assertStringNotEmpty'\n\n/**\n * Assert that a value is a string and that it matches in constant case pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as in constant case.\n * @throws `ValidationError` if the value is not in constant case.\n * @example assertStringConstantCase('john.doe@acme.com') // void\n */\nexport function assertStringConstantCase(value: unknown): asserts value is string {\n  assertString(value)\n  assertStringNotEmpty(value)\n  if (value === toConstantCase(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_CONSTANT_CASE',\n    message: `Expected value to be a string in constant case but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is in constant case', () => {\n    const result = assertStringConstantCase('FOO_BAR')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not in constant case', () => {\n    const shouldThrow = () => assertStringConstantCase('foo.bar')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string in constant case but received: foo.bar')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringConstantCase(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringConstantCase(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringConstantCase(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate in constant case', () => {\n    const value = 'FOO_BAR' as unknown\n    assertStringConstantCase(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression that matches an email address. */\nexport const EXP_EMAIL = /^[\\w!#$%&'*+./=?^`{|}~-]+@[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?(?:\\.[\\da-z](?:[\\da-z-]{0,61}[\\da-z])?)*$/i\n\n/** A string that must contain an `@` character. */\nexport type Email = `${string}@${string}`\n\n/**\n * Assert that a value is a string and that it matches an email pattern as\n * specified by [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322).\n *\n * @param value The value to assert as an email.\n * @throws `ValidationError` if the value is not an email.\n * @example assertStringEmail('john.doe@acme.com') // void\n */\nexport function assertStringEmail(value: unknown): asserts value is Email {\n  assertString(value)\n  if (EXP_EMAIL.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMAIL',\n    message: `Expected value to be an email but received: ${value}`,\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an email', () => {\n    const result = assertStringEmail('john.doe@acme.com')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not an email', () => {\n    const shouldThrow = () => assertStringEmail('john.doe@')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an email but received: john.doe@')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmail(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmail(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmail(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an email', () => {\n    const value = 'john.doe@acme.com' as unknown\n    assertStringEmail(value)\n    expectTypeOf(value).toEqualTypeOf<`${string}@${string}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string and that it is empty. An empty string is a\n * string that has a length of zero or only contains whitespace characters.\n *\n * @param value The value to assert as an empty string.\n * @throws `ValidationError` if the value is not an empty string.\n * @example assertStringEmpty('') // void\n */\nexport function assertStringEmpty(value: unknown): asserts value is string {\n  assertString(value)\n  if (value.trim().length === 0) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EMPTY',\n    message: 'Expected value to be an empty string but received a non-empty string.',\n  })\n}\n\n/* v8 ignore end */\nif (import.meta.vitest) {\n  test('should pass if value is an empty string', () => {\n    const result = assertStringEmpty('')\n    expect(result).toBeUndefined()\n  })\n\n  test('should pass if value is a string with only whitespace characters', () => {\n    const result = assertStringEmpty(' \\n\\t ')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is a non-empty string', () => {\n    const shouldThrow = () => assertStringEmpty('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be an empty string but received a non-empty string.')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEmpty(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringEmpty(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEmpty(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate an empty string', () => {\n    const value = '' as unknown\n    assertStringEmpty(value)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that ends with the given string.\n *\n * @param value The value to assert as a string ending with the given string.\n * @param end The string to match the end of the value against.\n * @throws `ValidationError` if the value is not a string or does not end with the given string.\n * @example assertStringEndingWith('Hello, World!', 'World!') // void\n */\n\nexport function assertStringEndingWith<T extends string>(value: unknown, end: T): asserts value is `${string}${T}` {\n  assertString(value)\n  if (value.endsWith(end)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ENDING_WITH',\n    message: `Expected value to be a string ending with \"${end}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = assertStringEndingWith('Hello, World!', 'World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEndingWith(1, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not end with the given string', () => {\n    const shouldThrow = () => assertStringEndingWith('Hello, World!', 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string ending with \"Hello\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEndingWith(undefined, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEndingWith(null, 'World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEndingWith(value, 'World!')\n    expectTypeOf(value).toEqualTypeOf<`${string}World!`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string is one of the values in an array.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param values The values to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!']) // void\n */\nexport function assertStringEnum<T extends string>(value: unknown, values: T[]): asserts value is T {\n  assertString(value)\n  if (values.includes(value as T)) return\n  const messageValues = values.map(x => `'${x}'`).join(', ')\n  throw new ValidationError({\n    name: 'E_STRING_NOT_ONE_OF_VALUES',\n    message: `Expected value to be one of the following values: ${messageValues} but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string is one of the values in an array', () => {\n    const result = assertStringEnum('Hello, World!', ['Hello, World!', 'Hello, Universe!'])\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEnum(1, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is not one of the values in an array', () => {\n    const shouldThrow = () => assertStringEnum('Hello, World!', ['Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be one of the following values: \\'Hello, Universe!\\' but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEnum(undefined, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEnum(null, ['Hello, World!', 'Hello, Universe!'])\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEnum(value, ['Hello, World!', 'Hello, Universe!'])\n    expectTypeOf(value).toEqualTypeOf< 'Hello, Universe!' | 'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that strictly equals a given string.\n *\n * @param value The value to assert as a string equal to the given string.\n * @param expected The string to compare the value against.\n * @throws `ValidationError` if the value is not a string or does not equal the expected string.\n * @example assertStringEqual('Hello, World!', 'Hello, World!') // void\n */\nexport function assertStringEquals<T extends string>(value: unknown, expected: T): asserts value is T {\n  assertString(value)\n  if (value === expected) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_EQUAL',\n    message: `Expected value to be a string equal to ${expected} but received: ${value}`,\n  })\n}\n\n/* v8 ignore next */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = assertStringEquals('Hello, World!', 'Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringEquals(1, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not equal the expected string', () => {\n    const shouldThrow = () => assertStringEquals('Hello, World!', 'Hello, World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string equal to Hello, World but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringEquals(undefined, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringEquals(null, 'Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string equal to the expected string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringEquals(value, 'Hello, World!')\n    expectTypeOf(value).toEqualTypeOf<'Hello, World!'>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that matches a regular expression.\n *\n * @param value The value to assert as a string matching a regular expression.\n * @param exp The regular expression to match the value against.\n * @throws `ValidationError` if the value is not a string or does not match the regular expression.\n * @example assertStringMatching('Hello, World!', /Hello, \\w+!/) // void\n */\nexport function assertStringMatching(value: unknown, exp: RegExp): asserts value is string {\n  assertString(value)\n  if (exp.test(value)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_MATCHING_REGULAR_EXPRESSION',\n    message: `Expected value to be a string matching the regular expression but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string matching a regular expression', () => {\n    const result = assertStringMatching('Hello, World!', /Hello, \\w+!/)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringMatching(1, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not match the regular expression', () => {\n    const shouldThrow = () => assertStringMatching('Hello, World!', /Hello, \\d+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n\n    const shouldThrow = () => assertStringMatching(undefined, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringMatching(null, /Hello, \\w+!/)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string matching a regular expression', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringMatching(value, /Hello, \\w+!/)\n    expectTypeOf(value).toEqualTypeOf<string>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n// assertStringNumber.ts\n/** Regular expression that matches a string representation of a number. */\nconst EXP_NUMBER = /^[+-]?\\d+(?:\\.\\d+)?$/\n\n/**\n * Assert that a value is a string and can be converted to a number.\n *\n * @param value The value to assert as a string number.\n * @throws `ValidationError` if the value is not a string number.\n * @example assertStringNumber('5') // void\n */\nexport function assertStringNumber(value: unknown): asserts value is `${number}` {\n  assertString(value)\n  if (EXP_NUMBER.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_STRING_NUMBER',\n    message: `Expected value to be a string representation of a number but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string number', () => {\n    const result = assertStringNumber('5')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string number', () => {\n    const shouldThrow = () => assertStringNumber('Hello, World!')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string representation of a number but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringNumber(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringNumber(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string number', () => {\n    const value = '5' as unknown\n    assertStringNumber(value)\n    expectTypeOf(value).toEqualTypeOf<`${number}`>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/**\n * Assert that a value is a string that starts the given string.\n *\n * @param value The value to assert as a string starting with the given string.\n * @param start The string to match the start of the value against.\n * @throws `ValidationError` if the value is not a string or does not start with the given string.\n */\nexport function assertStringStartingWith<T extends string>(value: unknown, start: T): asserts value is `${T}${string}` {\n  assertString(value)\n  if (value.startsWith(start)) return\n  throw new ValidationError({\n    name: 'E_STRING_NOT_STARTING_WITH',\n    message: `Expected value to be a string starting with \"${start}\" but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = assertStringStartingWith('Hello, World!', 'Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringStartingWith(1, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value does not start with the given string', () => {\n    const shouldThrow = () => assertStringStartingWith('Hello, World!', 'World')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string starting with \"World\" but received: Hello, World!')\n  })\n\n  test('should throw if value is undefined', () => {\n    const shouldThrow = () => assertStringStartingWith(undefined, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringStartingWith(null, 'Hello')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const value = 'Hello, World!' as unknown\n    assertStringStartingWith(value, 'Hello')\n    expectTypeOf(value).toEqualTypeOf<`Hello${string}`>()\n  })\n}\n","import type { UUID } from 'node:crypto'\nimport { ValidationError } from '../ValidationError'\nimport { assertString } from './assertString'\n\n/** Regular expression for a UUID. */\nexport const EXP_UUID = /^(?:[\\da-f]{8}-[\\da-f]{4}-[1-5][\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i\n\n/**\n * Assert that a value is a UUID as specified by [RFC 4122](https://www.ietf.org/rfc/rfc4122.txt).\n *\n * @param value The value to assert as a UUID.\n * @throws `ValidationError` if the value is not a UUID.\n * @example assertStringUuid('00000000-0000-0000-0000-000000000000') // void\n */\nexport function assertStringUuid(value: unknown): asserts value is UUID {\n  assertString(value)\n  if (EXP_UUID.test(value)) return\n  throw new ValidationError({\n    name: 'E_NOT_UUID',\n    message: `Expected value to be a UUID but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a UUID', () => {\n    const result = assertStringUuid('00000000-0000-0000-0000-000000000000')\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a UUID', () => {\n    const shouldThrow = () => assertStringUuid('not-a-uuid')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a UUID but received: not-a-uuid')\n  })\n\n  test('should throw if value is not a string', () => {\n    const shouldThrow = () => assertStringUuid(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertStringUuid(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertStringUuid(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a string but received: null')\n  })\n\n  test('should predicate a UUID', () => {\n    const value = '00000000-0000-0000-0000-000000000000' as unknown\n    assertStringUuid(value)\n    expectTypeOf(value).toEqualTypeOf<UUID>()\n  })\n}\n","import { ValidationError } from '../ValidationError'\nimport { assertBoolean } from './assertBoolean'\n\n/**\n * Assert that a value is a boolean equal to `true`.\n *\n * @param value The value to assert as a boolean equal to `true`.\n * @throws `ValidationError` if the value is not a boolean equal to `true`.\n * @example assertTrue(true) // void\n */\nexport function assertTrue(value: unknown): asserts value is true {\n  assertBoolean(value)\n  if (value === true) return\n  throw new ValidationError({\n    name: 'E_BOOLEAN_NOT_TRUE',\n    message: `Expected value to be a boolean equal to true but received: ${value}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a boolean equal to true', () => {\n    const result = assertTrue(true)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not a boolean equal to true', () => {\n    const shouldThrow = () => assertTrue(false)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean equal to true but received: false')\n  })\n\n  test('should throw if value is not a boolean', () => {\n    const shouldThrow = () => assertTrue(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: number')\n  })\n\n  test('should throw if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const shouldThrow = () => assertTrue(undefined)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: undefined')\n  })\n\n  test('should throw if value is null', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertTrue(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be a boolean but received: null')\n  })\n\n  test('should predicate a boolean equal to true', () => {\n    const value = true as unknown\n    assertTrue(value)\n    expectTypeOf(value).toEqualTypeOf<true>()\n  })\n}\n","import { kindOf } from '@unshared/functions/kindOf'\nimport { ValidationError } from '../ValidationError'\n\n/**\n * Assert that a value is `undefined`.\n *\n * @param value The value to assert as `undefined`.\n * @throws `ValidationError` if the value is not `undefined`.\n * @example assertUndefined(undefined) // void\n */\nexport function assertUndefined(value: unknown): asserts value is undefined {\n  if (value === undefined) return\n  throw new ValidationError({\n    name: 'E_NOT_UNDEFINED',\n    message: `Expected value to be undefined but received: ${kindOf(value)}`,\n  })\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is undefined', () => {\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    const result = assertUndefined(undefined)\n    expect(result).toBeUndefined()\n  })\n\n  test('should throw if value is not undefined', () => {\n    const shouldThrow = () => assertUndefined(1)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: number')\n  })\n\n  test('should throw if value is not undefined', () => {\n    // eslint-disable-next-line unicorn/no-null\n    const shouldThrow = () => assertUndefined(null)\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to be undefined but received: null')\n  })\n\n  test('should predicate an undefined', () => {\n    const value = undefined as unknown\n    assertUndefined(value)\n    expectTypeOf(value).toEqualTypeOf<undefined>()\n  })\n}\n","import type { Constructor } from '@unshared/types'\nimport { assertInstance } from './assertInstance'\n\n/**\n * Create an assertion function that asserts a value is an instance of the given class.\n *\n * @param ctor The class to assert the value is an instance of.\n * @returns An assertion function that asserts a value is an instance of the given class.\n * @example const assertDate = createAssertInstance(Date) // (value: unknown) => asserts value is Date\n */\nexport function createAssertInstance<T extends object>(ctor: Constructor<T>) {\n  return (value: unknown): asserts value is T => assertInstance(value, ctor)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertInstance(Date)(new Date())\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertInstance(Date)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is Date>()\n  })\n}\n","import { assertNumberBetween } from './assertNumberBetween'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetween(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetween(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetween(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetween(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetween(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertNumberBetweenStrict } from './assertNumberBetweenStrict'\n\n/**\n * Create a parser function that can be used to validate a number between a minimum and maximum value.\n *\n * @param min The lower bound of the range.\n * @param max The upper bound of the range.\n * @returns A parser function that can be used to validate a number between a minimum and maximum value.\n * @example const parse = createAssertNumberBetweenStrict(1, 10) // (value: unknown) => number\n */\nexport function createAssertNumberBetweenStrict(min: number, max: number) {\n  return (value: unknown): asserts value is number => assertNumberBetweenStrict(value, min, max)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a number between min and max', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)(5)\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a number', () => {\n    const result = createAssertNumberBetweenStrict(1, 10)\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is number>()\n  })\n}\n","import { assertStringEndingWith } from './assertStringEndingWith'\n\n/**\n * Create a function to assert that a value is a string ending with the given string.\n *\n * @param end The string to match the end of the value against.\n * @returns A function that asserts that a value is a string ending with the given string.\n * @example const isWorld = assertStringEndingWith('World') // (value: unknown) => asserts value is `${string}World`\n */\nexport function createAssertStringEndingWith<T extends string>(end: T) {\n  return (value: unknown): asserts value is `${string}${T}` => assertStringEndingWith(value, end)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string ending with the given string', () => {\n    const result = createAssertStringEndingWith('World')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `${string}World`>()\n  })\n}\n","import { assertStringEnum } from './assertStringEnum'\n\n/**\n * Create a predicate function that asserts that a value is a string that is one of the values in an array.\n *\n * @param values The values to match the value against.\n * @returns A predicate function that asserts that a value is a string that is one of the values in an array.\n * @example const isHello = createAssertStringEnum(['Hello', 'World']) // (value: unknown) => asserts value is 'Hello' | 'World'\n */\nexport function createAssertStringEnum<T extends string>(values: T[]) {\n  return (value: unknown): asserts value is T => assertStringEnum(value, values)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string in the array', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])('Hello')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string union', () => {\n    const result = createAssertStringEnum(['Hello', 'World'])\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello' | 'World'>()\n  })\n}\n","import { assertStringEquals } from './assertStringEquals'\n\n/**\n * Create a parse function that can be used to assert a string is striclty equal to a given value.\n *\n * @param expected The value to assert the string is equal to.\n * @returns A parser function that can be used to assert a string is striclty equal to a given value.\n * @example const parse = createAssertStringEqual('foo') // (value: unknown) => value is 'foo'\n */\nexport function createAssertStringEquals<T extends string>(expected: T) {\n  return (value: unknown): asserts value is T => assertStringEquals(value, expected)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string equal to the expected string', () => {\n    const result = createAssertStringEquals('Hello, World!')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate string literal', () => {\n    const result = createAssertStringEquals('Hello, World!')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is 'Hello, World!'>()\n  })\n}\n","import { assertStringStartingWith } from './assertStringStartingWith'\n\n/**\n * Create a function to assert that a value is a string starting with the given string.\n *\n * @param start The string to match the start of the value against.\n * @returns A function that asserts that a value is a string starting with the given string.\n * @example const isHello = assertStringStartingWith('Hello') // (value: unknown) => asserts value is `Hello${string}`\n */\nexport function createAssertStringStartingWith<T extends string>(start: T) {\n  return (value: unknown): asserts value is `${T}${string}` => assertStringStartingWith(value, start)\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should pass if value is a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')('Hello, World!')\n    expect(result).toBeUndefined()\n  })\n\n  test('should predicate a string starting with the given string', () => {\n    const result = createAssertStringStartingWith('Hello')\n    expectTypeOf(result).toEqualTypeOf<(value: unknown) => asserts value is `Hello${string}`>()\n  })\n}\n"],"names":["kindOf"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/createArrayParser.cjs b/dist/createArrayParser.cjs
index 18b9f508fe041bb21bc333bfad6570ba4b23ded9..02edd273f16bcc0bee1451c8b47f8d57548b8085 100644
--- a/dist/createArrayParser.cjs
+++ b/dist/createArrayParser.cjs
@@ -1,6 +1,7 @@
 "use strict";
 var assert = require("./assert.cjs"), createParser = require("./createParser.cjs"), ValidationError = require("./ValidationError.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 require("@unshared/functions/tries");
 require("./createRuleChain.cjs");
diff --git a/dist/createArrayParser.cjs.map b/dist/createArrayParser.cjs.map
index 76fab28455146a0e562a234e68555999b7966c76..b4505ef6059891901b4dad2dfdb85716204b2054 100644
--- a/dist/createArrayParser.cjs.map
+++ b/dist/createArrayParser.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createArrayParser.cjs","sources":["../createArrayParser.ts"],"sourcesContent":["import type { ParserLike, ParserResult } from './createParser'\nimport { assertArray } from './assert'\nimport { createParser } from './createParser'\nimport { ValidationError } from './ValidationError'\n\n/** A parser function that can be used to validate an array of values. */\nexport type ArrayParser<T extends ParserLike> =\n  (value: unknown) => Array<ParserResult<T>>\n\n/**\n * Create a parser function that can be used to validate an array of values.\n *\n * @param rules The rules or schema to use to validate the array.\n * @returns A parser function that can be used to validate an array of values.\n * @example\n * // Create a parser function from a schema.\n * const parse = createArrayParser([String])\n *\n * // Parse the value.\n * const result = parse(['Hello, World!']) // ['Hello, World!']\n */\nexport function createArrayParser<T extends ParserLike>(...rules: T): ArrayParser<T> {\n  const parse = createParser(...rules)\n\n  return (value: unknown) => {\n    assertArray(value)\n    let index = 0\n    const result = []\n    for (const item of value) {\n      try {\n        const value = parse(item)\n        result.push(value)\n      }\n\n      catch (error) {\n        throw new ValidationError({\n          name: 'E_ARRAY_VALIDATION_ERROR',\n          message: `Expected value at index ${index} to pass validation but received an error.`,\n          cause: error,\n        })\n      }\n      index++\n    }\n\n    return result\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertStringNumber } = await import('./assert')\n\n  describe('validate and parse an array of values', () => {\n    it('should assert it is an array', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse([])\n      expect(result).toStrictEqual([])\n    })\n\n    it('should not mutate the original array', () => {\n      const parse = createArrayParser(assertString, (x: string) => x.toUpperCase())\n      const value = ['Hello', 'World']\n      const result = parse(value)\n      expect(result).toStrictEqual(['HELLO', 'WORLD'])\n      expect(value).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert it is an array of strings', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse(['Hello', 'World'])\n      expect(result).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert strings and convert to numbers', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const result = parse(['5', '10'])\n      expect(result).toStrictEqual([5, 10])\n    })\n\n    it('should assert strings and convert to numbers if possible or uppercase', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString, (x: string) => x.toUpperCase()])\n      const result = parse(['5', 'Hello'])\n      expect(result).toStrictEqual([5, 'HELLO'])\n    })\n\n    it('should assert an array of object matching a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const result = parse([{ name: 'John', age: '25' }])\n      expect(result).toStrictEqual([{ name: 'John', age: 25 }])\n    })\n  })\n\n  describe('error handling', () => {\n    it('should throw if value is not an array', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse({})\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n    })\n\n    it('should throw if value is undefined', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const shouldThrow = () => parse(undefined)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n    })\n\n    it('should throw if value is null', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-null\n      const shouldThrow = () => parse(null)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n    })\n\n    it('should throw if value at index fails validation', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse(['Hello, World!', 5])\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value at index 1 to pass validation but received an error.')\n    })\n  })\n\n  describe('return type', () => {\n    it('should return a value of type string if passing a single rule', () => {\n      const parse = createArrayParser(assertString)\n      const value = parse(['Hello, World!'])\n      expectTypeOf(value).toEqualTypeOf<string[]>()\n    })\n\n    it('should return a value of type string if passing a rule chain', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<number[]>()\n    })\n\n    it('should return a value of type string if passing a rule set', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString])\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<Array<number | string>>()\n    })\n\n    it('should return a value of type string if passing a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const value = parse([{ name: 'John', age: '25' }])\n      expectTypeOf(value).toEqualTypeOf<Array<{ name: string; age: number }>>()\n    })\n  })\n}\n"],"names":["createParser","assertArray","value","ValidationError"],"mappings":";;;;;;;;;AAqBO,SAAS,qBAA2C,OAA0B;AAC7E,QAAA,QAAQA,aAAAA,aAAa,GAAG,KAAK;AAEnC,SAAO,CAAC,UAAmB;AACzBC,WAAA,YAAY,KAAK;AACjB,QAAI,QAAQ;AACZ,UAAM,SAAS,CAAA;AACf,eAAW,QAAQ,OAAO;AACpB,UAAA;AACIC,cAAAA,SAAQ,MAAM,IAAI;AACxB,eAAO,KAAKA,MAAK;AAAA,eAGZ,OAAO;AACZ,cAAM,IAAIC,gBAAAA,gBAAgB;AAAA,UACxB,MAAM;AAAA,UACN,SAAS,2BAA2B,KAAK;AAAA,UACzC,OAAO;AAAA,QAAA,CACR;AAAA,MACH;AACA;AAAA,IACF;AAEO,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
+{"version":3,"file":"createArrayParser.cjs","sources":["../createArrayParser.ts"],"sourcesContent":["import type { ParserLike, ParserResult } from './createParser'\nimport { assertArray } from './assert'\nimport { createParser } from './createParser'\nimport { ValidationError } from './ValidationError'\n\n/** A parser function that can be used to validate an array of values. */\nexport type ArrayParser<T extends ParserLike> =\n  (value: unknown) => Array<ParserResult<T>>\n\n/**\n * Create a parser function that can be used to validate an array of values.\n *\n * @param rules The rules or schema to use to validate the array.\n * @returns A parser function that can be used to validate an array of values.\n * @example\n * // Create a parser function from a schema.\n * const parse = createArrayParser([String])\n *\n * // Parse the value.\n * const result = parse(['Hello, World!']) // ['Hello, World!']\n */\nexport function createArrayParser<T extends ParserLike>(...rules: T): ArrayParser<T> {\n  const parse = createParser(...rules)\n\n  return (value: unknown) => {\n    assertArray(value)\n    let index = 0\n    const result = []\n    for (const item of value) {\n      try {\n        const value = parse(item)\n        result.push(value)\n      }\n\n      catch (error) {\n        throw new ValidationError({\n          name: 'E_ARRAY_VALIDATION_ERROR',\n          message: `Expected value at index ${index} to pass validation but received an error.`,\n          cause: error,\n        })\n      }\n      index++\n    }\n\n    return result\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertStringNumber } = await import('./assert')\n\n  describe('validate and parse an array of values', () => {\n    it('should assert it is an array', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse([])\n      expect(result).toStrictEqual([])\n    })\n\n    it('should not mutate the original array', () => {\n      const parse = createArrayParser(assertString, (x: string) => x.toUpperCase())\n      const value = ['Hello', 'World']\n      const result = parse(value)\n      expect(result).toStrictEqual(['HELLO', 'WORLD'])\n      expect(value).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert it is an array of strings', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse(['Hello', 'World'])\n      expect(result).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert strings and convert to numbers', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const result = parse(['5', '10'])\n      expect(result).toStrictEqual([5, 10])\n    })\n\n    it('should assert strings and convert to numbers if possible or uppercase', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString, (x: string) => x.toUpperCase()])\n      const result = parse(['5', 'Hello'])\n      expect(result).toStrictEqual([5, 'HELLO'])\n    })\n\n    it('should assert an array of object matching a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const result = parse([{ name: 'John', age: '25' }])\n      expect(result).toStrictEqual([{ name: 'John', age: 25 }])\n    })\n  })\n\n  describe('error handling', () => {\n    it('should throw if value is not an array', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse({})\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n    })\n\n    it('should throw if value is undefined', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const shouldThrow = () => parse(undefined)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n    })\n\n    it('should throw if value is null', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-null\n      const shouldThrow = () => parse(null)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n    })\n\n    it('should throw if value at index fails validation', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse(['Hello, World!', 5])\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value at index 1 to pass validation but received an error.')\n    })\n  })\n\n  describe('return type', () => {\n    it('should return a value of type string if passing a single rule', () => {\n      const parse = createArrayParser(assertString)\n      const value = parse(['Hello, World!'])\n      expectTypeOf(value).toEqualTypeOf<string[]>()\n    })\n\n    it('should return a value of type string if passing a rule chain', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<number[]>()\n    })\n\n    it('should return a value of type string if passing a rule set', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString])\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<Array<number | string>>()\n    })\n\n    it('should return a value of type string if passing a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const value = parse([{ name: 'John', age: '25' }])\n      expectTypeOf(value).toEqualTypeOf<Array<{ name: string; age: number }>>()\n    })\n  })\n}\n"],"names":["createParser","assertArray","value","ValidationError"],"mappings":";;;;;;;;;;AAqBO,SAAS,qBAA2C,OAA0B;AAC7E,QAAA,QAAQA,aAAAA,aAAa,GAAG,KAAK;AAEnC,SAAO,CAAC,UAAmB;AACzBC,WAAA,YAAY,KAAK;AACjB,QAAI,QAAQ;AACZ,UAAM,SAAS,CAAA;AACf,eAAW,QAAQ,OAAO;AACpB,UAAA;AACIC,cAAAA,SAAQ,MAAM,IAAI;AACxB,eAAO,KAAKA,MAAK;AAAA,eAGZ,OAAO;AACZ,cAAM,IAAIC,gBAAAA,gBAAgB;AAAA,UACxB,MAAM;AAAA,UACN,SAAS,2BAA2B,KAAK;AAAA,UACzC,OAAO;AAAA,QAAA,CACR;AAAA,MACH;AACA;AAAA,IACF;AAEO,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
diff --git a/dist/createArrayParser.js b/dist/createArrayParser.js
index ff57cdf38619c110ef82a38c254d0c6e7ef5e1e0..4e65d5aa0f633462f2a9ec50baf4ba771522fa73 100644
--- a/dist/createArrayParser.js
+++ b/dist/createArrayParser.js
@@ -2,6 +2,7 @@ import { assertArray } from "./assert.js";
 import { createParser } from "./createParser.js";
 import { ValidationError } from "./ValidationError.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 import "@unshared/functions/tries";
 import "./createRuleChain.js";
diff --git a/dist/createArrayParser.js.map b/dist/createArrayParser.js.map
index 26f9a870358a1ee74bf40f6476757107cda86e9a..2f6a1c96443059abd046b8e642f6497cf3369032 100644
--- a/dist/createArrayParser.js.map
+++ b/dist/createArrayParser.js.map
@@ -1 +1 @@
-{"version":3,"file":"createArrayParser.js","sources":["../createArrayParser.ts"],"sourcesContent":["import type { ParserLike, ParserResult } from './createParser'\nimport { assertArray } from './assert'\nimport { createParser } from './createParser'\nimport { ValidationError } from './ValidationError'\n\n/** A parser function that can be used to validate an array of values. */\nexport type ArrayParser<T extends ParserLike> =\n  (value: unknown) => Array<ParserResult<T>>\n\n/**\n * Create a parser function that can be used to validate an array of values.\n *\n * @param rules The rules or schema to use to validate the array.\n * @returns A parser function that can be used to validate an array of values.\n * @example\n * // Create a parser function from a schema.\n * const parse = createArrayParser([String])\n *\n * // Parse the value.\n * const result = parse(['Hello, World!']) // ['Hello, World!']\n */\nexport function createArrayParser<T extends ParserLike>(...rules: T): ArrayParser<T> {\n  const parse = createParser(...rules)\n\n  return (value: unknown) => {\n    assertArray(value)\n    let index = 0\n    const result = []\n    for (const item of value) {\n      try {\n        const value = parse(item)\n        result.push(value)\n      }\n\n      catch (error) {\n        throw new ValidationError({\n          name: 'E_ARRAY_VALIDATION_ERROR',\n          message: `Expected value at index ${index} to pass validation but received an error.`,\n          cause: error,\n        })\n      }\n      index++\n    }\n\n    return result\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertStringNumber } = await import('./assert')\n\n  describe('validate and parse an array of values', () => {\n    it('should assert it is an array', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse([])\n      expect(result).toStrictEqual([])\n    })\n\n    it('should not mutate the original array', () => {\n      const parse = createArrayParser(assertString, (x: string) => x.toUpperCase())\n      const value = ['Hello', 'World']\n      const result = parse(value)\n      expect(result).toStrictEqual(['HELLO', 'WORLD'])\n      expect(value).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert it is an array of strings', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse(['Hello', 'World'])\n      expect(result).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert strings and convert to numbers', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const result = parse(['5', '10'])\n      expect(result).toStrictEqual([5, 10])\n    })\n\n    it('should assert strings and convert to numbers if possible or uppercase', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString, (x: string) => x.toUpperCase()])\n      const result = parse(['5', 'Hello'])\n      expect(result).toStrictEqual([5, 'HELLO'])\n    })\n\n    it('should assert an array of object matching a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const result = parse([{ name: 'John', age: '25' }])\n      expect(result).toStrictEqual([{ name: 'John', age: 25 }])\n    })\n  })\n\n  describe('error handling', () => {\n    it('should throw if value is not an array', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse({})\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n    })\n\n    it('should throw if value is undefined', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const shouldThrow = () => parse(undefined)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n    })\n\n    it('should throw if value is null', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-null\n      const shouldThrow = () => parse(null)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n    })\n\n    it('should throw if value at index fails validation', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse(['Hello, World!', 5])\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value at index 1 to pass validation but received an error.')\n    })\n  })\n\n  describe('return type', () => {\n    it('should return a value of type string if passing a single rule', () => {\n      const parse = createArrayParser(assertString)\n      const value = parse(['Hello, World!'])\n      expectTypeOf(value).toEqualTypeOf<string[]>()\n    })\n\n    it('should return a value of type string if passing a rule chain', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<number[]>()\n    })\n\n    it('should return a value of type string if passing a rule set', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString])\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<Array<number | string>>()\n    })\n\n    it('should return a value of type string if passing a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const value = parse([{ name: 'John', age: '25' }])\n      expectTypeOf(value).toEqualTypeOf<Array<{ name: string; age: number }>>()\n    })\n  })\n}\n"],"names":["value"],"mappings":";;;;;;;;;;AAqBO,SAAS,qBAA2C,OAA0B;AAC7E,QAAA,QAAQ,aAAa,GAAG,KAAK;AAEnC,SAAO,CAAC,UAAmB;AACzB,gBAAY,KAAK;AACjB,QAAI,QAAQ;AACZ,UAAM,SAAS,CAAA;AACf,eAAW,QAAQ,OAAO;AACpB,UAAA;AACIA,cAAAA,SAAQ,MAAM,IAAI;AACxB,eAAO,KAAKA,MAAK;AAAA,eAGZ,OAAO;AACZ,cAAM,IAAI,gBAAgB;AAAA,UACxB,MAAM;AAAA,UACN,SAAS,2BAA2B,KAAK;AAAA,UACzC,OAAO;AAAA,QAAA,CACR;AAAA,MACH;AACA;AAAA,IACF;AAEO,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
+{"version":3,"file":"createArrayParser.js","sources":["../createArrayParser.ts"],"sourcesContent":["import type { ParserLike, ParserResult } from './createParser'\nimport { assertArray } from './assert'\nimport { createParser } from './createParser'\nimport { ValidationError } from './ValidationError'\n\n/** A parser function that can be used to validate an array of values. */\nexport type ArrayParser<T extends ParserLike> =\n  (value: unknown) => Array<ParserResult<T>>\n\n/**\n * Create a parser function that can be used to validate an array of values.\n *\n * @param rules The rules or schema to use to validate the array.\n * @returns A parser function that can be used to validate an array of values.\n * @example\n * // Create a parser function from a schema.\n * const parse = createArrayParser([String])\n *\n * // Parse the value.\n * const result = parse(['Hello, World!']) // ['Hello, World!']\n */\nexport function createArrayParser<T extends ParserLike>(...rules: T): ArrayParser<T> {\n  const parse = createParser(...rules)\n\n  return (value: unknown) => {\n    assertArray(value)\n    let index = 0\n    const result = []\n    for (const item of value) {\n      try {\n        const value = parse(item)\n        result.push(value)\n      }\n\n      catch (error) {\n        throw new ValidationError({\n          name: 'E_ARRAY_VALIDATION_ERROR',\n          message: `Expected value at index ${index} to pass validation but received an error.`,\n          cause: error,\n        })\n      }\n      index++\n    }\n\n    return result\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertStringNumber } = await import('./assert')\n\n  describe('validate and parse an array of values', () => {\n    it('should assert it is an array', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse([])\n      expect(result).toStrictEqual([])\n    })\n\n    it('should not mutate the original array', () => {\n      const parse = createArrayParser(assertString, (x: string) => x.toUpperCase())\n      const value = ['Hello', 'World']\n      const result = parse(value)\n      expect(result).toStrictEqual(['HELLO', 'WORLD'])\n      expect(value).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert it is an array of strings', () => {\n      const parse = createArrayParser(assertString)\n      const result = parse(['Hello', 'World'])\n      expect(result).toStrictEqual(['Hello', 'World'])\n    })\n\n    it('should assert strings and convert to numbers', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const result = parse(['5', '10'])\n      expect(result).toStrictEqual([5, 10])\n    })\n\n    it('should assert strings and convert to numbers if possible or uppercase', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString, (x: string) => x.toUpperCase()])\n      const result = parse(['5', 'Hello'])\n      expect(result).toStrictEqual([5, 'HELLO'])\n    })\n\n    it('should assert an array of object matching a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const result = parse([{ name: 'John', age: '25' }])\n      expect(result).toStrictEqual([{ name: 'John', age: 25 }])\n    })\n  })\n\n  describe('error handling', () => {\n    it('should throw if value is not an array', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse({})\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: object')\n    })\n\n    it('should throw if value is undefined', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const shouldThrow = () => parse(undefined)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: undefined')\n    })\n\n    it('should throw if value is null', () => {\n      const parse = createArrayParser(assertString)\n      // eslint-disable-next-line unicorn/no-null\n      const shouldThrow = () => parse(null)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be an array but received: null')\n    })\n\n    it('should throw if value at index fails validation', () => {\n      const parse = createArrayParser(assertString)\n      const shouldThrow = () => parse(['Hello, World!', 5])\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value at index 1 to pass validation but received an error.')\n    })\n  })\n\n  describe('return type', () => {\n    it('should return a value of type string if passing a single rule', () => {\n      const parse = createArrayParser(assertString)\n      const value = parse(['Hello, World!'])\n      expectTypeOf(value).toEqualTypeOf<string[]>()\n    })\n\n    it('should return a value of type string if passing a rule chain', () => {\n      const parse = createArrayParser(assertStringNumber, Number)\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<number[]>()\n    })\n\n    it('should return a value of type string if passing a rule set', () => {\n      const parse = createArrayParser([assertStringNumber, Number], [assertString])\n      const value = parse(['5'])\n      expectTypeOf(value).toEqualTypeOf<Array<number | string>>()\n    })\n\n    it('should return a value of type string if passing a schema', () => {\n      const parse = createArrayParser({ name: assertString, age: [assertStringNumber, Number] })\n      const value = parse([{ name: 'John', age: '25' }])\n      expectTypeOf(value).toEqualTypeOf<Array<{ name: string; age: number }>>()\n    })\n  })\n}\n"],"names":["value"],"mappings":";;;;;;;;;;;AAqBO,SAAS,qBAA2C,OAA0B;AAC7E,QAAA,QAAQ,aAAa,GAAG,KAAK;AAEnC,SAAO,CAAC,UAAmB;AACzB,gBAAY,KAAK;AACjB,QAAI,QAAQ;AACZ,UAAM,SAAS,CAAA;AACf,eAAW,QAAQ,OAAO;AACpB,UAAA;AACIA,cAAAA,SAAQ,MAAM,IAAI;AACxB,eAAO,KAAKA,MAAK;AAAA,eAGZ,OAAO;AACZ,cAAM,IAAI,gBAAgB;AAAA,UACxB,MAAM;AAAA,UACN,SAAS,2BAA2B,KAAK;AAAA,UACzC,OAAO;AAAA,QAAA,CACR;AAAA,MACH;AACA;AAAA,IACF;AAEO,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
diff --git a/dist/createParser.cjs b/dist/createParser.cjs
index 961f1dca14476ca7b765f637cf3a7ecbb872645e..3be874a5572141c3b9f4bd307d2535d63057dea1 100644
--- a/dist/createParser.cjs
+++ b/dist/createParser.cjs
@@ -4,6 +4,7 @@ require("./ValidationError.cjs");
 require("./createRule.cjs");
 require("./assert.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 function createParser(...rules) {
   const parse = tries.tries(
diff --git a/dist/createParser.cjs.map b/dist/createParser.cjs.map
index 48d12a242ca30d696bbd95b40cb8e9cddfa6b2bf..328f03566b2aeb58eebc931d9eee9374904037ec 100644
--- a/dist/createParser.cjs.map
+++ b/dist/createParser.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createParser.cjs","sources":["../createParser.ts"],"sourcesContent":["import type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport type { SchemaLike, SchemaResult } from './createSchema'\nimport { tries } from '@unshared/functions/tries'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { createSchema } from './createSchema'\nimport { ValidationError } from './ValidationError'\n\n/** A set of rules or a schema that can be used to validate a value. */\nexport type ParserLike = [SchemaLike] | RuleChainLike | RuleSetLike\n\n/** The result of a parser function. */\nexport type ParserResult<T extends ParserLike> =\n  T extends [SchemaLike] ? SchemaResult<T[0]> :\n    T extends RuleChainLike ? RuleChainResult<T> :\n      T extends RuleSetLike ? RuleSetResult<T> :\n        never\n\n/** A parser function that can be used to validate a value. */\nexport type Parser<T extends ParserLike = ParserLike> =\n  (value: unknown) => ParserResult<T>\n\n/**\n * Create a parser function given a map of rules.\n *\n * @param rules The rules or schema to use to validate the value.\n * @returns A parser function that can be used to validate a value.\n * @example\n * // Create a parser function from a schema.\n * const parse = createParser({\n *   name: isString,\n *   age: [assertStringNumber, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' }) // { name: 'John', age: 25 }\n */\nexport function createParser<T extends ParserLike>(...rules: T): Parser<T> {\n  const parse = tries(\n    () => createRuleChain(...rules as RuleChainLike),\n    () => createRuleSet(...rules as RuleSetLike),\n    () => createSchema(rules[0] as SchemaLike),\n  )\n\n  // --- If none of the functions return a valid parser, throw an error.\n  if (!parse) throw new TypeError('The value passed to createParser is not a valid rule, rule chain, rule set, or schema.')\n  return parse as Parser<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertNumber, assertStringNumber, assertUndefined } = await import('./assert')\n\n  test('should create a parser function from a single rule', () => {\n    const rule = createParser(assertStringNumber)\n    const result = rule('5')\n    expect(result).toBe('5')\n    expectTypeOf(result).toEqualTypeOf<`${number}`>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => `${number}`>()\n  })\n\n  test('should create a parser function from a rule chain', () => {\n    const rule = createParser(assertStringNumber, Number)\n    const result = rule('5')\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n  })\n\n  test('should create a parser function from a rule set', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber], [assertUndefined])\n    const result = rule(5)\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number | undefined>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n  })\n\n  test('should create a parser function from a schema', () => {\n    const rule = createParser({ name: assertString, age: [assertStringNumber, Number] })\n    const result = rule({ name: 'John', age: '25' })\n    expect(result).toStrictEqual({ name: 'John', age: 25 })\n    expectTypeOf(result).toEqualTypeOf<{ name: string; age: number }>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => { name: string; age: number }>()\n  })\n\n  test('should throw a validation error if no rule passes', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber])\n    const shouldThrow = () => rule('a')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n  })\n}\n"],"names":["tries","createRuleChain","createRuleSet","createSchema"],"mappings":";;;;;;;AAsCO,SAAS,gBAAsC,OAAqB;AACzE,QAAM,QAAQA,MAAA;AAAA,IACZ,MAAMC,gBAAAA,gBAAgB,GAAG,KAAsB;AAAA,IAC/C,MAAMC,cAAAA,cAAc,GAAG,KAAoB;AAAA,IAC3C,MAAMC,aAAA,aAAa,MAAM,CAAC,CAAe;AAAA,EAAA;AAI3C,MAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACjH,SAAA;AACT;;"}
\ No newline at end of file
+{"version":3,"file":"createParser.cjs","sources":["../createParser.ts"],"sourcesContent":["import type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport type { SchemaLike, SchemaResult } from './createSchema'\nimport { tries } from '@unshared/functions/tries'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { createSchema } from './createSchema'\nimport { ValidationError } from './ValidationError'\n\n/** A set of rules or a schema that can be used to validate a value. */\nexport type ParserLike = [SchemaLike] | RuleChainLike | RuleSetLike\n\n/** The result of a parser function. */\nexport type ParserResult<T extends ParserLike> =\n  T extends [SchemaLike] ? SchemaResult<T[0]> :\n    T extends RuleChainLike ? RuleChainResult<T> :\n      T extends RuleSetLike ? RuleSetResult<T> :\n        never\n\n/** A parser function that can be used to validate a value. */\nexport type Parser<T extends ParserLike = ParserLike> =\n  (value: unknown) => ParserResult<T>\n\n/**\n * Create a parser function given a map of rules.\n *\n * @param rules The rules or schema to use to validate the value.\n * @returns A parser function that can be used to validate a value.\n * @example\n * // Create a parser function from a schema.\n * const parse = createParser({\n *   name: isString,\n *   age: [assertStringNumber, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' }) // { name: 'John', age: 25 }\n */\nexport function createParser<T extends ParserLike>(...rules: T): Parser<T> {\n  const parse = tries(\n    () => createRuleChain(...rules as RuleChainLike),\n    () => createRuleSet(...rules as RuleSetLike),\n    () => createSchema(rules[0] as SchemaLike),\n  )\n\n  // --- If none of the functions return a valid parser, throw an error.\n  if (!parse) throw new TypeError('The value passed to createParser is not a valid rule, rule chain, rule set, or schema.')\n  return parse as Parser<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertNumber, assertStringNumber, assertUndefined } = await import('./assert')\n\n  test('should create a parser function from a single rule', () => {\n    const rule = createParser(assertStringNumber)\n    const result = rule('5')\n    expect(result).toBe('5')\n    expectTypeOf(result).toEqualTypeOf<`${number}`>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => `${number}`>()\n  })\n\n  test('should create a parser function from a rule chain', () => {\n    const rule = createParser(assertStringNumber, Number)\n    const result = rule('5')\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n  })\n\n  test('should create a parser function from a rule set', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber], [assertUndefined])\n    const result = rule(5)\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number | undefined>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n  })\n\n  test('should create a parser function from a schema', () => {\n    const rule = createParser({ name: assertString, age: [assertStringNumber, Number] })\n    const result = rule({ name: 'John', age: '25' })\n    expect(result).toStrictEqual({ name: 'John', age: 25 })\n    expectTypeOf(result).toEqualTypeOf<{ name: string; age: number }>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => { name: string; age: number }>()\n  })\n\n  test('should throw a validation error if no rule passes', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber])\n    const shouldThrow = () => rule('a')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n  })\n}\n"],"names":["tries","createRuleChain","createRuleSet","createSchema"],"mappings":";;;;;;;;AAsCO,SAAS,gBAAsC,OAAqB;AACzE,QAAM,QAAQA,MAAA;AAAA,IACZ,MAAMC,gBAAAA,gBAAgB,GAAG,KAAsB;AAAA,IAC/C,MAAMC,cAAAA,cAAc,GAAG,KAAoB;AAAA,IAC3C,MAAMC,aAAA,aAAa,MAAM,CAAC,CAAe;AAAA,EAAA;AAI3C,MAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACjH,SAAA;AACT;;"}
\ No newline at end of file
diff --git a/dist/createParser.js b/dist/createParser.js
index e5ab43640f96aa2ca3c17a78bc78ed2079d8e56c..1e86d370ab5592a7ace1a0a0da2e8f7e6a30ac30 100644
--- a/dist/createParser.js
+++ b/dist/createParser.js
@@ -6,6 +6,7 @@ import "./ValidationError.js";
 import "./createRule.js";
 import "./assert.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 function createParser(...rules) {
   const parse = tries(
diff --git a/dist/createParser.js.map b/dist/createParser.js.map
index 5736014ac20fc2396632b999a89f8d8ac0feea54..44c72db7fd4111b81bac362f2ff8ba648987e906 100644
--- a/dist/createParser.js.map
+++ b/dist/createParser.js.map
@@ -1 +1 @@
-{"version":3,"file":"createParser.js","sources":["../createParser.ts"],"sourcesContent":["import type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport type { SchemaLike, SchemaResult } from './createSchema'\nimport { tries } from '@unshared/functions/tries'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { createSchema } from './createSchema'\nimport { ValidationError } from './ValidationError'\n\n/** A set of rules or a schema that can be used to validate a value. */\nexport type ParserLike = [SchemaLike] | RuleChainLike | RuleSetLike\n\n/** The result of a parser function. */\nexport type ParserResult<T extends ParserLike> =\n  T extends [SchemaLike] ? SchemaResult<T[0]> :\n    T extends RuleChainLike ? RuleChainResult<T> :\n      T extends RuleSetLike ? RuleSetResult<T> :\n        never\n\n/** A parser function that can be used to validate a value. */\nexport type Parser<T extends ParserLike = ParserLike> =\n  (value: unknown) => ParserResult<T>\n\n/**\n * Create a parser function given a map of rules.\n *\n * @param rules The rules or schema to use to validate the value.\n * @returns A parser function that can be used to validate a value.\n * @example\n * // Create a parser function from a schema.\n * const parse = createParser({\n *   name: isString,\n *   age: [assertStringNumber, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' }) // { name: 'John', age: 25 }\n */\nexport function createParser<T extends ParserLike>(...rules: T): Parser<T> {\n  const parse = tries(\n    () => createRuleChain(...rules as RuleChainLike),\n    () => createRuleSet(...rules as RuleSetLike),\n    () => createSchema(rules[0] as SchemaLike),\n  )\n\n  // --- If none of the functions return a valid parser, throw an error.\n  if (!parse) throw new TypeError('The value passed to createParser is not a valid rule, rule chain, rule set, or schema.')\n  return parse as Parser<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertNumber, assertStringNumber, assertUndefined } = await import('./assert')\n\n  test('should create a parser function from a single rule', () => {\n    const rule = createParser(assertStringNumber)\n    const result = rule('5')\n    expect(result).toBe('5')\n    expectTypeOf(result).toEqualTypeOf<`${number}`>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => `${number}`>()\n  })\n\n  test('should create a parser function from a rule chain', () => {\n    const rule = createParser(assertStringNumber, Number)\n    const result = rule('5')\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n  })\n\n  test('should create a parser function from a rule set', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber], [assertUndefined])\n    const result = rule(5)\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number | undefined>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n  })\n\n  test('should create a parser function from a schema', () => {\n    const rule = createParser({ name: assertString, age: [assertStringNumber, Number] })\n    const result = rule({ name: 'John', age: '25' })\n    expect(result).toStrictEqual({ name: 'John', age: 25 })\n    expectTypeOf(result).toEqualTypeOf<{ name: string; age: number }>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => { name: string; age: number }>()\n  })\n\n  test('should throw a validation error if no rule passes', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber])\n    const shouldThrow = () => rule('a')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;AAsCO,SAAS,gBAAsC,OAAqB;AACzE,QAAM,QAAQ;AAAA,IACZ,MAAM,gBAAgB,GAAG,KAAsB;AAAA,IAC/C,MAAM,cAAc,GAAG,KAAoB;AAAA,IAC3C,MAAM,aAAa,MAAM,CAAC,CAAe;AAAA,EAAA;AAI3C,MAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACjH,SAAA;AACT;"}
\ No newline at end of file
+{"version":3,"file":"createParser.js","sources":["../createParser.ts"],"sourcesContent":["import type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport type { SchemaLike, SchemaResult } from './createSchema'\nimport { tries } from '@unshared/functions/tries'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { createSchema } from './createSchema'\nimport { ValidationError } from './ValidationError'\n\n/** A set of rules or a schema that can be used to validate a value. */\nexport type ParserLike = [SchemaLike] | RuleChainLike | RuleSetLike\n\n/** The result of a parser function. */\nexport type ParserResult<T extends ParserLike> =\n  T extends [SchemaLike] ? SchemaResult<T[0]> :\n    T extends RuleChainLike ? RuleChainResult<T> :\n      T extends RuleSetLike ? RuleSetResult<T> :\n        never\n\n/** A parser function that can be used to validate a value. */\nexport type Parser<T extends ParserLike = ParserLike> =\n  (value: unknown) => ParserResult<T>\n\n/**\n * Create a parser function given a map of rules.\n *\n * @param rules The rules or schema to use to validate the value.\n * @returns A parser function that can be used to validate a value.\n * @example\n * // Create a parser function from a schema.\n * const parse = createParser({\n *   name: isString,\n *   age: [assertStringNumber, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' }) // { name: 'John', age: 25 }\n */\nexport function createParser<T extends ParserLike>(...rules: T): Parser<T> {\n  const parse = tries(\n    () => createRuleChain(...rules as RuleChainLike),\n    () => createRuleSet(...rules as RuleSetLike),\n    () => createSchema(rules[0] as SchemaLike),\n  )\n\n  // --- If none of the functions return a valid parser, throw an error.\n  if (!parse) throw new TypeError('The value passed to createParser is not a valid rule, rule chain, rule set, or schema.')\n  return parse as Parser<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertNumber, assertStringNumber, assertUndefined } = await import('./assert')\n\n  test('should create a parser function from a single rule', () => {\n    const rule = createParser(assertStringNumber)\n    const result = rule('5')\n    expect(result).toBe('5')\n    expectTypeOf(result).toEqualTypeOf<`${number}`>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => `${number}`>()\n  })\n\n  test('should create a parser function from a rule chain', () => {\n    const rule = createParser(assertStringNumber, Number)\n    const result = rule('5')\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n  })\n\n  test('should create a parser function from a rule set', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber], [assertUndefined])\n    const result = rule(5)\n    expect(result).toBe(5)\n    expectTypeOf(result).toEqualTypeOf<number | undefined>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n  })\n\n  test('should create a parser function from a schema', () => {\n    const rule = createParser({ name: assertString, age: [assertStringNumber, Number] })\n    const result = rule({ name: 'John', age: '25' })\n    expect(result).toStrictEqual({ name: 'John', age: 25 })\n    expectTypeOf(result).toEqualTypeOf<{ name: string; age: number }>()\n    expectTypeOf(rule).toEqualTypeOf<(value: unknown) => { name: string; age: number }>()\n  })\n\n  test('should throw a validation error if no rule passes', () => {\n    const rule = createParser([assertStringNumber, Number], [assertNumber])\n    const shouldThrow = () => rule('a')\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;;AAsCO,SAAS,gBAAsC,OAAqB;AACzE,QAAM,QAAQ;AAAA,IACZ,MAAM,gBAAgB,GAAG,KAAsB;AAAA,IAC/C,MAAM,cAAc,GAAG,KAAoB;AAAA,IAC3C,MAAM,aAAa,MAAM,CAAC,CAAe;AAAA,EAAA;AAI3C,MAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACjH,SAAA;AACT;"}
\ No newline at end of file
diff --git a/dist/createRule.cjs b/dist/createRule.cjs
index fdef62f30123b14c61122eca4f3ad93cc36e2f46..f45fc59063d86e141e728eff7dc57b70e595f299 100644
--- a/dist/createRule.cjs
+++ b/dist/createRule.cjs
@@ -2,6 +2,7 @@
 var assert = require("./assert.cjs");
 require("./ValidationError.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 function createRule(rule) {
   if (rule instanceof RegExp)
diff --git a/dist/createRule.cjs.map b/dist/createRule.cjs.map
index a1ca73da9e8aa9090165aafdac59f004c16e9f3f..4be9da70e166dd7d38018b552b5c191ebe474093 100644
--- a/dist/createRule.cjs.map
+++ b/dist/createRule.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createRule.cjs","sources":["../createRule.ts"],"sourcesContent":["import type { Function, IsUnknown, NotFunction } from '@unshared/types'\nimport { assertString, assertStringMatching } from './assert'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A rule-like value can be a regular expression or a function that validates and/or transforms a value.\n * It can also be an array that contains a regular expression and a replacement string, or a function\n * and its right-most parameters.\n *\n * @template U The value returned by the rule function.\n * @example RuleLike<number> = RegExp | Function<number> | [RegExp, string] | [Function<number>, ...NotFunction[]]\n */\nexport type RuleLike<U = unknown> =\n  | [handler: Function<U>, ...NotFunction[]]\n  | [handler: RegExp, replacement: string]\n  | Function<U>\n  | RegExp\n\n/**\n * Infer the result of a rule given a `RuleLike` function.\n *\n * @template T The type of the rule-like function.\n * @example RuleFunctionResult<(value: string) => asserts value is string> = string\n */\ntype RuleFunctionResult<T extends Function> =\n  T extends (value: any, ...rest: any[]) => asserts value is infer U\n    ? IsUnknown<U> extends false ? U\n\n      // --- If the function returns void or undefined, return the value.\n      : T extends (value: infer V, ...rest: any[]) => infer U\n        ? (undefined | void) extends U ? V : U\n        : never\n    : never\n\n/**\n * Infer the result of a rule given a `RuleLike` value.\n *\n * @template T The type of the rule-like value.\n * @example RuleResult<RegExp> = string\n */\nexport type RuleResult<T extends RuleLike> =\n  RuleLike extends T ? unknown\n\n  // --- If the rule is a RegExp matcher or replacer.\n    : T extends RegExp ? string\n      : T extends [RegExp, string] ? string\n\n      // --- If the rule is an assertion function.\n        : T extends Function ? RuleFunctionResult<T>\n          : T extends [infer F extends Function, ...NotFunction[]] ? RuleFunctionResult<F>\n            : never\n\n/**\n * Infer the function type from a `RuleLike` value.\n *\n * @template T The type of the `RuleLike` value.\n * @example Rule<RegExp> = (value: string) => asserts value is string\n */\nexport type Rule<T extends RuleLike = RuleLike> =\n  T extends (...args: infer P) => any\n    ? (...args: P) => RuleResult<T>\n\n  // --- If the rule is a parameterized function.\n    : T extends [(value: infer V, ...rest: any[]) => any, ...any[]]\n      ? (value: V) => RuleResult<T>\n      : (value: unknown) => RuleResult<T>\n\n/**\n * Convert a {@linkcode RuleLike} value into a rule function. This function can be used to create a rule\n * function from a regular expression, a function, or an array that contains a regular expression\n * and a replacement string, or a function with it's n+1 parameters bound to the function.\n *\n * @param rule The rule-like value to convert into a rule function.\n * @returns A function that validates and/or transforms a value.\n * @example\n * // Validates a string against a regular expression.\n * const isEmail = createRule(/^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/i) // (value: unknown) => string\n *\n * // Validates using a function that throws a `ValidationError` if the value is invalid.\n * const isString = createRule((value) => {\n *   if (typeof value !== 'string') throw new ValidationError('E_TYPE_NOT_STRING')\n * })\n *\n * // Remove the 'http://' prefix from a string.\n * const removeHttp = createRule([/^http:\\/\\//, '']) // (value: string) => string\n *\n * // Transforms a string to a number.\n * const toUpperCase = createRule(Number)\n */\nexport function createRule<T extends RuleLike>(rule: T): Rule<T>\nexport function createRule(rule: RuleLike): Function {\n\n  // --- Short-circuit to the `isStringMatching` function if the rule is a regular expression.\n  if (rule instanceof RegExp) {\n    return (value: unknown) => {\n      assertStringMatching(value, rule)\n      return value\n    }\n  }\n\n  // --- If the rule is a function, wrap it in a function that calls the rule\n  // --- and returns the value if the the result is undefined.\n  if (typeof rule === 'function') {\n    return function(this: unknown, value: unknown) {\n      const result = rule.call(this, value)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- At this point, the rule must be an array of at least two elements.\n  if (!Array.isArray(rule))\n    throw new TypeError(`Rule must be a function, RegExp or array, got ${typeof rule}`)\n  if (rule.length < 2)\n    throw new TypeError('Paremeterized rule must have at least two elements')\n\n  // --- Create a function that replaces the value with a string.\n  if (rule[0] instanceof RegExp) {\n    const [exp, replacement] = rule\n    if (typeof replacement !== 'string')\n      throw new TypeError('Remplacement rule must have a string as second element')\n    return (value) => {\n      assertString(value)\n      return value.replace(exp, replacement)\n    }\n  }\n\n  // --- Create a function with the parameters bound to the rule function.\n  if (typeof rule[0] === 'function') {\n    const [handler, ...parameters] = rule as [Function<unknown>, ...NotFunction[]]\n    if (typeof parameters[0] === 'function')\n      throw new TypeError('Paremeterized rule must not have a function as second element')\n    return function(this: unknown, value: unknown) {\n      const result = handler.call(this, value, ...parameters)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- Invalid rule.\n  throw new TypeError('Invalid rule, must be a function, RegExp or array')\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: assertString, assertNumberBetween } = await import('./assert')\n\n  describe('rule from function', () => {\n    it('should return the value if it is a string', () => {\n      const rule = createRule(assertString)\n      const result = rule('test')\n      expect(result).toBe('test')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw an error if the value is not a string', () => {\n      const rule = createRule(assertString)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n\n    it('should transform the value to uppercase', () => {\n      const fn = (value: string) => value.toUpperCase()\n      const rule = createRule(fn)\n      const result = rule('test')\n      expect(result).toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => string>()\n    })\n\n    it('should create a rule from an async function and return it as-is', async() => {\n      const fn = (value: string) => Promise.resolve(value.toUpperCase())\n      const rule = createRule(fn)\n      const result = rule('test')\n      await expect(result).resolves.toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => Promise<string>>()\n    })\n\n    it('should create a rule from a Number constructor and return a number', () => {\n      const rule = createRule(Number)\n      const result = rule('1')\n      expect(result).toBe(1)\n      expectTypeOf(rule).toEqualTypeOf<(value?: any) => number>()\n    })\n\n    it('should create a rule from a Boolean constructor and return a boolean', () => {\n      const rule = createRule(Boolean)\n      const result = rule(0)\n      expect(result).toBe(false)\n      expectTypeOf(rule).toEqualTypeOf<(value?: unknown) => boolean>()\n    })\n\n    it('should preserve the function context', () => {\n      const context = { value: 'test' }\n      const fn = function(this: typeof context) { return this.value }\n      const rule = createRule(fn)\n      const result = rule.call(context)\n      expect(result).toBe('test')\n    })\n  })\n\n  describe('rule from parameterized function', () => {\n    it('should create a rule with parameters pre-bound to the function', () => {\n      const rule = createRule([assertNumberBetween, 2, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should return undefined if the value is in range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n    })\n\n    it('should throw a ValidationError if the value is out of range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const shouldThrow = () => rule(0)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a number between 1 and 3 but received: 0')\n    })\n  })\n\n  describe('assertion rule from RegExp', () => {\n    it('should return the value if it matches the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const result = rule('a')\n      expect(result).toBe('a')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw a ValidationError if the value does not match the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule('1')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: 1')\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('transform rule from RegExp', () => {\n    it('should replace the value with the replacement string if it matches the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello World')\n      expect(result).toBe('Hello Earth')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should not replace the value if it does not match the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello')\n      expect(result).toBe('Hello')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('type inference', () => {\n    it('should infer the return type of a rule from a transform function', () => {\n      type Result = RuleResult<(value: string) => number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from an assertion function', () => {\n      type Result = RuleResult<(value: unknown) => asserts value is number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a function that returns void | undefined', () => {\n      type Result = RuleResult<(value: string) => undefined | void>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a parameterized function', () => {\n      type Result = RuleResult<[(value: number, min: number, max: number) => asserts value is number, number, number]>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a regular expression', () => {\n      type Result = RuleResult<RegExp>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a replacement regular expression', () => {\n      type Result = RuleResult<[RegExp, string]>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw a TypeError if the rule is not a function, RegExp or array', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule(1)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array')\n    })\n\n    it('should throw a TypeError if the rule is an array with less than two elements', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([/World/])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must have at least two elements')\n    })\n\n    it('should throw a TypeError if the second parameter is a function', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw a TypeError if the replacement is not a string', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n\n    it('should throw a TypeError if the rule is an array with a function as the first element', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule(['foo', 'bar'])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Invalid rule, must be a function, RegExp or array')\n    })\n  })\n}\n"],"names":["assertStringMatching","assertString"],"mappings":";;;;;AA0FO,SAAS,WAAW,MAA0B;AAGnD,MAAI,gBAAgB;AAClB,WAAO,CAAC,WACNA,OAAqB,qBAAA,OAAO,IAAI,GACzB;AAMX,MAAI,OAAO,QAAS;AAClB,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,KAAK,KAAK,MAAM,KAAK;AAC7B,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAKtC,MAAA,CAAC,MAAM,QAAQ,IAAI;AACrB,UAAM,IAAI,UAAU,iDAAiD,OAAO,IAAI,EAAE;AACpF,MAAI,KAAK,SAAS;AACV,UAAA,IAAI,UAAU,oDAAoD;AAGtE,MAAA,KAAK,CAAC,aAAa,QAAQ;AACvB,UAAA,CAAC,KAAK,WAAW,IAAI;AAC3B,QAAI,OAAO,eAAgB;AACnB,YAAA,IAAI,UAAU,wDAAwD;AACvE,WAAA,CAAC,WACNC,OAAa,aAAA,KAAK,GACX,MAAM,QAAQ,KAAK,WAAW;AAAA,EAEzC;AAGA,MAAI,OAAO,KAAK,CAAC,KAAM,YAAY;AACjC,UAAM,CAAC,SAAS,GAAG,UAAU,IAAI;AAC7B,QAAA,OAAO,WAAW,CAAC,KAAM;AACrB,YAAA,IAAI,UAAU,+DAA+D;AACrF,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,QAAQ,KAAK,MAAM,OAAO,GAAG,UAAU;AAC/C,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAAA,EAE1C;AAGM,QAAA,IAAI,UAAU,mDAAmD;AACzE;;"}
\ No newline at end of file
+{"version":3,"file":"createRule.cjs","sources":["../createRule.ts"],"sourcesContent":["import type { Function, IsUnknown, NotFunction } from '@unshared/types'\nimport { assertString, assertStringMatching } from './assert'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A rule-like value can be a regular expression or a function that validates and/or transforms a value.\n * It can also be an array that contains a regular expression and a replacement string, or a function\n * and its right-most parameters.\n *\n * @template U The value returned by the rule function.\n * @example RuleLike<number> = RegExp | Function<number> | [RegExp, string] | [Function<number>, ...NotFunction[]]\n */\nexport type RuleLike<U = unknown> =\n  | [handler: Function<U>, ...NotFunction[]]\n  | [handler: RegExp, replacement: string]\n  | Function<U>\n  | RegExp\n\n/**\n * Infer the result of a rule given a `RuleLike` function.\n *\n * @template T The type of the rule-like function.\n * @example RuleFunctionResult<(value: string) => asserts value is string> = string\n */\ntype RuleFunctionResult<T extends Function> =\n  T extends (value: any, ...rest: any[]) => asserts value is infer U\n    ? IsUnknown<U> extends false ? U\n\n      // --- If the function returns void or undefined, return the value.\n      : T extends (value: infer V, ...rest: any[]) => infer U\n        ? (undefined | void) extends U ? V : U\n        : never\n    : never\n\n/**\n * Infer the result of a rule given a `RuleLike` value.\n *\n * @template T The type of the rule-like value.\n * @example RuleResult<RegExp> = string\n */\nexport type RuleResult<T extends RuleLike> =\n  RuleLike extends T ? unknown\n\n  // --- If the rule is a RegExp matcher or replacer.\n    : T extends RegExp ? string\n      : T extends [RegExp, string] ? string\n\n      // --- If the rule is an assertion function.\n        : T extends Function ? RuleFunctionResult<T>\n          : T extends [infer F extends Function, ...NotFunction[]] ? RuleFunctionResult<F>\n            : never\n\n/**\n * Infer the function type from a `RuleLike` value.\n *\n * @template T The type of the `RuleLike` value.\n * @example Rule<RegExp> = (value: string) => asserts value is string\n */\nexport type Rule<T extends RuleLike = RuleLike> =\n  T extends (...args: infer P) => any\n    ? (...args: P) => RuleResult<T>\n\n  // --- If the rule is a parameterized function.\n    : T extends [(value: infer V, ...rest: any[]) => any, ...any[]]\n      ? (value: V) => RuleResult<T>\n      : (value: unknown) => RuleResult<T>\n\n/**\n * Convert a {@linkcode RuleLike} value into a rule function. This function can be used to create a rule\n * function from a regular expression, a function, or an array that contains a regular expression\n * and a replacement string, or a function with it's n+1 parameters bound to the function.\n *\n * @param rule The rule-like value to convert into a rule function.\n * @returns A function that validates and/or transforms a value.\n * @example\n * // Validates a string against a regular expression.\n * const isEmail = createRule(/^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/i) // (value: unknown) => string\n *\n * // Validates using a function that throws a `ValidationError` if the value is invalid.\n * const isString = createRule((value) => {\n *   if (typeof value !== 'string') throw new ValidationError('E_TYPE_NOT_STRING')\n * })\n *\n * // Remove the 'http://' prefix from a string.\n * const removeHttp = createRule([/^http:\\/\\//, '']) // (value: string) => string\n *\n * // Transforms a string to a number.\n * const toUpperCase = createRule(Number)\n */\nexport function createRule<T extends RuleLike>(rule: T): Rule<T>\nexport function createRule(rule: RuleLike): Function {\n\n  // --- Short-circuit to the `isStringMatching` function if the rule is a regular expression.\n  if (rule instanceof RegExp) {\n    return (value: unknown) => {\n      assertStringMatching(value, rule)\n      return value\n    }\n  }\n\n  // --- If the rule is a function, wrap it in a function that calls the rule\n  // --- and returns the value if the the result is undefined.\n  if (typeof rule === 'function') {\n    return function(this: unknown, value: unknown) {\n      const result = rule.call(this, value)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- At this point, the rule must be an array of at least two elements.\n  if (!Array.isArray(rule))\n    throw new TypeError(`Rule must be a function, RegExp or array, got ${typeof rule}`)\n  if (rule.length < 2)\n    throw new TypeError('Paremeterized rule must have at least two elements')\n\n  // --- Create a function that replaces the value with a string.\n  if (rule[0] instanceof RegExp) {\n    const [exp, replacement] = rule\n    if (typeof replacement !== 'string')\n      throw new TypeError('Remplacement rule must have a string as second element')\n    return (value) => {\n      assertString(value)\n      return value.replace(exp, replacement)\n    }\n  }\n\n  // --- Create a function with the parameters bound to the rule function.\n  if (typeof rule[0] === 'function') {\n    const [handler, ...parameters] = rule as [Function<unknown>, ...NotFunction[]]\n    if (typeof parameters[0] === 'function')\n      throw new TypeError('Paremeterized rule must not have a function as second element')\n    return function(this: unknown, value: unknown) {\n      const result = handler.call(this, value, ...parameters)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- Invalid rule.\n  throw new TypeError('Invalid rule, must be a function, RegExp or array')\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: assertString, assertNumberBetween } = await import('./assert')\n\n  describe('rule from function', () => {\n    it('should return the value if it is a string', () => {\n      const rule = createRule(assertString)\n      const result = rule('test')\n      expect(result).toBe('test')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw an error if the value is not a string', () => {\n      const rule = createRule(assertString)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n\n    it('should transform the value to uppercase', () => {\n      const fn = (value: string) => value.toUpperCase()\n      const rule = createRule(fn)\n      const result = rule('test')\n      expect(result).toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => string>()\n    })\n\n    it('should create a rule from an async function and return it as-is', async() => {\n      const fn = (value: string) => Promise.resolve(value.toUpperCase())\n      const rule = createRule(fn)\n      const result = rule('test')\n      await expect(result).resolves.toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => Promise<string>>()\n    })\n\n    it('should create a rule from a Number constructor and return a number', () => {\n      const rule = createRule(Number)\n      const result = rule('1')\n      expect(result).toBe(1)\n      expectTypeOf(rule).toEqualTypeOf<(value?: any) => number>()\n    })\n\n    it('should create a rule from a Boolean constructor and return a boolean', () => {\n      const rule = createRule(Boolean)\n      const result = rule(0)\n      expect(result).toBe(false)\n      expectTypeOf(rule).toEqualTypeOf<(value?: unknown) => boolean>()\n    })\n\n    it('should preserve the function context', () => {\n      const context = { value: 'test' }\n      const fn = function(this: typeof context) { return this.value }\n      const rule = createRule(fn)\n      const result = rule.call(context)\n      expect(result).toBe('test')\n    })\n  })\n\n  describe('rule from parameterized function', () => {\n    it('should create a rule with parameters pre-bound to the function', () => {\n      const rule = createRule([assertNumberBetween, 2, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should return undefined if the value is in range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n    })\n\n    it('should throw a ValidationError if the value is out of range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const shouldThrow = () => rule(0)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a number between 1 and 3 but received: 0')\n    })\n  })\n\n  describe('assertion rule from RegExp', () => {\n    it('should return the value if it matches the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const result = rule('a')\n      expect(result).toBe('a')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw a ValidationError if the value does not match the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule('1')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: 1')\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('transform rule from RegExp', () => {\n    it('should replace the value with the replacement string if it matches the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello World')\n      expect(result).toBe('Hello Earth')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should not replace the value if it does not match the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello')\n      expect(result).toBe('Hello')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('type inference', () => {\n    it('should infer the return type of a rule from a transform function', () => {\n      type Result = RuleResult<(value: string) => number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from an assertion function', () => {\n      type Result = RuleResult<(value: unknown) => asserts value is number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a function that returns void | undefined', () => {\n      type Result = RuleResult<(value: string) => undefined | void>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a parameterized function', () => {\n      type Result = RuleResult<[(value: number, min: number, max: number) => asserts value is number, number, number]>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a regular expression', () => {\n      type Result = RuleResult<RegExp>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a replacement regular expression', () => {\n      type Result = RuleResult<[RegExp, string]>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw a TypeError if the rule is not a function, RegExp or array', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule(1)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array')\n    })\n\n    it('should throw a TypeError if the rule is an array with less than two elements', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([/World/])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must have at least two elements')\n    })\n\n    it('should throw a TypeError if the second parameter is a function', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw a TypeError if the replacement is not a string', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n\n    it('should throw a TypeError if the rule is an array with a function as the first element', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule(['foo', 'bar'])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Invalid rule, must be a function, RegExp or array')\n    })\n  })\n}\n"],"names":["assertStringMatching","assertString"],"mappings":";;;;;;AA0FO,SAAS,WAAW,MAA0B;AAGnD,MAAI,gBAAgB;AAClB,WAAO,CAAC,WACNA,OAAqB,qBAAA,OAAO,IAAI,GACzB;AAMX,MAAI,OAAO,QAAS;AAClB,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,KAAK,KAAK,MAAM,KAAK;AAC7B,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAKtC,MAAA,CAAC,MAAM,QAAQ,IAAI;AACrB,UAAM,IAAI,UAAU,iDAAiD,OAAO,IAAI,EAAE;AACpF,MAAI,KAAK,SAAS;AACV,UAAA,IAAI,UAAU,oDAAoD;AAGtE,MAAA,KAAK,CAAC,aAAa,QAAQ;AACvB,UAAA,CAAC,KAAK,WAAW,IAAI;AAC3B,QAAI,OAAO,eAAgB;AACnB,YAAA,IAAI,UAAU,wDAAwD;AACvE,WAAA,CAAC,WACNC,OAAa,aAAA,KAAK,GACX,MAAM,QAAQ,KAAK,WAAW;AAAA,EAEzC;AAGA,MAAI,OAAO,KAAK,CAAC,KAAM,YAAY;AACjC,UAAM,CAAC,SAAS,GAAG,UAAU,IAAI;AAC7B,QAAA,OAAO,WAAW,CAAC,KAAM;AACrB,YAAA,IAAI,UAAU,+DAA+D;AACrF,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,QAAQ,KAAK,MAAM,OAAO,GAAG,UAAU;AAC/C,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAAA,EAE1C;AAGM,QAAA,IAAI,UAAU,mDAAmD;AACzE;;"}
\ No newline at end of file
diff --git a/dist/createRule.js b/dist/createRule.js
index 6d22cef2217c8353a77a0d3fbe449e371a3c1938..c1a8b07e8c133cab649654fa39a6ca91ada1134d 100644
--- a/dist/createRule.js
+++ b/dist/createRule.js
@@ -1,6 +1,7 @@
 import { assertStringMatching, assertString } from "./assert.js";
 import "./ValidationError.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 function createRule(rule) {
   if (rule instanceof RegExp)
diff --git a/dist/createRule.js.map b/dist/createRule.js.map
index ed48958c30355c43dd7e5d519a5e70a05b14ed60..fb7c672f2fcec0ce7f58dffc29e263292ba8c306 100644
--- a/dist/createRule.js.map
+++ b/dist/createRule.js.map
@@ -1 +1 @@
-{"version":3,"file":"createRule.js","sources":["../createRule.ts"],"sourcesContent":["import type { Function, IsUnknown, NotFunction } from '@unshared/types'\nimport { assertString, assertStringMatching } from './assert'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A rule-like value can be a regular expression or a function that validates and/or transforms a value.\n * It can also be an array that contains a regular expression and a replacement string, or a function\n * and its right-most parameters.\n *\n * @template U The value returned by the rule function.\n * @example RuleLike<number> = RegExp | Function<number> | [RegExp, string] | [Function<number>, ...NotFunction[]]\n */\nexport type RuleLike<U = unknown> =\n  | [handler: Function<U>, ...NotFunction[]]\n  | [handler: RegExp, replacement: string]\n  | Function<U>\n  | RegExp\n\n/**\n * Infer the result of a rule given a `RuleLike` function.\n *\n * @template T The type of the rule-like function.\n * @example RuleFunctionResult<(value: string) => asserts value is string> = string\n */\ntype RuleFunctionResult<T extends Function> =\n  T extends (value: any, ...rest: any[]) => asserts value is infer U\n    ? IsUnknown<U> extends false ? U\n\n      // --- If the function returns void or undefined, return the value.\n      : T extends (value: infer V, ...rest: any[]) => infer U\n        ? (undefined | void) extends U ? V : U\n        : never\n    : never\n\n/**\n * Infer the result of a rule given a `RuleLike` value.\n *\n * @template T The type of the rule-like value.\n * @example RuleResult<RegExp> = string\n */\nexport type RuleResult<T extends RuleLike> =\n  RuleLike extends T ? unknown\n\n  // --- If the rule is a RegExp matcher or replacer.\n    : T extends RegExp ? string\n      : T extends [RegExp, string] ? string\n\n      // --- If the rule is an assertion function.\n        : T extends Function ? RuleFunctionResult<T>\n          : T extends [infer F extends Function, ...NotFunction[]] ? RuleFunctionResult<F>\n            : never\n\n/**\n * Infer the function type from a `RuleLike` value.\n *\n * @template T The type of the `RuleLike` value.\n * @example Rule<RegExp> = (value: string) => asserts value is string\n */\nexport type Rule<T extends RuleLike = RuleLike> =\n  T extends (...args: infer P) => any\n    ? (...args: P) => RuleResult<T>\n\n  // --- If the rule is a parameterized function.\n    : T extends [(value: infer V, ...rest: any[]) => any, ...any[]]\n      ? (value: V) => RuleResult<T>\n      : (value: unknown) => RuleResult<T>\n\n/**\n * Convert a {@linkcode RuleLike} value into a rule function. This function can be used to create a rule\n * function from a regular expression, a function, or an array that contains a regular expression\n * and a replacement string, or a function with it's n+1 parameters bound to the function.\n *\n * @param rule The rule-like value to convert into a rule function.\n * @returns A function that validates and/or transforms a value.\n * @example\n * // Validates a string against a regular expression.\n * const isEmail = createRule(/^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/i) // (value: unknown) => string\n *\n * // Validates using a function that throws a `ValidationError` if the value is invalid.\n * const isString = createRule((value) => {\n *   if (typeof value !== 'string') throw new ValidationError('E_TYPE_NOT_STRING')\n * })\n *\n * // Remove the 'http://' prefix from a string.\n * const removeHttp = createRule([/^http:\\/\\//, '']) // (value: string) => string\n *\n * // Transforms a string to a number.\n * const toUpperCase = createRule(Number)\n */\nexport function createRule<T extends RuleLike>(rule: T): Rule<T>\nexport function createRule(rule: RuleLike): Function {\n\n  // --- Short-circuit to the `isStringMatching` function if the rule is a regular expression.\n  if (rule instanceof RegExp) {\n    return (value: unknown) => {\n      assertStringMatching(value, rule)\n      return value\n    }\n  }\n\n  // --- If the rule is a function, wrap it in a function that calls the rule\n  // --- and returns the value if the the result is undefined.\n  if (typeof rule === 'function') {\n    return function(this: unknown, value: unknown) {\n      const result = rule.call(this, value)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- At this point, the rule must be an array of at least two elements.\n  if (!Array.isArray(rule))\n    throw new TypeError(`Rule must be a function, RegExp or array, got ${typeof rule}`)\n  if (rule.length < 2)\n    throw new TypeError('Paremeterized rule must have at least two elements')\n\n  // --- Create a function that replaces the value with a string.\n  if (rule[0] instanceof RegExp) {\n    const [exp, replacement] = rule\n    if (typeof replacement !== 'string')\n      throw new TypeError('Remplacement rule must have a string as second element')\n    return (value) => {\n      assertString(value)\n      return value.replace(exp, replacement)\n    }\n  }\n\n  // --- Create a function with the parameters bound to the rule function.\n  if (typeof rule[0] === 'function') {\n    const [handler, ...parameters] = rule as [Function<unknown>, ...NotFunction[]]\n    if (typeof parameters[0] === 'function')\n      throw new TypeError('Paremeterized rule must not have a function as second element')\n    return function(this: unknown, value: unknown) {\n      const result = handler.call(this, value, ...parameters)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- Invalid rule.\n  throw new TypeError('Invalid rule, must be a function, RegExp or array')\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: assertString, assertNumberBetween } = await import('./assert')\n\n  describe('rule from function', () => {\n    it('should return the value if it is a string', () => {\n      const rule = createRule(assertString)\n      const result = rule('test')\n      expect(result).toBe('test')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw an error if the value is not a string', () => {\n      const rule = createRule(assertString)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n\n    it('should transform the value to uppercase', () => {\n      const fn = (value: string) => value.toUpperCase()\n      const rule = createRule(fn)\n      const result = rule('test')\n      expect(result).toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => string>()\n    })\n\n    it('should create a rule from an async function and return it as-is', async() => {\n      const fn = (value: string) => Promise.resolve(value.toUpperCase())\n      const rule = createRule(fn)\n      const result = rule('test')\n      await expect(result).resolves.toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => Promise<string>>()\n    })\n\n    it('should create a rule from a Number constructor and return a number', () => {\n      const rule = createRule(Number)\n      const result = rule('1')\n      expect(result).toBe(1)\n      expectTypeOf(rule).toEqualTypeOf<(value?: any) => number>()\n    })\n\n    it('should create a rule from a Boolean constructor and return a boolean', () => {\n      const rule = createRule(Boolean)\n      const result = rule(0)\n      expect(result).toBe(false)\n      expectTypeOf(rule).toEqualTypeOf<(value?: unknown) => boolean>()\n    })\n\n    it('should preserve the function context', () => {\n      const context = { value: 'test' }\n      const fn = function(this: typeof context) { return this.value }\n      const rule = createRule(fn)\n      const result = rule.call(context)\n      expect(result).toBe('test')\n    })\n  })\n\n  describe('rule from parameterized function', () => {\n    it('should create a rule with parameters pre-bound to the function', () => {\n      const rule = createRule([assertNumberBetween, 2, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should return undefined if the value is in range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n    })\n\n    it('should throw a ValidationError if the value is out of range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const shouldThrow = () => rule(0)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a number between 1 and 3 but received: 0')\n    })\n  })\n\n  describe('assertion rule from RegExp', () => {\n    it('should return the value if it matches the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const result = rule('a')\n      expect(result).toBe('a')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw a ValidationError if the value does not match the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule('1')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: 1')\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('transform rule from RegExp', () => {\n    it('should replace the value with the replacement string if it matches the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello World')\n      expect(result).toBe('Hello Earth')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should not replace the value if it does not match the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello')\n      expect(result).toBe('Hello')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('type inference', () => {\n    it('should infer the return type of a rule from a transform function', () => {\n      type Result = RuleResult<(value: string) => number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from an assertion function', () => {\n      type Result = RuleResult<(value: unknown) => asserts value is number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a function that returns void | undefined', () => {\n      type Result = RuleResult<(value: string) => undefined | void>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a parameterized function', () => {\n      type Result = RuleResult<[(value: number, min: number, max: number) => asserts value is number, number, number]>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a regular expression', () => {\n      type Result = RuleResult<RegExp>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a replacement regular expression', () => {\n      type Result = RuleResult<[RegExp, string]>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw a TypeError if the rule is not a function, RegExp or array', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule(1)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array')\n    })\n\n    it('should throw a TypeError if the rule is an array with less than two elements', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([/World/])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must have at least two elements')\n    })\n\n    it('should throw a TypeError if the second parameter is a function', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw a TypeError if the replacement is not a string', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n\n    it('should throw a TypeError if the rule is an array with a function as the first element', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule(['foo', 'bar'])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Invalid rule, must be a function, RegExp or array')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;AA0FO,SAAS,WAAW,MAA0B;AAGnD,MAAI,gBAAgB;AAClB,WAAO,CAAC,WACN,qBAAqB,OAAO,IAAI,GACzB;AAMX,MAAI,OAAO,QAAS;AAClB,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,KAAK,KAAK,MAAM,KAAK;AAC7B,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAKtC,MAAA,CAAC,MAAM,QAAQ,IAAI;AACrB,UAAM,IAAI,UAAU,iDAAiD,OAAO,IAAI,EAAE;AACpF,MAAI,KAAK,SAAS;AACV,UAAA,IAAI,UAAU,oDAAoD;AAGtE,MAAA,KAAK,CAAC,aAAa,QAAQ;AACvB,UAAA,CAAC,KAAK,WAAW,IAAI;AAC3B,QAAI,OAAO,eAAgB;AACnB,YAAA,IAAI,UAAU,wDAAwD;AACvE,WAAA,CAAC,WACN,aAAa,KAAK,GACX,MAAM,QAAQ,KAAK,WAAW;AAAA,EAEzC;AAGA,MAAI,OAAO,KAAK,CAAC,KAAM,YAAY;AACjC,UAAM,CAAC,SAAS,GAAG,UAAU,IAAI;AAC7B,QAAA,OAAO,WAAW,CAAC,KAAM;AACrB,YAAA,IAAI,UAAU,+DAA+D;AACrF,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,QAAQ,KAAK,MAAM,OAAO,GAAG,UAAU;AAC/C,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAAA,EAE1C;AAGM,QAAA,IAAI,UAAU,mDAAmD;AACzE;"}
\ No newline at end of file
+{"version":3,"file":"createRule.js","sources":["../createRule.ts"],"sourcesContent":["import type { Function, IsUnknown, NotFunction } from '@unshared/types'\nimport { assertString, assertStringMatching } from './assert'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A rule-like value can be a regular expression or a function that validates and/or transforms a value.\n * It can also be an array that contains a regular expression and a replacement string, or a function\n * and its right-most parameters.\n *\n * @template U The value returned by the rule function.\n * @example RuleLike<number> = RegExp | Function<number> | [RegExp, string] | [Function<number>, ...NotFunction[]]\n */\nexport type RuleLike<U = unknown> =\n  | [handler: Function<U>, ...NotFunction[]]\n  | [handler: RegExp, replacement: string]\n  | Function<U>\n  | RegExp\n\n/**\n * Infer the result of a rule given a `RuleLike` function.\n *\n * @template T The type of the rule-like function.\n * @example RuleFunctionResult<(value: string) => asserts value is string> = string\n */\ntype RuleFunctionResult<T extends Function> =\n  T extends (value: any, ...rest: any[]) => asserts value is infer U\n    ? IsUnknown<U> extends false ? U\n\n      // --- If the function returns void or undefined, return the value.\n      : T extends (value: infer V, ...rest: any[]) => infer U\n        ? (undefined | void) extends U ? V : U\n        : never\n    : never\n\n/**\n * Infer the result of a rule given a `RuleLike` value.\n *\n * @template T The type of the rule-like value.\n * @example RuleResult<RegExp> = string\n */\nexport type RuleResult<T extends RuleLike> =\n  RuleLike extends T ? unknown\n\n  // --- If the rule is a RegExp matcher or replacer.\n    : T extends RegExp ? string\n      : T extends [RegExp, string] ? string\n\n      // --- If the rule is an assertion function.\n        : T extends Function ? RuleFunctionResult<T>\n          : T extends [infer F extends Function, ...NotFunction[]] ? RuleFunctionResult<F>\n            : never\n\n/**\n * Infer the function type from a `RuleLike` value.\n *\n * @template T The type of the `RuleLike` value.\n * @example Rule<RegExp> = (value: string) => asserts value is string\n */\nexport type Rule<T extends RuleLike = RuleLike> =\n  T extends (...args: infer P) => any\n    ? (...args: P) => RuleResult<T>\n\n  // --- If the rule is a parameterized function.\n    : T extends [(value: infer V, ...rest: any[]) => any, ...any[]]\n      ? (value: V) => RuleResult<T>\n      : (value: unknown) => RuleResult<T>\n\n/**\n * Convert a {@linkcode RuleLike} value into a rule function. This function can be used to create a rule\n * function from a regular expression, a function, or an array that contains a regular expression\n * and a replacement string, or a function with it's n+1 parameters bound to the function.\n *\n * @param rule The rule-like value to convert into a rule function.\n * @returns A function that validates and/or transforms a value.\n * @example\n * // Validates a string against a regular expression.\n * const isEmail = createRule(/^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/i) // (value: unknown) => string\n *\n * // Validates using a function that throws a `ValidationError` if the value is invalid.\n * const isString = createRule((value) => {\n *   if (typeof value !== 'string') throw new ValidationError('E_TYPE_NOT_STRING')\n * })\n *\n * // Remove the 'http://' prefix from a string.\n * const removeHttp = createRule([/^http:\\/\\//, '']) // (value: string) => string\n *\n * // Transforms a string to a number.\n * const toUpperCase = createRule(Number)\n */\nexport function createRule<T extends RuleLike>(rule: T): Rule<T>\nexport function createRule(rule: RuleLike): Function {\n\n  // --- Short-circuit to the `isStringMatching` function if the rule is a regular expression.\n  if (rule instanceof RegExp) {\n    return (value: unknown) => {\n      assertStringMatching(value, rule)\n      return value\n    }\n  }\n\n  // --- If the rule is a function, wrap it in a function that calls the rule\n  // --- and returns the value if the the result is undefined.\n  if (typeof rule === 'function') {\n    return function(this: unknown, value: unknown) {\n      const result = rule.call(this, value)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- At this point, the rule must be an array of at least two elements.\n  if (!Array.isArray(rule))\n    throw new TypeError(`Rule must be a function, RegExp or array, got ${typeof rule}`)\n  if (rule.length < 2)\n    throw new TypeError('Paremeterized rule must have at least two elements')\n\n  // --- Create a function that replaces the value with a string.\n  if (rule[0] instanceof RegExp) {\n    const [exp, replacement] = rule\n    if (typeof replacement !== 'string')\n      throw new TypeError('Remplacement rule must have a string as second element')\n    return (value) => {\n      assertString(value)\n      return value.replace(exp, replacement)\n    }\n  }\n\n  // --- Create a function with the parameters bound to the rule function.\n  if (typeof rule[0] === 'function') {\n    const [handler, ...parameters] = rule as [Function<unknown>, ...NotFunction[]]\n    if (typeof parameters[0] === 'function')\n      throw new TypeError('Paremeterized rule must not have a function as second element')\n    return function(this: unknown, value: unknown) {\n      const result = handler.call(this, value, ...parameters)\n      return result === undefined ? value : result\n    }\n  }\n\n  // --- Invalid rule.\n  throw new TypeError('Invalid rule, must be a function, RegExp or array')\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: assertString, assertNumberBetween } = await import('./assert')\n\n  describe('rule from function', () => {\n    it('should return the value if it is a string', () => {\n      const rule = createRule(assertString)\n      const result = rule('test')\n      expect(result).toBe('test')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw an error if the value is not a string', () => {\n      const rule = createRule(assertString)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n\n    it('should transform the value to uppercase', () => {\n      const fn = (value: string) => value.toUpperCase()\n      const rule = createRule(fn)\n      const result = rule('test')\n      expect(result).toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => string>()\n    })\n\n    it('should create a rule from an async function and return it as-is', async() => {\n      const fn = (value: string) => Promise.resolve(value.toUpperCase())\n      const rule = createRule(fn)\n      const result = rule('test')\n      await expect(result).resolves.toBe('TEST')\n      expectTypeOf(rule).toEqualTypeOf<(value: string) => Promise<string>>()\n    })\n\n    it('should create a rule from a Number constructor and return a number', () => {\n      const rule = createRule(Number)\n      const result = rule('1')\n      expect(result).toBe(1)\n      expectTypeOf(rule).toEqualTypeOf<(value?: any) => number>()\n    })\n\n    it('should create a rule from a Boolean constructor and return a boolean', () => {\n      const rule = createRule(Boolean)\n      const result = rule(0)\n      expect(result).toBe(false)\n      expectTypeOf(rule).toEqualTypeOf<(value?: unknown) => boolean>()\n    })\n\n    it('should preserve the function context', () => {\n      const context = { value: 'test' }\n      const fn = function(this: typeof context) { return this.value }\n      const rule = createRule(fn)\n      const result = rule.call(context)\n      expect(result).toBe('test')\n    })\n  })\n\n  describe('rule from parameterized function', () => {\n    it('should create a rule with parameters pre-bound to the function', () => {\n      const rule = createRule([assertNumberBetween, 2, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should return undefined if the value is in range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const result = rule(2)\n      expect(result).toBe(2)\n    })\n\n    it('should throw a ValidationError if the value is out of range', () => {\n      const rule = createRule([assertNumberBetween, 1, 3])\n      const shouldThrow = () => rule(0)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a number between 1 and 3 but received: 0')\n    })\n  })\n\n  describe('assertion rule from RegExp', () => {\n    it('should return the value if it matches the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const result = rule('a')\n      expect(result).toBe('a')\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string>()\n    })\n\n    it('should throw a ValidationError if the value does not match the regular expression', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule('1')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: 1')\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule(/[a-z]/)\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('transform rule from RegExp', () => {\n    it('should replace the value with the replacement string if it matches the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello World')\n      expect(result).toBe('Hello Earth')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should not replace the value if it does not match the regular expression', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const result = rule('Hello')\n      expect(result).toBe('Hello')\n      expectTypeOf(result).toEqualTypeOf<string>()\n    })\n\n    it('should throw a ValidationError if the value is not a string', () => {\n      const rule = createRule([/World/, 'Earth'])\n      const shouldThrow = () => rule(1)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string but received: number')\n    })\n  })\n\n  describe('type inference', () => {\n    it('should infer the return type of a rule from a transform function', () => {\n      type Result = RuleResult<(value: string) => number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from an assertion function', () => {\n      type Result = RuleResult<(value: unknown) => asserts value is number>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a function that returns void | undefined', () => {\n      type Result = RuleResult<(value: string) => undefined | void>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a parameterized function', () => {\n      type Result = RuleResult<[(value: number, min: number, max: number) => asserts value is number, number, number]>\n      expectTypeOf<Result>().toEqualTypeOf<number>()\n    })\n\n    it('should infer the return type of a rule from a regular expression', () => {\n      type Result = RuleResult<RegExp>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n\n    it('should infer the return type of a rule from a replacement regular expression', () => {\n      type Result = RuleResult<[RegExp, string]>\n      expectTypeOf<Result>().toEqualTypeOf<string>()\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw a TypeError if the rule is not a function, RegExp or array', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule(1)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array')\n    })\n\n    it('should throw a TypeError if the rule is an array with less than two elements', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([/World/])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must have at least two elements')\n    })\n\n    it('should throw a TypeError if the second parameter is a function', () => {\n      // @ts-expect-error: This is an edge case\n      const shouldThrow = () => createRule([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw a TypeError if the replacement is not a string', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n\n    it('should throw a TypeError if the rule is an array with a function as the first element', () => {\n      // @ts-expect-error: This is a test case\n      const shouldThrow = () => createRule(['foo', 'bar'])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Invalid rule, must be a function, RegExp or array')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;;AA0FO,SAAS,WAAW,MAA0B;AAGnD,MAAI,gBAAgB;AAClB,WAAO,CAAC,WACN,qBAAqB,OAAO,IAAI,GACzB;AAMX,MAAI,OAAO,QAAS;AAClB,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,KAAK,KAAK,MAAM,KAAK;AAC7B,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAKtC,MAAA,CAAC,MAAM,QAAQ,IAAI;AACrB,UAAM,IAAI,UAAU,iDAAiD,OAAO,IAAI,EAAE;AACpF,MAAI,KAAK,SAAS;AACV,UAAA,IAAI,UAAU,oDAAoD;AAGtE,MAAA,KAAK,CAAC,aAAa,QAAQ;AACvB,UAAA,CAAC,KAAK,WAAW,IAAI;AAC3B,QAAI,OAAO,eAAgB;AACnB,YAAA,IAAI,UAAU,wDAAwD;AACvE,WAAA,CAAC,WACN,aAAa,KAAK,GACX,MAAM,QAAQ,KAAK,WAAW;AAAA,EAEzC;AAGA,MAAI,OAAO,KAAK,CAAC,KAAM,YAAY;AACjC,UAAM,CAAC,SAAS,GAAG,UAAU,IAAI;AAC7B,QAAA,OAAO,WAAW,CAAC,KAAM;AACrB,YAAA,IAAI,UAAU,+DAA+D;AACrF,WAAO,SAAwB,OAAgB;AAC7C,YAAM,SAAS,QAAQ,KAAK,MAAM,OAAO,GAAG,UAAU;AAC/C,aAAA,WAAW,SAAY,QAAQ;AAAA,IAAA;AAAA,EAE1C;AAGM,QAAA,IAAI,UAAU,mDAAmD;AACzE;"}
\ No newline at end of file
diff --git a/dist/createRuleChain.cjs b/dist/createRuleChain.cjs
index b9e2fcafea27e6036ad7f063b926f02085e1abb8..620b9f6a4366396b501e013ab3b935295faec3de 100644
--- a/dist/createRuleChain.cjs
+++ b/dist/createRuleChain.cjs
@@ -3,6 +3,7 @@ var createRule = require("./createRule.cjs");
 require("./ValidationError.cjs");
 require("./assert.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 function createRuleChain(...rules) {
   const compiled = rules.map(createRule.createRule);
diff --git a/dist/createRuleChain.cjs.map b/dist/createRuleChain.cjs.map
index 1c11603fb89a7deaf90cba567e2252d8776ae383..ede4d1656c1b84c101e61b686a989bb1df96c407 100644
--- a/dist/createRuleChain.cjs.map
+++ b/dist/createRuleChain.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createRuleChain.cjs","sources":["../createRuleChain.ts"],"sourcesContent":["import type { RuleLike, RuleResult } from './createRule'\nimport { createRule } from './createRule'\nimport { ValidationError } from './ValidationError'\n\n/** A tuple of `RuleLike` values that can be used to create a rule chain. */\nexport type RuleChainLike = RuleLike[]\n\n/**\n * Infer the result type of a rule chain given a `RuleChainLike` value.\n *\n * @template T The type of the rule chain.\n * @example RuleChainResult<[RegExp, (value: string) => string]> = string\n */\nexport type RuleChainResult<T extends RuleChainLike> =\n  T extends [infer U extends RuleLike] ? RuleResult<U>\n    : T extends [...RuleLike[], infer U extends RuleLike] ? RuleResult<U>\n      : never\n\n/**\n * A tuple of rules that are executed in order until one fails.\n *\n * @template T The type of the rules in the chain.\n * @example RuleChain<[RegExp, (value: string) => string]> = [(value: unknown) => asserts value is string, (value: string) => string]\n */\nexport type RuleChain<T extends RuleChainLike = RuleChainLike> = (value: unknown) => RuleChainResult<T>\n\n/**\n * Create a rule chain from a list of `RuleLike` values. This function can be used to create a\n * chain of rules that are executed in order until one fails.\n *\n * @param rules The `RuleLike` values to create the chain from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleChain<T extends RuleChainLike>(...rules: Readonly<T>): RuleChain<T> {\n  const compiled = rules.map(createRule)\n  return function(this: unknown, value: unknown) {\n    for (const rule of compiled) value = rule.call(this, value)\n    return value\n  } as RuleChain<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: isString } = await import('./assert')\n\n  describe('rule chain', () => {\n    it('should create a rule chain that parses and validates a string', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const result = ruleChain('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(ruleChain).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should throw an error if the value is not matching one of the rules', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const shouldThrow = () => ruleChain('hello')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: hello')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if the parameter is not a rule', () => {\n    // @ts-expect-error: Testing invalid input\n      const shouldThrow = () => createRuleChain(5)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array, got number')\n    })\n\n    it('should throw an error if the rule parameter is a function', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw an error if the replacement is not a string', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n  })\n}\n"],"names":["createRule"],"mappings":";;;;;;AAkCO,SAAS,mBAA4C,OAAkC;AACtF,QAAA,WAAW,MAAM,IAAIA,WAAU,UAAA;AACrC,SAAO,SAAwB,OAAgB;AAC7C,eAAW,QAAQ,SAAU,SAAQ,KAAK,KAAK,MAAM,KAAK;AACnD,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
+{"version":3,"file":"createRuleChain.cjs","sources":["../createRuleChain.ts"],"sourcesContent":["import type { RuleLike, RuleResult } from './createRule'\nimport { createRule } from './createRule'\nimport { ValidationError } from './ValidationError'\n\n/** A tuple of `RuleLike` values that can be used to create a rule chain. */\nexport type RuleChainLike = RuleLike[]\n\n/**\n * Infer the result type of a rule chain given a `RuleChainLike` value.\n *\n * @template T The type of the rule chain.\n * @example RuleChainResult<[RegExp, (value: string) => string]> = string\n */\nexport type RuleChainResult<T extends RuleChainLike> =\n  T extends [infer U extends RuleLike] ? RuleResult<U>\n    : T extends [...RuleLike[], infer U extends RuleLike] ? RuleResult<U>\n      : never\n\n/**\n * A tuple of rules that are executed in order until one fails.\n *\n * @template T The type of the rules in the chain.\n * @example RuleChain<[RegExp, (value: string) => string]> = [(value: unknown) => asserts value is string, (value: string) => string]\n */\nexport type RuleChain<T extends RuleChainLike = RuleChainLike> = (value: unknown) => RuleChainResult<T>\n\n/**\n * Create a rule chain from a list of `RuleLike` values. This function can be used to create a\n * chain of rules that are executed in order until one fails.\n *\n * @param rules The `RuleLike` values to create the chain from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleChain<T extends RuleChainLike>(...rules: Readonly<T>): RuleChain<T> {\n  const compiled = rules.map(createRule)\n  return function(this: unknown, value: unknown) {\n    for (const rule of compiled) value = rule.call(this, value)\n    return value\n  } as RuleChain<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: isString } = await import('./assert')\n\n  describe('rule chain', () => {\n    it('should create a rule chain that parses and validates a string', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const result = ruleChain('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(ruleChain).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should throw an error if the value is not matching one of the rules', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const shouldThrow = () => ruleChain('hello')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: hello')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if the parameter is not a rule', () => {\n    // @ts-expect-error: Testing invalid input\n      const shouldThrow = () => createRuleChain(5)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array, got number')\n    })\n\n    it('should throw an error if the rule parameter is a function', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw an error if the replacement is not a string', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n  })\n}\n"],"names":["createRule"],"mappings":";;;;;;;AAkCO,SAAS,mBAA4C,OAAkC;AACtF,QAAA,WAAW,MAAM,IAAIA,WAAU,UAAA;AACrC,SAAO,SAAwB,OAAgB;AAC7C,eAAW,QAAQ,SAAU,SAAQ,KAAK,KAAK,MAAM,KAAK;AACnD,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
diff --git a/dist/createRuleChain.js b/dist/createRuleChain.js
index 04ce614e5b7f9e885f8f2f3ae7f3ec27f2784333..51c995c4f538b27fb47d3231440fdb8a62e39b49 100644
--- a/dist/createRuleChain.js
+++ b/dist/createRuleChain.js
@@ -2,6 +2,7 @@ import { createRule } from "./createRule.js";
 import "./ValidationError.js";
 import "./assert.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 function createRuleChain(...rules) {
   const compiled = rules.map(createRule);
diff --git a/dist/createRuleChain.js.map b/dist/createRuleChain.js.map
index 431e91040d9e3a270a072e75bf0f491130dcd225..240028bffb51c383c95ece03f96dc99f9d84e202 100644
--- a/dist/createRuleChain.js.map
+++ b/dist/createRuleChain.js.map
@@ -1 +1 @@
-{"version":3,"file":"createRuleChain.js","sources":["../createRuleChain.ts"],"sourcesContent":["import type { RuleLike, RuleResult } from './createRule'\nimport { createRule } from './createRule'\nimport { ValidationError } from './ValidationError'\n\n/** A tuple of `RuleLike` values that can be used to create a rule chain. */\nexport type RuleChainLike = RuleLike[]\n\n/**\n * Infer the result type of a rule chain given a `RuleChainLike` value.\n *\n * @template T The type of the rule chain.\n * @example RuleChainResult<[RegExp, (value: string) => string]> = string\n */\nexport type RuleChainResult<T extends RuleChainLike> =\n  T extends [infer U extends RuleLike] ? RuleResult<U>\n    : T extends [...RuleLike[], infer U extends RuleLike] ? RuleResult<U>\n      : never\n\n/**\n * A tuple of rules that are executed in order until one fails.\n *\n * @template T The type of the rules in the chain.\n * @example RuleChain<[RegExp, (value: string) => string]> = [(value: unknown) => asserts value is string, (value: string) => string]\n */\nexport type RuleChain<T extends RuleChainLike = RuleChainLike> = (value: unknown) => RuleChainResult<T>\n\n/**\n * Create a rule chain from a list of `RuleLike` values. This function can be used to create a\n * chain of rules that are executed in order until one fails.\n *\n * @param rules The `RuleLike` values to create the chain from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleChain<T extends RuleChainLike>(...rules: Readonly<T>): RuleChain<T> {\n  const compiled = rules.map(createRule)\n  return function(this: unknown, value: unknown) {\n    for (const rule of compiled) value = rule.call(this, value)\n    return value\n  } as RuleChain<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: isString } = await import('./assert')\n\n  describe('rule chain', () => {\n    it('should create a rule chain that parses and validates a string', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const result = ruleChain('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(ruleChain).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should throw an error if the value is not matching one of the rules', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const shouldThrow = () => ruleChain('hello')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: hello')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if the parameter is not a rule', () => {\n    // @ts-expect-error: Testing invalid input\n      const shouldThrow = () => createRuleChain(5)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array, got number')\n    })\n\n    it('should throw an error if the rule parameter is a function', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw an error if the replacement is not a string', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;;AAkCO,SAAS,mBAA4C,OAAkC;AACtF,QAAA,WAAW,MAAM,IAAI,UAAU;AACrC,SAAO,SAAwB,OAAgB;AAC7C,eAAW,QAAQ,SAAU,SAAQ,KAAK,KAAK,MAAM,KAAK;AACnD,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
+{"version":3,"file":"createRuleChain.js","sources":["../createRuleChain.ts"],"sourcesContent":["import type { RuleLike, RuleResult } from './createRule'\nimport { createRule } from './createRule'\nimport { ValidationError } from './ValidationError'\n\n/** A tuple of `RuleLike` values that can be used to create a rule chain. */\nexport type RuleChainLike = RuleLike[]\n\n/**\n * Infer the result type of a rule chain given a `RuleChainLike` value.\n *\n * @template T The type of the rule chain.\n * @example RuleChainResult<[RegExp, (value: string) => string]> = string\n */\nexport type RuleChainResult<T extends RuleChainLike> =\n  T extends [infer U extends RuleLike] ? RuleResult<U>\n    : T extends [...RuleLike[], infer U extends RuleLike] ? RuleResult<U>\n      : never\n\n/**\n * A tuple of rules that are executed in order until one fails.\n *\n * @template T The type of the rules in the chain.\n * @example RuleChain<[RegExp, (value: string) => string]> = [(value: unknown) => asserts value is string, (value: string) => string]\n */\nexport type RuleChain<T extends RuleChainLike = RuleChainLike> = (value: unknown) => RuleChainResult<T>\n\n/**\n * Create a rule chain from a list of `RuleLike` values. This function can be used to create a\n * chain of rules that are executed in order until one fails.\n *\n * @param rules The `RuleLike` values to create the chain from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleChain<T extends RuleChainLike>(...rules: Readonly<T>): RuleChain<T> {\n  const compiled = rules.map(createRule)\n  return function(this: unknown, value: unknown) {\n    for (const rule of compiled) value = rule.call(this, value)\n    return value\n  } as RuleChain<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString: isString } = await import('./assert')\n\n  describe('rule chain', () => {\n    it('should create a rule chain that parses and validates a string', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const result = ruleChain('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(ruleChain).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should throw an error if the value is not matching one of the rules', () => {\n      const ruleChain = createRuleChain(isString, /\\d+/, Number)\n      const shouldThrow = () => ruleChain('hello')\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to be a string matching the regular expression but received: hello')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if the parameter is not a rule', () => {\n    // @ts-expect-error: Testing invalid input\n      const shouldThrow = () => createRuleChain(5)\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function, RegExp or array, got number')\n    })\n\n    it('should throw an error if the rule parameter is a function', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([() => {}, () => {}])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Paremeterized rule must not have a function as second element')\n    })\n\n    it('should throw an error if the replacement is not a string', () => {\n      // @ts-expect-error: This is an invalid test case\n      const shouldThrow = () => createRuleChain([/World/, 1])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Remplacement rule must have a string as second element')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;;;AAkCO,SAAS,mBAA4C,OAAkC;AACtF,QAAA,WAAW,MAAM,IAAI,UAAU;AACrC,SAAO,SAAwB,OAAgB;AAC7C,eAAW,QAAQ,SAAU,SAAQ,KAAK,KAAK,MAAM,KAAK;AACnD,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
diff --git a/dist/createRuleSet.cjs b/dist/createRuleSet.cjs
index c66b0aee3e6981612af1bc6f4ad152ef807996fd..46399c1c63449e8d7ac65859e8b519693746b3ea 100644
--- a/dist/createRuleSet.cjs
+++ b/dist/createRuleSet.cjs
@@ -3,6 +3,7 @@ var createRuleChain = require("./createRuleChain.cjs"), ValidationError = requir
 require("./createRule.cjs");
 require("./assert.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 function createRuleSet(...chains) {
   const compiled = chains.map((chain) => createRuleChain.createRuleChain(...chain));
diff --git a/dist/createRuleSet.cjs.map b/dist/createRuleSet.cjs.map
index 714c2f9ef4bace2891e8d1b3dad15212acfe4d85..4b125d2d50ed987fd385b09fd8df3305e18d6122 100644
--- a/dist/createRuleSet.cjs.map
+++ b/dist/createRuleSet.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createRuleSet.cjs","sources":["../createRuleSet.ts"],"sourcesContent":["import type { Immutable } from '@unshared/types'\nimport type { RuleLike } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport { createRuleChain } from './createRuleChain'\nimport { ValidationError } from './ValidationError'\n\n/** A matrix of `RuleLike` values that can be used to create a rule set. */\nexport type RuleSetLike = RuleLike[][]\n\n/**\n * Infer the result type of a rule set given a `RuleSetLike` value.\n *\n * @template T The type of the rule set.\n * @example RuleSetResult<[[RegExp], [NumberConstructor]]> = string | number\n */\nexport type RuleSetResult<T extends RuleSetLike> =\n  T extends Array<infer U extends RuleChainLike> ? RuleChainResult<U> : never\n\n/**\n * A tuple of rule chains that are tested in order until one matches.\n *\n * @template T The type of the rule chains in the set.\n * @example RuleSet<[RegExp, (value: string) => string]> = [(value: unknown) => string, (value: string) => string]\n */\nexport type RuleSet<T extends RuleSetLike = RuleSetLike> =\n  (value: unknown) => RuleSetResult<T>\n\n/**\n * Create a rule set from a list of `RuleChain` values. This function can be used to create a\n * set of rules that can be used to validate a value against at least one rule chain in the set.\n *\n * @param chains The `RuleChain` values to create the set from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleSet<T extends RuleSetLike>(...chains: Immutable<T>): RuleSet<T> {\n  const compiled = chains.map(chain => createRuleChain(...chain))\n  return function(this: object, value: unknown) {\n    const causes: Error[] = []\n\n    // --- For each rule set, validate the value. If one chain passes, return\n    // --- the transformed value. If no chain passes, throw a validation error.\n    for (const set of compiled) {\n      try { return set.call(this, value) }\n      catch (error) { causes.push(error as Error) }\n    }\n\n    // --- If we reach this point, no rule chain passed.\n    throw new ValidationError({\n      name: 'E_NO_MATCHING_RULE_CHAIN',\n      message: 'Expected value to match at least one rule chain in the set.',\n      causes,\n    })\n  } as RuleSet<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertStringNumber, assertUndefined } = await import('./assert')\n\n  describe('rule set from set of functions', () => {\n    it('should create a rule set and transform a value', () => {\n      const rule = createRuleSet([assertStringNumber, Number])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should match the first rule chain', () => {\n      const toString = vi.fn(String) as (value: unknown) => string\n      const toNumber = vi.fn(Number) as (value: unknown) => number\n      const rule = createRuleSet([toNumber], [toString])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expect(toNumber).toHaveBeenCalledWith('5')\n      expect(toString).not.toHaveBeenCalled()\n      expectTypeOf(result).toEqualTypeOf<number | string>()\n    })\n\n    it('should match undefined if the value is not a number', () => {\n      const rule = createRuleSet([assertStringNumber, Number], [assertUndefined])\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const result = rule(undefined)\n      expect(result).toBeUndefined()\n      expectTypeOf(result).toEqualTypeOf<number | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n    })\n\n    it('should match the second rule chain if the first rule chain fails', () => {\n      const throws = vi.fn(assertUndefined) as typeof assertUndefined\n      const toString = vi.fn(String) as (value: unknown) => string\n      const rule = createRuleSet([throws], [toString])\n      const result = rule(5)\n      expect(result).toBe('5')\n      expect(throws).toHaveBeenCalledWith(5)\n      expect(toString).toHaveBeenCalledWith(5)\n      expectTypeOf(result).toEqualTypeOf<string | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string | undefined>()\n    })\n\n    it('should throw an error if no rule chain passes', () => {\n      const throws = vi.fn(assertUndefined)\n      const rule = createRuleSet([throws], [throws])\n      const shouldThrow = () => rule(5)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if a rule is not a function', () => {\n      // @ts-expect-error: testing invalid input\n      const shouldThrow = () => createRuleSet([5])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function')\n    })\n  })\n}\n"],"names":["createRuleChain","ValidationError"],"mappings":";;;;;;AAmCO,SAAS,iBAAwC,QAAkC;AACxF,QAAM,WAAW,OAAO,IAAI,WAASA,gCAAgB,GAAG,KAAK,CAAC;AAC9D,SAAO,SAAuB,OAAgB;AAC5C,UAAM,SAAkB,CAAA;AAIxB,eAAW,OAAO;AACZ,UAAA;AAAS,eAAA,IAAI,KAAK,MAAM,KAAK;AAAA,eAC1B,OAAO;AAAE,eAAO,KAAK,KAAc;AAAA,MAAE;AAI9C,UAAM,IAAIC,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,MACT;AAAA,IAAA,CACD;AAAA,EAAA;AAEL;;"}
\ No newline at end of file
+{"version":3,"file":"createRuleSet.cjs","sources":["../createRuleSet.ts"],"sourcesContent":["import type { Immutable } from '@unshared/types'\nimport type { RuleLike } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport { createRuleChain } from './createRuleChain'\nimport { ValidationError } from './ValidationError'\n\n/** A matrix of `RuleLike` values that can be used to create a rule set. */\nexport type RuleSetLike = RuleLike[][]\n\n/**\n * Infer the result type of a rule set given a `RuleSetLike` value.\n *\n * @template T The type of the rule set.\n * @example RuleSetResult<[[RegExp], [NumberConstructor]]> = string | number\n */\nexport type RuleSetResult<T extends RuleSetLike> =\n  T extends Array<infer U extends RuleChainLike> ? RuleChainResult<U> : never\n\n/**\n * A tuple of rule chains that are tested in order until one matches.\n *\n * @template T The type of the rule chains in the set.\n * @example RuleSet<[RegExp, (value: string) => string]> = [(value: unknown) => string, (value: string) => string]\n */\nexport type RuleSet<T extends RuleSetLike = RuleSetLike> =\n  (value: unknown) => RuleSetResult<T>\n\n/**\n * Create a rule set from a list of `RuleChain` values. This function can be used to create a\n * set of rules that can be used to validate a value against at least one rule chain in the set.\n *\n * @param chains The `RuleChain` values to create the set from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleSet<T extends RuleSetLike>(...chains: Immutable<T>): RuleSet<T> {\n  const compiled = chains.map(chain => createRuleChain(...chain))\n  return function(this: object, value: unknown) {\n    const causes: Error[] = []\n\n    // --- For each rule set, validate the value. If one chain passes, return\n    // --- the transformed value. If no chain passes, throw a validation error.\n    for (const set of compiled) {\n      try { return set.call(this, value) }\n      catch (error) { causes.push(error as Error) }\n    }\n\n    // --- If we reach this point, no rule chain passed.\n    throw new ValidationError({\n      name: 'E_NO_MATCHING_RULE_CHAIN',\n      message: 'Expected value to match at least one rule chain in the set.',\n      causes,\n    })\n  } as RuleSet<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertStringNumber, assertUndefined } = await import('./assert')\n\n  describe('rule set from set of functions', () => {\n    it('should create a rule set and transform a value', () => {\n      const rule = createRuleSet([assertStringNumber, Number])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should match the first rule chain', () => {\n      const toString = vi.fn(String) as (value: unknown) => string\n      const toNumber = vi.fn(Number) as (value: unknown) => number\n      const rule = createRuleSet([toNumber], [toString])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expect(toNumber).toHaveBeenCalledWith('5')\n      expect(toString).not.toHaveBeenCalled()\n      expectTypeOf(result).toEqualTypeOf<number | string>()\n    })\n\n    it('should match undefined if the value is not a number', () => {\n      const rule = createRuleSet([assertStringNumber, Number], [assertUndefined])\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const result = rule(undefined)\n      expect(result).toBeUndefined()\n      expectTypeOf(result).toEqualTypeOf<number | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n    })\n\n    it('should match the second rule chain if the first rule chain fails', () => {\n      const throws = vi.fn(assertUndefined) as typeof assertUndefined\n      const toString = vi.fn(String) as (value: unknown) => string\n      const rule = createRuleSet([throws], [toString])\n      const result = rule(5)\n      expect(result).toBe('5')\n      expect(throws).toHaveBeenCalledWith(5)\n      expect(toString).toHaveBeenCalledWith(5)\n      expectTypeOf(result).toEqualTypeOf<string | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string | undefined>()\n    })\n\n    it('should throw an error if no rule chain passes', () => {\n      const throws = vi.fn(assertUndefined)\n      const rule = createRuleSet([throws], [throws])\n      const shouldThrow = () => rule(5)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if a rule is not a function', () => {\n      // @ts-expect-error: testing invalid input\n      const shouldThrow = () => createRuleSet([5])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function')\n    })\n  })\n}\n"],"names":["createRuleChain","ValidationError"],"mappings":";;;;;;;AAmCO,SAAS,iBAAwC,QAAkC;AACxF,QAAM,WAAW,OAAO,IAAI,WAASA,gCAAgB,GAAG,KAAK,CAAC;AAC9D,SAAO,SAAuB,OAAgB;AAC5C,UAAM,SAAkB,CAAA;AAIxB,eAAW,OAAO;AACZ,UAAA;AAAS,eAAA,IAAI,KAAK,MAAM,KAAK;AAAA,eAC1B,OAAO;AAAE,eAAO,KAAK,KAAc;AAAA,MAAE;AAI9C,UAAM,IAAIC,gBAAAA,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,MACT;AAAA,IAAA,CACD;AAAA,EAAA;AAEL;;"}
\ No newline at end of file
diff --git a/dist/createRuleSet.js b/dist/createRuleSet.js
index 35ad6b97935a01fd91af2126afe4a2c5bd3461bb..a053a930e9936133404a31cce3b73cbaced1290b 100644
--- a/dist/createRuleSet.js
+++ b/dist/createRuleSet.js
@@ -3,6 +3,7 @@ import { ValidationError } from "./ValidationError.js";
 import "./createRule.js";
 import "./assert.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 function createRuleSet(...chains) {
   const compiled = chains.map((chain) => createRuleChain(...chain));
diff --git a/dist/createRuleSet.js.map b/dist/createRuleSet.js.map
index 13a518bf4b83101169e88b98ad9dbeba29b391dd..e818dd416ee8db7279f9083f123534573dd06117 100644
--- a/dist/createRuleSet.js.map
+++ b/dist/createRuleSet.js.map
@@ -1 +1 @@
-{"version":3,"file":"createRuleSet.js","sources":["../createRuleSet.ts"],"sourcesContent":["import type { Immutable } from '@unshared/types'\nimport type { RuleLike } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport { createRuleChain } from './createRuleChain'\nimport { ValidationError } from './ValidationError'\n\n/** A matrix of `RuleLike` values that can be used to create a rule set. */\nexport type RuleSetLike = RuleLike[][]\n\n/**\n * Infer the result type of a rule set given a `RuleSetLike` value.\n *\n * @template T The type of the rule set.\n * @example RuleSetResult<[[RegExp], [NumberConstructor]]> = string | number\n */\nexport type RuleSetResult<T extends RuleSetLike> =\n  T extends Array<infer U extends RuleChainLike> ? RuleChainResult<U> : never\n\n/**\n * A tuple of rule chains that are tested in order until one matches.\n *\n * @template T The type of the rule chains in the set.\n * @example RuleSet<[RegExp, (value: string) => string]> = [(value: unknown) => string, (value: string) => string]\n */\nexport type RuleSet<T extends RuleSetLike = RuleSetLike> =\n  (value: unknown) => RuleSetResult<T>\n\n/**\n * Create a rule set from a list of `RuleChain` values. This function can be used to create a\n * set of rules that can be used to validate a value against at least one rule chain in the set.\n *\n * @param chains The `RuleChain` values to create the set from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleSet<T extends RuleSetLike>(...chains: Immutable<T>): RuleSet<T> {\n  const compiled = chains.map(chain => createRuleChain(...chain))\n  return function(this: object, value: unknown) {\n    const causes: Error[] = []\n\n    // --- For each rule set, validate the value. If one chain passes, return\n    // --- the transformed value. If no chain passes, throw a validation error.\n    for (const set of compiled) {\n      try { return set.call(this, value) }\n      catch (error) { causes.push(error as Error) }\n    }\n\n    // --- If we reach this point, no rule chain passed.\n    throw new ValidationError({\n      name: 'E_NO_MATCHING_RULE_CHAIN',\n      message: 'Expected value to match at least one rule chain in the set.',\n      causes,\n    })\n  } as RuleSet<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertStringNumber, assertUndefined } = await import('./assert')\n\n  describe('rule set from set of functions', () => {\n    it('should create a rule set and transform a value', () => {\n      const rule = createRuleSet([assertStringNumber, Number])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should match the first rule chain', () => {\n      const toString = vi.fn(String) as (value: unknown) => string\n      const toNumber = vi.fn(Number) as (value: unknown) => number\n      const rule = createRuleSet([toNumber], [toString])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expect(toNumber).toHaveBeenCalledWith('5')\n      expect(toString).not.toHaveBeenCalled()\n      expectTypeOf(result).toEqualTypeOf<number | string>()\n    })\n\n    it('should match undefined if the value is not a number', () => {\n      const rule = createRuleSet([assertStringNumber, Number], [assertUndefined])\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const result = rule(undefined)\n      expect(result).toBeUndefined()\n      expectTypeOf(result).toEqualTypeOf<number | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n    })\n\n    it('should match the second rule chain if the first rule chain fails', () => {\n      const throws = vi.fn(assertUndefined) as typeof assertUndefined\n      const toString = vi.fn(String) as (value: unknown) => string\n      const rule = createRuleSet([throws], [toString])\n      const result = rule(5)\n      expect(result).toBe('5')\n      expect(throws).toHaveBeenCalledWith(5)\n      expect(toString).toHaveBeenCalledWith(5)\n      expectTypeOf(result).toEqualTypeOf<string | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string | undefined>()\n    })\n\n    it('should throw an error if no rule chain passes', () => {\n      const throws = vi.fn(assertUndefined)\n      const rule = createRuleSet([throws], [throws])\n      const shouldThrow = () => rule(5)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if a rule is not a function', () => {\n      // @ts-expect-error: testing invalid input\n      const shouldThrow = () => createRuleSet([5])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;;;AAmCO,SAAS,iBAAwC,QAAkC;AACxF,QAAM,WAAW,OAAO,IAAI,WAAS,gBAAgB,GAAG,KAAK,CAAC;AAC9D,SAAO,SAAuB,OAAgB;AAC5C,UAAM,SAAkB,CAAA;AAIxB,eAAW,OAAO;AACZ,UAAA;AAAS,eAAA,IAAI,KAAK,MAAM,KAAK;AAAA,eAC1B,OAAO;AAAE,eAAO,KAAK,KAAc;AAAA,MAAE;AAI9C,UAAM,IAAI,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,MACT;AAAA,IAAA,CACD;AAAA,EAAA;AAEL;"}
\ No newline at end of file
+{"version":3,"file":"createRuleSet.js","sources":["../createRuleSet.ts"],"sourcesContent":["import type { Immutable } from '@unshared/types'\nimport type { RuleLike } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport { createRuleChain } from './createRuleChain'\nimport { ValidationError } from './ValidationError'\n\n/** A matrix of `RuleLike` values that can be used to create a rule set. */\nexport type RuleSetLike = RuleLike[][]\n\n/**\n * Infer the result type of a rule set given a `RuleSetLike` value.\n *\n * @template T The type of the rule set.\n * @example RuleSetResult<[[RegExp], [NumberConstructor]]> = string | number\n */\nexport type RuleSetResult<T extends RuleSetLike> =\n  T extends Array<infer U extends RuleChainLike> ? RuleChainResult<U> : never\n\n/**\n * A tuple of rule chains that are tested in order until one matches.\n *\n * @template T The type of the rule chains in the set.\n * @example RuleSet<[RegExp, (value: string) => string]> = [(value: unknown) => string, (value: string) => string]\n */\nexport type RuleSet<T extends RuleSetLike = RuleSetLike> =\n  (value: unknown) => RuleSetResult<T>\n\n/**\n * Create a rule set from a list of `RuleChain` values. This function can be used to create a\n * set of rules that can be used to validate a value against at least one rule chain in the set.\n *\n * @param chains The `RuleChain` values to create the set from.\n * @returns A rule chain that can be used to validate a value.\n * @example createRuleChain(isString, /\\w+@example\\.com/) // (value: unknown) => string\n */\nexport function createRuleSet<T extends RuleSetLike>(...chains: Immutable<T>): RuleSet<T> {\n  const compiled = chains.map(chain => createRuleChain(...chain))\n  return function(this: object, value: unknown) {\n    const causes: Error[] = []\n\n    // --- For each rule set, validate the value. If one chain passes, return\n    // --- the transformed value. If no chain passes, throw a validation error.\n    for (const set of compiled) {\n      try { return set.call(this, value) }\n      catch (error) { causes.push(error as Error) }\n    }\n\n    // --- If we reach this point, no rule chain passed.\n    throw new ValidationError({\n      name: 'E_NO_MATCHING_RULE_CHAIN',\n      message: 'Expected value to match at least one rule chain in the set.',\n      causes,\n    })\n  } as RuleSet<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertStringNumber, assertUndefined } = await import('./assert')\n\n  describe('rule set from set of functions', () => {\n    it('should create a rule set and transform a value', () => {\n      const rule = createRuleSet([assertStringNumber, Number])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expectTypeOf(result).toEqualTypeOf<number>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number>()\n    })\n\n    it('should match the first rule chain', () => {\n      const toString = vi.fn(String) as (value: unknown) => string\n      const toNumber = vi.fn(Number) as (value: unknown) => number\n      const rule = createRuleSet([toNumber], [toString])\n      const result = rule('5')\n      expect(result).toBe(5)\n      expect(toNumber).toHaveBeenCalledWith('5')\n      expect(toString).not.toHaveBeenCalled()\n      expectTypeOf(result).toEqualTypeOf<number | string>()\n    })\n\n    it('should match undefined if the value is not a number', () => {\n      const rule = createRuleSet([assertStringNumber, Number], [assertUndefined])\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      const result = rule(undefined)\n      expect(result).toBeUndefined()\n      expectTypeOf(result).toEqualTypeOf<number | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => number | undefined>()\n    })\n\n    it('should match the second rule chain if the first rule chain fails', () => {\n      const throws = vi.fn(assertUndefined) as typeof assertUndefined\n      const toString = vi.fn(String) as (value: unknown) => string\n      const rule = createRuleSet([throws], [toString])\n      const result = rule(5)\n      expect(result).toBe('5')\n      expect(throws).toHaveBeenCalledWith(5)\n      expect(toString).toHaveBeenCalledWith(5)\n      expectTypeOf(result).toEqualTypeOf<string | undefined>()\n      expectTypeOf(rule).toEqualTypeOf<(value: unknown) => string | undefined>()\n    })\n\n    it('should throw an error if no rule chain passes', () => {\n      const throws = vi.fn(assertUndefined)\n      const rule = createRuleSet([throws], [throws])\n      const shouldThrow = () => rule(5)\n      expect(shouldThrow).toThrow(ValidationError)\n      expect(shouldThrow).toThrow('Expected value to match at least one rule chain in the set.')\n    })\n  })\n\n  describe('edge cases', () => {\n    it('should throw an error if a rule is not a function', () => {\n      // @ts-expect-error: testing invalid input\n      const shouldThrow = () => createRuleSet([5])\n      expect(shouldThrow).toThrow(TypeError)\n      expect(shouldThrow).toThrow('Rule must be a function')\n    })\n  })\n}\n"],"names":[],"mappings":";;;;;;;AAmCO,SAAS,iBAAwC,QAAkC;AACxF,QAAM,WAAW,OAAO,IAAI,WAAS,gBAAgB,GAAG,KAAK,CAAC;AAC9D,SAAO,SAAuB,OAAgB;AAC5C,UAAM,SAAkB,CAAA;AAIxB,eAAW,OAAO;AACZ,UAAA;AAAS,eAAA,IAAI,KAAK,MAAM,KAAK;AAAA,eAC1B,OAAO;AAAE,eAAO,KAAK,KAAc;AAAA,MAAE;AAI9C,UAAM,IAAI,gBAAgB;AAAA,MACxB,MAAM;AAAA,MACN,SAAS;AAAA,MACT;AAAA,IAAA,CACD;AAAA,EAAA;AAEL;"}
\ No newline at end of file
diff --git a/dist/createSchema.cjs b/dist/createSchema.cjs
index 3798d782bda8ef9ea69ce3ba9ada022da1153719..da54e979a620d44dc6822a980cf668fa64d46d5d 100644
--- a/dist/createSchema.cjs
+++ b/dist/createSchema.cjs
@@ -3,6 +3,7 @@ var tries = require("@unshared/functions/tries");
 require("./assert.cjs");
 var createRuleChain = require("./createRuleChain.cjs"), createRuleSet = require("./createRuleSet.cjs"), ValidationError = require("./ValidationError.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 require("./createRule.cjs");
 function createSchema(schema) {
@@ -17,7 +18,7 @@ function createSchema(schema) {
     if (!parse) throw new TypeError("The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.");
     schemaObject[key] = parse;
   }
-  return function(object) {
+  return function(object = {}) {
     const result = {};
     for (const key in schemaObject)
       try {
diff --git a/dist/createSchema.cjs.map b/dist/createSchema.cjs.map
index 2c916bb98cbff1424830d3d4f7fde49c7738d1aa..2c5fd73466f2e29a61de92b44fb96c733f5beb4e 100644
--- a/dist/createSchema.cjs.map
+++ b/dist/createSchema.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"createSchema.cjs","sources":["../createSchema.ts"],"sourcesContent":["import type { Function, Immutable, Pretty } from '@unshared/types'\nimport type { RuleLike, RuleResult } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport { tries } from '@unshared/functions/tries'\nimport { assertBoolean } from './assert'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A map of properties and their corresponding rules or sets of rules.\n *\n * @example { name: [isString, /\\w+/] }\n */\nexport interface SchemaLike {\n  [key: string]: RuleChainLike | RuleLike | RuleSetLike | SchemaLike\n}\n\n/**\n * The return type of a schema parser.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: RegExp> = { name: string }\n */\nexport type SchemaResult<T extends SchemaLike> = Pretty<{\n  [K in keyof T]:\n  T[K] extends SchemaLike ? SchemaResult<T[K]>\n    : T[K] extends RuleLike ? RuleResult<T[K]>\n      : T[K] extends RuleSetLike ? RuleSetResult<T[K]>\n        : T[K] extends RuleChainLike ? RuleChainResult<T[K]>\n          : never\n}>\n\n/**\n * A schema parser that can be used to validate and transform an object\n * given a map of properties and their corresponding rules or sets of rules.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: [RegExp, (value: string) => string] }>\n */\nexport type Schema<T extends SchemaLike> = (value: object) => SchemaResult<T>\n\n/**\n * Create a parser function given an object of rules or sets of rules.\n *\n * @param schema The schema to validate the value against.\n * @returns A parser function that can be used to validate a value.\n * @example\n * const parse = createParser({\n *   name: isString,\n *   age: [/\\d+/, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' })\n * expect(result).toEqual({ name: 'John', age: 25 })\n */\nexport function createSchema<T extends SchemaLike>(schema: Immutable<T>): Schema<T> {\n\n  // --- Compile the schema into a set of parsers.\n  const schemaObject: Record<string, Function> = {}\n  for (const key in schema) {\n    const rules: unknown = schema[key]\n    const parse = tries(\n      () => createRuleChain(rules as RuleLike),\n      () => createRuleChain(...rules as RuleChainLike),\n      () => createRuleSet(...rules as RuleSetLike),\n      () => createSchema(rules as SchemaLike),\n    )\n\n    // --- If none of the functions return a valid parser, throw an error.\n    if (!parse) throw new TypeError('The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.')\n    schemaObject[key] = parse\n  }\n\n  // --- Return a function that validates the value against the schema.\n  // --- For each key in the schema, validate and transform the value.\n  return function(object: FormData | Record<PropertyKey, unknown>) {\n    const result: Record<string, unknown> = {}\n    for (const key in schemaObject) {\n      try {\n        const rule = schemaObject[key]\n\n        // --- If the object is a FormData instance, get the value from the form data.\n        // --- If the key ends with '[]', get all values for the key.\n        if (object instanceof FormData) {\n          const formValue = object.getAll(key)\n          const value = formValue.length > 1 ? formValue : formValue[0]\n          result[key] = rule.call(object, value ?? undefined)\n        }\n\n        // --- Otherwise, get the value for the key.\n        else {\n          const value = object[key]\n          result[key] = rule.call(object, value)\n        }\n      }\n      catch (error) {\n        if (error instanceof ValidationError)\n          error.message = error.message.replace('Expected value', `Expected property \"${key}\"`)\n        throw error\n      }\n    }\n\n    return result\n  } as Schema<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertUndefined, assertStringNumber } = await import('./assert')\n\n  test('should create a schema and parse an object', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: { isAdmin: assertBoolean, isVerified: assertBoolean },\n    })\n\n    const result = parse({\n      name: 'John',\n      age: '25',\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expectTypeOf(result).toEqualTypeOf<{\n      name: string\n      email: string\n      age: number | undefined\n      flags: { isAdmin: boolean; isVerified: boolean }\n    }>()\n  })\n\n  test('should create a schema and parse a FormData instance', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: [assertString, x => x === 'true'],\n      optional: [[assertString, Number], [assertUndefined]],\n    })\n\n    const formData = new FormData()\n    formData.append('name', 'John')\n    formData.append('age', '25')\n    formData.append('email', 'john.doe@acme.com')\n    formData.append('flags', 'true')\n\n    const result = parse(formData)\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'john.doe@acme.com',\n      flags: true,\n      optional: undefined,\n    })\n  })\n\n  test('should throw a validation error if a rule fails', () => {\n    const parse = createSchema({ value: [[assertStringNumber], [assertUndefined]] })\n    const shouldThrow = () => parse({ value: 'not-a-number' })\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected property \"value\" to match at least one rule chain in the set.')\n  })\n}\n"],"names":["tries","createRuleChain","createRuleSet","ValidationError"],"mappings":";;;;;;;AA0DO,SAAS,aAAmC,QAAiC;AAGlF,QAAM,eAAyC,CAAA;AAC/C,aAAW,OAAO,QAAQ;AACxB,UAAM,QAAiB,OAAO,GAAG,GAC3B,QAAQA,MAAA;AAAA,MACZ,MAAMC,gBAAAA,gBAAgB,KAAiB;AAAA,MACvC,MAAMA,gBAAAA,gBAAgB,GAAG,KAAsB;AAAA,MAC/C,MAAMC,cAAAA,cAAc,GAAG,KAAoB;AAAA,MAC3C,MAAM,aAAa,KAAmB;AAAA,IAAA;AAIxC,QAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACxH,iBAAa,GAAG,IAAI;AAAA,EACtB;AAIA,SAAO,SAAS,QAAiD;AAC/D,UAAM,SAAkC,CAAA;AACxC,eAAW,OAAO;AACZ,UAAA;AACI,cAAA,OAAO,aAAa,GAAG;AAI7B,YAAI,kBAAkB,UAAU;AACxB,gBAAA,YAAY,OAAO,OAAO,GAAG,GAC7B,QAAQ,UAAU,SAAS,IAAI,YAAY,UAAU,CAAC;AAC5D,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,SAAS,MAAS;AAAA,QAAA,OAI/C;AACG,gBAAA,QAAQ,OAAO,GAAG;AACxB,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,KAAK;AAAA,QACvC;AAAA,eAEK,OAAO;AACR,cAAA,iBAAiBC,gBAAAA,oBACnB,MAAM,UAAU,MAAM,QAAQ,QAAQ,kBAAkB,sBAAsB,GAAG,GAAG,IAChF;AAAA,MACR;AAGK,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
+{"version":3,"file":"createSchema.cjs","sources":["../createSchema.ts"],"sourcesContent":["import type { Function, Immutable, Pretty } from '@unshared/types'\nimport type { RuleLike, RuleResult } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport { tries } from '@unshared/functions/tries'\nimport { assertBoolean } from './assert'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A map of properties and their corresponding rules or sets of rules.\n *\n * @example { name: [isString, /\\w+/] }\n */\nexport interface SchemaLike {\n  [key: string]: RuleChainLike | RuleLike | RuleSetLike | SchemaLike\n}\n\n/**\n * The return type of a schema parser.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: RegExp> = { name: string }\n */\nexport type SchemaResult<T extends SchemaLike> = Pretty<{\n  [K in keyof T]:\n  T[K] extends SchemaLike ? SchemaResult<T[K]>\n    : T[K] extends RuleLike ? RuleResult<T[K]>\n      : T[K] extends RuleSetLike ? RuleSetResult<T[K]>\n        : T[K] extends RuleChainLike ? RuleChainResult<T[K]>\n          : never\n}>\n\n/**\n * A schema parser that can be used to validate and transform an object\n * given a map of properties and their corresponding rules or sets of rules.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: [RegExp, (value: string) => string] }>\n */\nexport type Schema<T extends SchemaLike> = (value: object) => SchemaResult<T>\n\n/**\n * Create a parser function given an object of rules or sets of rules.\n *\n * @param schema The schema to validate the value against.\n * @returns A parser function that can be used to validate a value.\n * @example\n * const parse = createParser({\n *   name: isString,\n *   age: [/\\d+/, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' })\n * expect(result).toEqual({ name: 'John', age: 25 })\n */\nexport function createSchema<T extends SchemaLike>(schema: Immutable<T>): Schema<T> {\n\n  // --- Compile the schema into a set of parsers.\n  const schemaObject: Record<string, Function> = {}\n  for (const key in schema) {\n    const rules: unknown = schema[key]\n    const parse = tries(\n      () => createRuleChain(rules as RuleLike),\n      () => createRuleChain(...rules as RuleChainLike),\n      () => createRuleSet(...rules as RuleSetLike),\n      () => createSchema(rules as SchemaLike),\n    )\n\n    // --- If none of the functions return a valid parser, throw an error.\n    if (!parse) throw new TypeError('The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.')\n    schemaObject[key] = parse\n  }\n\n  // --- Return a function that validates the value against the schema.\n  // --- For each key in the schema, validate and transform the value.\n  return function(object: FormData | Record<PropertyKey, unknown> = {}) {\n    const result: Record<string, unknown> = {}\n    for (const key in schemaObject) {\n      try {\n        const rule = schemaObject[key]\n\n        // --- If the object is a FormData instance, get the value from the form data.\n        // --- If the key ends with '[]', get all values for the key.\n        if (object instanceof FormData) {\n          const formValue = object.getAll(key)\n          const value = formValue.length > 1 ? formValue : formValue[0]\n          result[key] = rule.call(object, value ?? undefined)\n        }\n\n        // --- Otherwise, get the value for the key.\n        else {\n          const value = object[key]\n          result[key] = rule.call(object, value)\n        }\n      }\n      catch (error) {\n        if (error instanceof ValidationError)\n          error.message = error.message.replace('Expected value', `Expected property \"${key}\"`)\n        throw error\n      }\n    }\n\n    return result\n  } as Schema<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertUndefined, assertStringNumber } = await import('./assert')\n\n  test('should create a schema and parse an object', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: { isAdmin: assertBoolean, isVerified: assertBoolean },\n    })\n\n    const result = parse({\n      name: 'John',\n      age: '25',\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expectTypeOf(result).toEqualTypeOf<{\n      name: string\n      email: string\n      age: number | undefined\n      flags: { isAdmin: boolean; isVerified: boolean }\n    }>()\n  })\n\n  test('should create a schema and parse a FormData instance', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: [assertString, x => x === 'true'],\n      optional: [[assertString, Number], [assertUndefined]],\n    })\n\n    const formData = new FormData()\n    formData.append('name', 'John')\n    formData.append('age', '25')\n    formData.append('email', 'john.doe@acme.com')\n    formData.append('flags', 'true')\n\n    const result = parse(formData)\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'john.doe@acme.com',\n      flags: true,\n      optional: undefined,\n    })\n  })\n\n  test('should throw a validation error if a rule fails', () => {\n    const parse = createSchema({ value: [[assertStringNumber], [assertUndefined]] })\n    const shouldThrow = () => parse({ value: 'not-a-number' })\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected property \"value\" to match at least one rule chain in the set.')\n  })\n}\n"],"names":["tries","createRuleChain","createRuleSet","ValidationError"],"mappings":";;;;;;;;AA0DO,SAAS,aAAmC,QAAiC;AAGlF,QAAM,eAAyC,CAAA;AAC/C,aAAW,OAAO,QAAQ;AACxB,UAAM,QAAiB,OAAO,GAAG,GAC3B,QAAQA,MAAA;AAAA,MACZ,MAAMC,gBAAAA,gBAAgB,KAAiB;AAAA,MACvC,MAAMA,gBAAAA,gBAAgB,GAAG,KAAsB;AAAA,MAC/C,MAAMC,cAAAA,cAAc,GAAG,KAAoB;AAAA,MAC3C,MAAM,aAAa,KAAmB;AAAA,IAAA;AAIxC,QAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACxH,iBAAa,GAAG,IAAI;AAAA,EACtB;AAIO,SAAA,SAAS,SAAkD,IAAI;AACpE,UAAM,SAAkC,CAAA;AACxC,eAAW,OAAO;AACZ,UAAA;AACI,cAAA,OAAO,aAAa,GAAG;AAI7B,YAAI,kBAAkB,UAAU;AACxB,gBAAA,YAAY,OAAO,OAAO,GAAG,GAC7B,QAAQ,UAAU,SAAS,IAAI,YAAY,UAAU,CAAC;AAC5D,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,SAAS,MAAS;AAAA,QAAA,OAI/C;AACG,gBAAA,QAAQ,OAAO,GAAG;AACxB,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,KAAK;AAAA,QACvC;AAAA,eAEK,OAAO;AACR,cAAA,iBAAiBC,gBAAAA,oBACnB,MAAM,UAAU,MAAM,QAAQ,QAAQ,kBAAkB,sBAAsB,GAAG,GAAG,IAChF;AAAA,MACR;AAGK,WAAA;AAAA,EAAA;AAEX;;"}
\ No newline at end of file
diff --git a/dist/createSchema.js b/dist/createSchema.js
index f08f6c1fecf39eb9d13fe567d165eabd58810617..d1843403792a61906657bbe0b14b2bf52f044694 100644
--- a/dist/createSchema.js
+++ b/dist/createSchema.js
@@ -4,6 +4,7 @@ import { createRuleChain } from "./createRuleChain.js";
 import { createRuleSet } from "./createRuleSet.js";
 import { ValidationError } from "./ValidationError.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 import "./createRule.js";
 function createSchema(schema) {
@@ -18,7 +19,7 @@ function createSchema(schema) {
     if (!parse) throw new TypeError("The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.");
     schemaObject[key] = parse;
   }
-  return function(object) {
+  return function(object = {}) {
     const result = {};
     for (const key in schemaObject)
       try {
diff --git a/dist/createSchema.js.map b/dist/createSchema.js.map
index 816ee19bdb433c33d5d5bd4449a5de8b3508f386..cccef59d5881e4a6b5cdadcba973f4f619ab03d3 100644
--- a/dist/createSchema.js.map
+++ b/dist/createSchema.js.map
@@ -1 +1 @@
-{"version":3,"file":"createSchema.js","sources":["../createSchema.ts"],"sourcesContent":["import type { Function, Immutable, Pretty } from '@unshared/types'\nimport type { RuleLike, RuleResult } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport { tries } from '@unshared/functions/tries'\nimport { assertBoolean } from './assert'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A map of properties and their corresponding rules or sets of rules.\n *\n * @example { name: [isString, /\\w+/] }\n */\nexport interface SchemaLike {\n  [key: string]: RuleChainLike | RuleLike | RuleSetLike | SchemaLike\n}\n\n/**\n * The return type of a schema parser.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: RegExp> = { name: string }\n */\nexport type SchemaResult<T extends SchemaLike> = Pretty<{\n  [K in keyof T]:\n  T[K] extends SchemaLike ? SchemaResult<T[K]>\n    : T[K] extends RuleLike ? RuleResult<T[K]>\n      : T[K] extends RuleSetLike ? RuleSetResult<T[K]>\n        : T[K] extends RuleChainLike ? RuleChainResult<T[K]>\n          : never\n}>\n\n/**\n * A schema parser that can be used to validate and transform an object\n * given a map of properties and their corresponding rules or sets of rules.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: [RegExp, (value: string) => string] }>\n */\nexport type Schema<T extends SchemaLike> = (value: object) => SchemaResult<T>\n\n/**\n * Create a parser function given an object of rules or sets of rules.\n *\n * @param schema The schema to validate the value against.\n * @returns A parser function that can be used to validate a value.\n * @example\n * const parse = createParser({\n *   name: isString,\n *   age: [/\\d+/, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' })\n * expect(result).toEqual({ name: 'John', age: 25 })\n */\nexport function createSchema<T extends SchemaLike>(schema: Immutable<T>): Schema<T> {\n\n  // --- Compile the schema into a set of parsers.\n  const schemaObject: Record<string, Function> = {}\n  for (const key in schema) {\n    const rules: unknown = schema[key]\n    const parse = tries(\n      () => createRuleChain(rules as RuleLike),\n      () => createRuleChain(...rules as RuleChainLike),\n      () => createRuleSet(...rules as RuleSetLike),\n      () => createSchema(rules as SchemaLike),\n    )\n\n    // --- If none of the functions return a valid parser, throw an error.\n    if (!parse) throw new TypeError('The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.')\n    schemaObject[key] = parse\n  }\n\n  // --- Return a function that validates the value against the schema.\n  // --- For each key in the schema, validate and transform the value.\n  return function(object: FormData | Record<PropertyKey, unknown>) {\n    const result: Record<string, unknown> = {}\n    for (const key in schemaObject) {\n      try {\n        const rule = schemaObject[key]\n\n        // --- If the object is a FormData instance, get the value from the form data.\n        // --- If the key ends with '[]', get all values for the key.\n        if (object instanceof FormData) {\n          const formValue = object.getAll(key)\n          const value = formValue.length > 1 ? formValue : formValue[0]\n          result[key] = rule.call(object, value ?? undefined)\n        }\n\n        // --- Otherwise, get the value for the key.\n        else {\n          const value = object[key]\n          result[key] = rule.call(object, value)\n        }\n      }\n      catch (error) {\n        if (error instanceof ValidationError)\n          error.message = error.message.replace('Expected value', `Expected property \"${key}\"`)\n        throw error\n      }\n    }\n\n    return result\n  } as Schema<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertUndefined, assertStringNumber } = await import('./assert')\n\n  test('should create a schema and parse an object', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: { isAdmin: assertBoolean, isVerified: assertBoolean },\n    })\n\n    const result = parse({\n      name: 'John',\n      age: '25',\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expectTypeOf(result).toEqualTypeOf<{\n      name: string\n      email: string\n      age: number | undefined\n      flags: { isAdmin: boolean; isVerified: boolean }\n    }>()\n  })\n\n  test('should create a schema and parse a FormData instance', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: [assertString, x => x === 'true'],\n      optional: [[assertString, Number], [assertUndefined]],\n    })\n\n    const formData = new FormData()\n    formData.append('name', 'John')\n    formData.append('age', '25')\n    formData.append('email', 'john.doe@acme.com')\n    formData.append('flags', 'true')\n\n    const result = parse(formData)\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'john.doe@acme.com',\n      flags: true,\n      optional: undefined,\n    })\n  })\n\n  test('should throw a validation error if a rule fails', () => {\n    const parse = createSchema({ value: [[assertStringNumber], [assertUndefined]] })\n    const shouldThrow = () => parse({ value: 'not-a-number' })\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected property \"value\" to match at least one rule chain in the set.')\n  })\n}\n"],"names":[],"mappings":";;;;;;;;AA0DO,SAAS,aAAmC,QAAiC;AAGlF,QAAM,eAAyC,CAAA;AAC/C,aAAW,OAAO,QAAQ;AACxB,UAAM,QAAiB,OAAO,GAAG,GAC3B,QAAQ;AAAA,MACZ,MAAM,gBAAgB,KAAiB;AAAA,MACvC,MAAM,gBAAgB,GAAG,KAAsB;AAAA,MAC/C,MAAM,cAAc,GAAG,KAAoB;AAAA,MAC3C,MAAM,aAAa,KAAmB;AAAA,IAAA;AAIxC,QAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACxH,iBAAa,GAAG,IAAI;AAAA,EACtB;AAIA,SAAO,SAAS,QAAiD;AAC/D,UAAM,SAAkC,CAAA;AACxC,eAAW,OAAO;AACZ,UAAA;AACI,cAAA,OAAO,aAAa,GAAG;AAI7B,YAAI,kBAAkB,UAAU;AACxB,gBAAA,YAAY,OAAO,OAAO,GAAG,GAC7B,QAAQ,UAAU,SAAS,IAAI,YAAY,UAAU,CAAC;AAC5D,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,SAAS,MAAS;AAAA,QAAA,OAI/C;AACG,gBAAA,QAAQ,OAAO,GAAG;AACxB,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,KAAK;AAAA,QACvC;AAAA,eAEK,OAAO;AACR,cAAA,iBAAiB,oBACnB,MAAM,UAAU,MAAM,QAAQ,QAAQ,kBAAkB,sBAAsB,GAAG,GAAG,IAChF;AAAA,MACR;AAGK,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
+{"version":3,"file":"createSchema.js","sources":["../createSchema.ts"],"sourcesContent":["import type { Function, Immutable, Pretty } from '@unshared/types'\nimport type { RuleLike, RuleResult } from './createRule'\nimport type { RuleChainLike, RuleChainResult } from './createRuleChain'\nimport type { RuleSetLike, RuleSetResult } from './createRuleSet'\nimport { tries } from '@unshared/functions/tries'\nimport { assertBoolean } from './assert'\nimport { createRuleChain } from './createRuleChain'\nimport { createRuleSet } from './createRuleSet'\nimport { ValidationError } from './ValidationError'\n\n/**\n * A map of properties and their corresponding rules or sets of rules.\n *\n * @example { name: [isString, /\\w+/] }\n */\nexport interface SchemaLike {\n  [key: string]: RuleChainLike | RuleLike | RuleSetLike | SchemaLike\n}\n\n/**\n * The return type of a schema parser.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: RegExp> = { name: string }\n */\nexport type SchemaResult<T extends SchemaLike> = Pretty<{\n  [K in keyof T]:\n  T[K] extends SchemaLike ? SchemaResult<T[K]>\n    : T[K] extends RuleLike ? RuleResult<T[K]>\n      : T[K] extends RuleSetLike ? RuleSetResult<T[K]>\n        : T[K] extends RuleChainLike ? RuleChainResult<T[K]>\n          : never\n}>\n\n/**\n * A schema parser that can be used to validate and transform an object\n * given a map of properties and their corresponding rules or sets of rules.\n *\n * @template T The type of the schema.\n * @example Schema<{ name: [RegExp, (value: string) => string] }>\n */\nexport type Schema<T extends SchemaLike> = (value: object) => SchemaResult<T>\n\n/**\n * Create a parser function given an object of rules or sets of rules.\n *\n * @param schema The schema to validate the value against.\n * @returns A parser function that can be used to validate a value.\n * @example\n * const parse = createParser({\n *   name: isString,\n *   age: [/\\d+/, Number]\n * })\n *\n * // Parse the value.\n * const result = parse({ name: 'John', age: '25' })\n * expect(result).toEqual({ name: 'John', age: 25 })\n */\nexport function createSchema<T extends SchemaLike>(schema: Immutable<T>): Schema<T> {\n\n  // --- Compile the schema into a set of parsers.\n  const schemaObject: Record<string, Function> = {}\n  for (const key in schema) {\n    const rules: unknown = schema[key]\n    const parse = tries(\n      () => createRuleChain(rules as RuleLike),\n      () => createRuleChain(...rules as RuleChainLike),\n      () => createRuleSet(...rules as RuleSetLike),\n      () => createSchema(rules as SchemaLike),\n    )\n\n    // --- If none of the functions return a valid parser, throw an error.\n    if (!parse) throw new TypeError('The value passed to createSchema is not a valid rule, rule chain, rule set, or schema.')\n    schemaObject[key] = parse\n  }\n\n  // --- Return a function that validates the value against the schema.\n  // --- For each key in the schema, validate and transform the value.\n  return function(object: FormData | Record<PropertyKey, unknown> = {}) {\n    const result: Record<string, unknown> = {}\n    for (const key in schemaObject) {\n      try {\n        const rule = schemaObject[key]\n\n        // --- If the object is a FormData instance, get the value from the form data.\n        // --- If the key ends with '[]', get all values for the key.\n        if (object instanceof FormData) {\n          const formValue = object.getAll(key)\n          const value = formValue.length > 1 ? formValue : formValue[0]\n          result[key] = rule.call(object, value ?? undefined)\n        }\n\n        // --- Otherwise, get the value for the key.\n        else {\n          const value = object[key]\n          result[key] = rule.call(object, value)\n        }\n      }\n      catch (error) {\n        if (error instanceof ValidationError)\n          error.message = error.message.replace('Expected value', `Expected property \"${key}\"`)\n        throw error\n      }\n    }\n\n    return result\n  } as Schema<T>\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  const { assertString, assertUndefined, assertStringNumber } = await import('./assert')\n\n  test('should create a schema and parse an object', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: { isAdmin: assertBoolean, isVerified: assertBoolean },\n    })\n\n    const result = parse({\n      name: 'John',\n      age: '25',\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'example@example.com',\n      flags: { isAdmin: true, isVerified: false },\n    })\n\n    expectTypeOf(result).toEqualTypeOf<{\n      name: string\n      email: string\n      age: number | undefined\n      flags: { isAdmin: boolean; isVerified: boolean }\n    }>()\n  })\n\n  test('should create a schema and parse a FormData instance', () => {\n    const parse = createSchema({\n      name: assertString,\n      email: [assertString, /\\w+@example\\.com/],\n      age: [[assertString, Number], [assertUndefined]],\n      flags: [assertString, x => x === 'true'],\n      optional: [[assertString, Number], [assertUndefined]],\n    })\n\n    const formData = new FormData()\n    formData.append('name', 'John')\n    formData.append('age', '25')\n    formData.append('email', 'john.doe@acme.com')\n    formData.append('flags', 'true')\n\n    const result = parse(formData)\n    expect(result).toStrictEqual({\n      name: 'John',\n      age: 25,\n      email: 'john.doe@acme.com',\n      flags: true,\n      optional: undefined,\n    })\n  })\n\n  test('should throw a validation error if a rule fails', () => {\n    const parse = createSchema({ value: [[assertStringNumber], [assertUndefined]] })\n    const shouldThrow = () => parse({ value: 'not-a-number' })\n    expect(shouldThrow).toThrow(ValidationError)\n    expect(shouldThrow).toThrow('Expected property \"value\" to match at least one rule chain in the set.')\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;AA0DO,SAAS,aAAmC,QAAiC;AAGlF,QAAM,eAAyC,CAAA;AAC/C,aAAW,OAAO,QAAQ;AACxB,UAAM,QAAiB,OAAO,GAAG,GAC3B,QAAQ;AAAA,MACZ,MAAM,gBAAgB,KAAiB;AAAA,MACvC,MAAM,gBAAgB,GAAG,KAAsB;AAAA,MAC/C,MAAM,cAAc,GAAG,KAAoB;AAAA,MAC3C,MAAM,aAAa,KAAmB;AAAA,IAAA;AAIxC,QAAI,CAAC,MAAa,OAAA,IAAI,UAAU,wFAAwF;AACxH,iBAAa,GAAG,IAAI;AAAA,EACtB;AAIO,SAAA,SAAS,SAAkD,IAAI;AACpE,UAAM,SAAkC,CAAA;AACxC,eAAW,OAAO;AACZ,UAAA;AACI,cAAA,OAAO,aAAa,GAAG;AAI7B,YAAI,kBAAkB,UAAU;AACxB,gBAAA,YAAY,OAAO,OAAO,GAAG,GAC7B,QAAQ,UAAU,SAAS,IAAI,YAAY,UAAU,CAAC;AAC5D,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,SAAS,MAAS;AAAA,QAAA,OAI/C;AACG,gBAAA,QAAQ,OAAO,GAAG;AACxB,iBAAO,GAAG,IAAI,KAAK,KAAK,QAAQ,KAAK;AAAA,QACvC;AAAA,eAEK,OAAO;AACR,cAAA,iBAAiB,oBACnB,MAAM,UAAU,MAAM,QAAQ,QAAQ,kBAAkB,sBAAsB,GAAG,GAAG,IAChF;AAAA,MACR;AAGK,WAAA;AAAA,EAAA;AAEX;"}
\ No newline at end of file
diff --git a/dist/index.cjs b/dist/index.cjs
index dd193aea81b491c96b8e2f02f44877c73fe6f459..573289efb9b0a64f14e3d98beba6e861872940a3 100644
--- a/dist/index.cjs
+++ b/dist/index.cjs
@@ -1,6 +1,7 @@
 "use strict";
 var assert = require("./assert.cjs"), createArrayParser = require("./createArrayParser.cjs"), createParser = require("./createParser.cjs"), createRule = require("./createRule.cjs"), createRuleChain = require("./createRuleChain.cjs"), createRuleSet = require("./createRuleSet.cjs"), createSchema = require("./createSchema.cjs"), isRuleLike = require("./isRuleLike.cjs"), ValidationError = require("./ValidationError.cjs");
 require("@unshared/functions/kindOf");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 require("@unshared/functions/tries");
 exports.EXP_EMAIL = assert.EXP_EMAIL;
@@ -11,6 +12,7 @@ exports.assertArrayNotEmpty = assert.assertArrayNotEmpty;
 exports.assertBoolean = assert.assertBoolean;
 exports.assertFalse = assert.assertFalse;
 exports.assertFalsy = assert.assertFalsy;
+exports.assertFunction = assert.assertFunction;
 exports.assertInstance = assert.assertInstance;
 exports.assertNil = assert.assertNil;
 exports.assertNotNil = assert.assertNotNil;
diff --git a/dist/index.cjs.map b/dist/index.cjs.map
index 4407e154a01c4a1fcbc760c1b549e32d98cf7f7f..a1ac0ce48c95612f5dffd2d0aa1371304e009167 100644
--- a/dist/index.cjs.map
+++ b/dist/index.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"index.cjs","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"index.cjs","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 78ab1487252cdbcd80bf99f5d2d52f6f8bda6895..71e6b2530e2d0b4e444f5d021c9d84d1ba54f446 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,4 +1,4 @@
-export { EXP_EMAIL, EXP_UUID, Email, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith } from './assert.js';
+export { EXP_EMAIL, EXP_UUID, Email, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertFunction, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith } from './assert.js';
 export { ArrayParser, createArrayParser } from './createArrayParser.js';
 export { Parser, ParserLike, ParserResult, createParser } from './createParser.js';
 export { Rule, RuleLike, RuleResult, createRule } from './createRule.js';
diff --git a/dist/index.js b/dist/index.js
index 2edab6fc68946a36b6a0441e52063ecf15512be2..42fc647c63baeb6b3eeefa6d2f6415fab12f9752 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -1,4 +1,4 @@
-import { EXP_EMAIL, EXP_UUID, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith } from "./assert.js";
+import { EXP_EMAIL, EXP_UUID, assertArray, assertArrayEmpty, assertArrayNotEmpty, assertBoolean, assertFalse, assertFalsy, assertFunction, assertInstance, assertNil, assertNotNil, assertNotNull, assertNotUndefined, assertNull, assertNumber, assertNumberBetween, assertNumberBetweenStrict, assertNumberEven, assertNumberInteger, assertNumberNegative, assertNumberNegativeStrict, assertNumberOdd, assertNumberPositive, assertNumberPositiveStrict, assertObject, assertString, assertStringConstantCase, assertStringEmail, assertStringEmpty, assertStringEndingWith, assertStringEnum, assertStringEquals, assertStringMatching, assertStringNotEmpty, assertStringNumber, assertStringStartingWith, assertStringUuid, assertTrue, assertUndefined, createAssertInstance, createAssertNumberBetween, createAssertNumberBetweenStrict, createAssertStringEndingWith, createAssertStringEnum, createAssertStringEquals, createAssertStringStartingWith } from "./assert.js";
 import { createArrayParser } from "./createArrayParser.js";
 import { createParser } from "./createParser.js";
 import { createRule } from "./createRule.js";
@@ -8,6 +8,7 @@ import { createSchema } from "./createSchema.js";
 import { isRuleLike } from "./isRuleLike.js";
 import { ValidationError } from "./ValidationError.js";
 import "@unshared/functions/kindOf";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 import "@unshared/functions/tries";
 export {
@@ -20,6 +21,7 @@ export {
   assertBoolean,
   assertFalse,
   assertFalsy,
+  assertFunction,
   assertInstance,
   assertNil,
   assertNotNil,
diff --git a/dist/index.js.map b/dist/index.js.map
index dff53aea1c07185b2437885e5991228f9db35e53..10a431c8e5b1ba6e19d1b7b492e3d4b95feb5db9 100644
--- a/dist/index.js.map
+++ b/dist/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":[],"sourcesContent":[],"names":[],"mappings":";;;;;;;;;;;;;"}
\ No newline at end of file
diff --git a/dist/isRuleLike.cjs b/dist/isRuleLike.cjs
index 6ab51d2675c1e5096b2dd7af0a6d5e1cf53efaf2..a8c65424bb459926f378b7b2ae5319ed5300f9e2 100644
--- a/dist/isRuleLike.cjs
+++ b/dist/isRuleLike.cjs
@@ -3,6 +3,7 @@ var createRule = require("./createRule.cjs");
 require("./assert.cjs");
 require("@unshared/functions/kindOf");
 require("./ValidationError.cjs");
+require("@unshared/functions");
 require("@unshared/string/toConstantCase");
 function isRuleLike(value) {
   try {
diff --git a/dist/isRuleLike.cjs.map b/dist/isRuleLike.cjs.map
index ed9420ee9be9580a8ebb9eb941b4aa3bd929bab1..932759ce3c84ba35903793321f65b1326a030324 100644
--- a/dist/isRuleLike.cjs.map
+++ b/dist/isRuleLike.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"isRuleLike.cjs","sources":["../isRuleLike.ts"],"sourcesContent":["import type { RuleLike } from './createRule'\nimport { createRule } from './createRule'\n\n/**\n * Checks if the value is a `ValidationRule`.\n *\n * @param value The value to check\n * @returns whether or not the value is a `ValidationRule`\n * @example\n *\n * // Create a rule\n * const isGreaterThan = x => x > 0\n *\n * // Check if the rule is valid\n * isRuleLike([isGreaterThan, 1]) // => true\n */\nexport function isRuleLike(value: any): value is RuleLike {\n  try {\n    createRule(value)\n    return true\n  }\n  catch {\n    return false\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should return true if value is a rule', () => {\n    const rule = (value: any) => value > 0\n    const result = isRuleLike(rule)\n    expect(result).toBe(true)\n  })\n\n  test('should return false if value is not a rule', () => {\n    const result = isRuleLike(5)\n    expect(result).toBe(false)\n  })\n}\n"],"names":["createRule"],"mappings":";;;;;;AAgBO,SAAS,WAAW,OAA+B;AACpD,MAAA;AACF,WAAAA,sBAAW,KAAK,GACT;AAAA,EAAA,QAEH;AACG,WAAA;AAAA,EACT;AACF;;"}
\ No newline at end of file
+{"version":3,"file":"isRuleLike.cjs","sources":["../isRuleLike.ts"],"sourcesContent":["import type { RuleLike } from './createRule'\nimport { createRule } from './createRule'\n\n/**\n * Checks if the value is a `ValidationRule`.\n *\n * @param value The value to check\n * @returns whether or not the value is a `ValidationRule`\n * @example\n *\n * // Create a rule\n * const isGreaterThan = x => x > 0\n *\n * // Check if the rule is valid\n * isRuleLike([isGreaterThan, 1]) // => true\n */\nexport function isRuleLike(value: any): value is RuleLike {\n  try {\n    createRule(value)\n    return true\n  }\n  catch {\n    return false\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should return true if value is a rule', () => {\n    const rule = (value: any) => value > 0\n    const result = isRuleLike(rule)\n    expect(result).toBe(true)\n  })\n\n  test('should return false if value is not a rule', () => {\n    const result = isRuleLike(5)\n    expect(result).toBe(false)\n  })\n}\n"],"names":["createRule"],"mappings":";;;;;;;AAgBO,SAAS,WAAW,OAA+B;AACpD,MAAA;AACF,WAAAA,sBAAW,KAAK,GACT;AAAA,EAAA,QAEH;AACG,WAAA;AAAA,EACT;AACF;;"}
\ No newline at end of file
diff --git a/dist/isRuleLike.js b/dist/isRuleLike.js
index ea09c771506c7cb60f78641e926879a567cc3fef..c9dfa5bfeea77e193230fbd9aa13187d62b6c58b 100644
--- a/dist/isRuleLike.js
+++ b/dist/isRuleLike.js
@@ -2,6 +2,7 @@ import { createRule } from "./createRule.js";
 import "./assert.js";
 import "@unshared/functions/kindOf";
 import "./ValidationError.js";
+import "@unshared/functions";
 import "@unshared/string/toConstantCase";
 function isRuleLike(value) {
   try {
diff --git a/dist/isRuleLike.js.map b/dist/isRuleLike.js.map
index 9f658b58da7707132a7fdd052ec59cc7da666c51..3146e6b8d137168a46997bbb0267db4318a74dd0 100644
--- a/dist/isRuleLike.js.map
+++ b/dist/isRuleLike.js.map
@@ -1 +1 @@
-{"version":3,"file":"isRuleLike.js","sources":["../isRuleLike.ts"],"sourcesContent":["import type { RuleLike } from './createRule'\nimport { createRule } from './createRule'\n\n/**\n * Checks if the value is a `ValidationRule`.\n *\n * @param value The value to check\n * @returns whether or not the value is a `ValidationRule`\n * @example\n *\n * // Create a rule\n * const isGreaterThan = x => x > 0\n *\n * // Check if the rule is valid\n * isRuleLike([isGreaterThan, 1]) // => true\n */\nexport function isRuleLike(value: any): value is RuleLike {\n  try {\n    createRule(value)\n    return true\n  }\n  catch {\n    return false\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should return true if value is a rule', () => {\n    const rule = (value: any) => value > 0\n    const result = isRuleLike(rule)\n    expect(result).toBe(true)\n  })\n\n  test('should return false if value is not a rule', () => {\n    const result = isRuleLike(5)\n    expect(result).toBe(false)\n  })\n}\n"],"names":[],"mappings":";;;;;AAgBO,SAAS,WAAW,OAA+B;AACpD,MAAA;AACF,WAAA,WAAW,KAAK,GACT;AAAA,EAAA,QAEH;AACG,WAAA;AAAA,EACT;AACF;"}
\ No newline at end of file
+{"version":3,"file":"isRuleLike.js","sources":["../isRuleLike.ts"],"sourcesContent":["import type { RuleLike } from './createRule'\nimport { createRule } from './createRule'\n\n/**\n * Checks if the value is a `ValidationRule`.\n *\n * @param value The value to check\n * @returns whether or not the value is a `ValidationRule`\n * @example\n *\n * // Create a rule\n * const isGreaterThan = x => x > 0\n *\n * // Check if the rule is valid\n * isRuleLike([isGreaterThan, 1]) // => true\n */\nexport function isRuleLike(value: any): value is RuleLike {\n  try {\n    createRule(value)\n    return true\n  }\n  catch {\n    return false\n  }\n}\n\n/* v8 ignore start */\nif (import.meta.vitest) {\n  test('should return true if value is a rule', () => {\n    const rule = (value: any) => value > 0\n    const result = isRuleLike(rule)\n    expect(result).toBe(true)\n  })\n\n  test('should return false if value is not a rule', () => {\n    const result = isRuleLike(5)\n    expect(result).toBe(false)\n  })\n}\n"],"names":[],"mappings":";;;;;;AAgBO,SAAS,WAAW,OAA+B;AACpD,MAAA;AACF,WAAA,WAAW,KAAK,GACT;AAAA,EAAA,QAEH;AACG,WAAA;AAAA,EACT;AACF;"}
